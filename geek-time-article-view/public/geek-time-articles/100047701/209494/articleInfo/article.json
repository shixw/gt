{"code":0,"data":{"video_id":"","sku":"100047701","video_cover":"","author_name":"朱晔","text_read_version":0,"audio_size":15529710,"article_cover":"https:\/\/static001.geekbang.org\/resource\/image\/fb\/ac\/fbeb4305979cac39df1e27392284fdac.jpg","subtitles":{},"product_type":"c1","audio_url":"https:\/\/res001.geekbang.org\/\/media\/audio\/5f\/ed\/5fdcdac948fa08ba18ebb2a93dc1b9ed\/ld\/ld.m3u8","chapter_id":"0","column_had_sub":true,"audio_dubber":"王少泽","is_finished":false,"inline_video_subtitles":{},"like":{"had_done":false,"count":258},"neighbors":{"left":{"id":209108,"article_title":"开篇词 | 业务代码真的会有这么多坑？"},"right":{"id":209520,"article_title":"02 | 代码加锁：不要让“锁”事成为烦心事"}},"audio_time":"00:18:29","video_height":0,"rate_percent":0,"article_content":"<p>你好，我是朱晔。作为课程的第一讲，我今天要和你聊聊使用并发工具类库相关的话题。<\/p><p>在代码审核讨论的时候，我们有时会听到有关线程安全和并发工具的一些片面的观点和结论，比如“把HashMap改为ConcurrentHashMap，就可以解决并发问题了呀”“要不我们试试无锁的CopyOnWriteArrayList吧，性能更好”。事实上，这些说法都不太准确。<\/p><p>的确，为了方便开发者进行多线程编程，现代编程语言会提供各种并发工具类。但如果我们没有充分了解它们的使用场景、解决的问题，以及最佳实践的话，盲目使用就可能会导致一些坑，小则损失性能，大则无法确保多线程情况下业务逻辑的正确性。<\/p><p>我需要先说明下，这里的并发工具类是指用来解决多线程环境下并发问题的工具类库。一般而言并发工具包括同步器和容器两大类，业务代码中使用并发容器的情况会多一些，我今天分享的例子也会侧重并发容器。<\/p><p>接下来，我们就看看在使用并发工具时，最常遇到哪些坑，以及如何解决、避免这些坑吧。<\/p><h2>没有意识到线程重用导致用户信息错乱的Bug<\/h2><p>之前有业务同学和我反馈，在生产上遇到一个诡异的问题，有时获取到的用户信息是别人的。查看代码后，我发现他使用了ThreadLocal来缓存获取到的用户信息。<\/p><!-- [[[read_end]]] --><p>我们知道，ThreadLocal适用于变量在线程间隔离，而在方法或类间共享的场景。如果用户信息的获取比较昂贵（比如从数据库查询用户信息），那么在ThreadLocal中缓存数据是比较合适的做法。但，这么做为什么会出现用户信息错乱的Bug呢？<\/p><p>我们看一个具体的案例吧。<\/p><p>使用Spring Boot创建一个Web应用程序，使用ThreadLocal存放一个Integer的值，来暂且代表需要在线程中保存的用户信息，这个值初始是null。在业务逻辑中，我先从ThreadLocal获取一次值，然后把外部传入的参数设置到ThreadLocal中，来模拟从当前上下文获取到用户信息的逻辑，随后再获取一次值，最后输出两次获得的值和线程名称。<\/p><pre><code>private static final ThreadLocal&lt;Integer&gt; currentUser = ThreadLocal.withInitial(() -&gt; null);\n\n\n@GetMapping(&quot;wrong&quot;)\npublic Map wrong(@RequestParam(&quot;userId&quot;) Integer userId) {\n    \/\/设置用户信息之前先查询一次ThreadLocal中的用户信息\n    String before  = Thread.currentThread().getName() + &quot;:&quot; + currentUser.get();\n    \/\/设置用户信息到ThreadLocal\n    currentUser.set(userId);\n    \/\/设置用户信息之后再查询一次ThreadLocal中的用户信息\n    String after  = Thread.currentThread().getName() + &quot;:&quot; + currentUser.get();\n    \/\/汇总输出两次查询结果\n    Map result = new HashMap();\n    result.put(&quot;before&quot;, before);\n    result.put(&quot;after&quot;, after);\n    return result;\n}\n\n<\/code><\/pre><p>按理说，在设置用户信息之前第一次获取的值始终应该是null，但我们要意识到，程序运行在Tomcat中，执行程序的线程是Tomcat的工作线程，而Tomcat的工作线程是基于线程池的。<\/p><p><strong>顾名思义，线程池会重用固定的几个线程，一旦线程重用，那么很可能首次从ThreadLocal获取的值是之前其他用户的请求遗留的值。这时，ThreadLocal中的用户信息就是其他用户的信息。<\/strong><\/p><p>为了更快地重现这个问题，我在配置文件中设置一下Tomcat的参数，把工作线程池最大线程数设置为1，这样始终是同一个线程在处理请求：<\/p><pre><code>server.tomcat.max-threads=1\n<\/code><\/pre><p>运行程序后先让用户1来请求接口，可以看到第一和第二次获取到用户ID分别是null和1，符合预期：<br>\n<img src=\"https:\/\/static001.geekbang.org\/resource\/image\/4b\/30\/4b8f38415d03423132c7a3608ebe2430.png?wh=1038*330\" alt=\"\"><\/p><p>随后用户2来请求接口，这次就出现了Bug，第一和第二次获取到用户ID分别是1和2，显然第一次获取到了用户1的信息，原因就是Tomcat的线程池重用了线程。从图中可以看到，两次请求的线程都是同一个线程：http-nio-8080-exec-1。<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/a9\/db\/a9ccd42716d807687b3acff9a0baf2db.png?wh=1042*332\" alt=\"\"><\/p><p>这个例子告诉我们，在写业务代码时，首先要理解代码会跑在什么线程上：<\/p><ul>\n<li>我们可能会抱怨学多线程没用，因为代码里没有开启使用多线程。但其实，可能只是我们没有意识到，在Tomcat这种Web服务器下跑的业务代码，本来就运行在一个多线程环境（否则接口也不可能支持这么高的并发），<strong>并不能认为没有显式开启多线程就不会有线程安全问题<\/strong>。<\/li>\n<li>因为线程的创建比较昂贵，所以Web服务器往往会使用线程池来处理请求，这就意味着线程会被重用。这时，<strong>使用类似ThreadLocal工具来存放一些数据时，需要特别注意在代码运行完后，显式地去清空设置的数据<\/strong>。如果在代码中使用了自定义的线程池，也同样会遇到这个问题。<\/li>\n<\/ul><p>理解了这个知识点后，我们修正这段代码的方案是，在代码的finally代码块中，显式清除ThreadLocal中的数据。这样一来，新的请求过来即使使用了之前的线程也不会获取到错误的用户信息了。修正后的代码如下：<\/p><pre><code>@GetMapping(&quot;right&quot;)\npublic Map right(@RequestParam(&quot;userId&quot;) Integer userId) {\n    String before  = Thread.currentThread().getName() + &quot;:&quot; + currentUser.get();\n    currentUser.set(userId);\n    try {\n        String after = Thread.currentThread().getName() + &quot;:&quot; + currentUser.get();\n        Map result = new HashMap();\n        result.put(&quot;before&quot;, before);\n        result.put(&quot;after&quot;, after);\n        return result;\n    } finally {\n        \/\/在finally代码块中删除ThreadLocal中的数据，确保数据不串\n        currentUser.remove();\n    }\n}\n<\/code><\/pre><p>重新运行程序可以验证，再也不会出现第一次查询用户信息查询到之前用户请求的Bug：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/0d\/cc\/0dfe40fca441b58d491fc799d120a7cc.png?wh=1028*332\" alt=\"\"><\/p><p>ThreadLocal是利用独占资源的方式，来解决线程安全问题，那如果我们确实需要有资源在线程之间共享，应该怎么办呢？这时，我们可能就需要用到线程安全的容器了。<\/p><h2>使用了线程安全的并发工具，并不代表解决了所有线程安全问题<\/h2><p>JDK 1.5后推出的ConcurrentHashMap，是一个高性能的线程安全的哈希表容器。“线程安全”这四个字特别容易让人误解，因为<strong>ConcurrentHashMap只能保证提供的原子性读写操作是线程安全的。<\/strong><\/p><p>我在相当多的业务代码中看到过这个误区，比如下面这个场景。有一个含900个元素的Map，现在再补充100个元素进去，这个补充操作由10个线程并发进行。开发人员误以为使用了ConcurrentHashMap就不会有线程安全问题，于是不加思索地写出了下面的代码：在每一个线程的代码逻辑中先通过size方法拿到当前元素数量，计算ConcurrentHashMap目前还需要补充多少元素，并在日志中输出了这个值，然后通过putAll方法把缺少的元素添加进去。<\/p><p>为方便观察问题，我们输出了这个Map一开始和最后的元素个数。<\/p><pre><code>\/\/线程个数\nprivate static int THREAD_COUNT = 10;\n\/\/总元素数量\nprivate static int ITEM_COUNT = 1000;\n\n\/\/帮助方法，用来获得一个指定元素数量模拟数据的ConcurrentHashMap\nprivate ConcurrentHashMap&lt;String, Long&gt; getData(int count) {\n    return LongStream.rangeClosed(1, count)\n            .boxed()\n            .collect(Collectors.toConcurrentMap(i -&gt; UUID.randomUUID().toString(), Function.identity(),\n                    (o1, o2) -&gt; o1, ConcurrentHashMap::new));\n}\n\n@GetMapping(&quot;wrong&quot;)\npublic String wrong() throws InterruptedException {\n    ConcurrentHashMap&lt;String, Long&gt; concurrentHashMap = getData(ITEM_COUNT - 100);\n    \/\/初始900个元素\n    log.info(&quot;init size:{}&quot;, concurrentHashMap.size());\n\n    ForkJoinPool forkJoinPool = new ForkJoinPool(THREAD_COUNT);\n    \/\/使用线程池并发处理逻辑\n    forkJoinPool.execute(() -&gt; IntStream.rangeClosed(1, 10).parallel().forEach(i -&gt; {\n        \/\/查询还需要补充多少个元素\n        int gap = ITEM_COUNT - concurrentHashMap.size();\n        log.info(&quot;gap size:{}&quot;, gap);\n        \/\/补充元素\n        concurrentHashMap.putAll(getData(gap));\n    }));\n    \/\/等待所有任务完成\n    forkJoinPool.shutdown();\n    forkJoinPool.awaitTermination(1, TimeUnit.HOURS);\n    \/\/最后元素个数会是1000吗？\n    log.info(&quot;finish size:{}&quot;, concurrentHashMap.size());\n    return &quot;OK&quot;;\n}\n\n<\/code><\/pre><p>访问接口后程序输出的日志内容如下：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/2e\/70\/2eaf5cd1b910b2678aca15fee6144070.png?wh=1918*580\" alt=\"\"><\/p><p>从日志中可以看到：<\/p><ul>\n<li>初始大小900符合预期，还需要填充100个元素。<\/li>\n<li>worker1线程查询到当前需要填充的元素为36，竟然还不是100的倍数。<\/li>\n<li>worker13线程查询到需要填充的元素数是负的，显然已经过度填充了。<\/li>\n<li>最后HashMap的总项目数是1536，显然不符合填充满1000的预期。<\/li>\n<\/ul><p>针对这个场景，我们可以举一个形象的例子。ConcurrentHashMap就像是一个大篮子，现在这个篮子里有900个桔子，我们期望把这个篮子装满1000个桔子，也就是再装100个桔子。有10个工人来干这件事儿，大家先后到岗后会计算还需要补多少个桔子进去，最后把桔子装入篮子。<\/p><p>ConcurrentHashMap这个篮子本身，可以确保多个工人在装东西进去时，不会相互影响干扰，但无法确保工人A看到还需要装100个桔子但是还未装的时候，工人B就看不到篮子中的桔子数量。更值得注意的是，你往这个篮子装100个桔子的操作不是原子性的，在别人看来可能会有一个瞬间篮子里有964个桔子，还需要补36个桔子。<\/p><p>回到ConcurrentHashMap，我们需要注意<strong>ConcurrentHashMap对外提供的方法或能力的限制<\/strong>：<\/p><ul>\n<li>使用了ConcurrentHashMap，不代表对它的多个操作之间的状态是一致的，是没有其他线程在操作它的，如果需要确保需要手动加锁。<\/li>\n<li>诸如size、isEmpty和containsValue等聚合方法，在并发情况下可能会反映ConcurrentHashMap的中间状态。因此在并发情况下，这些方法的返回值只能用作参考，而不能用于流程控制。显然，利用size方法计算差异值，是一个流程控制。<\/li>\n<li>诸如putAll这样的聚合方法也不能确保原子性，在putAll的过程中去获取数据可能会获取到部分数据。<\/li>\n<\/ul><p>代码的修改方案很简单，整段逻辑加锁即可：<\/p><pre><code>@GetMapping(&quot;right&quot;)\npublic String right() throws InterruptedException {\n    ConcurrentHashMap&lt;String, Long&gt; concurrentHashMap = getData(ITEM_COUNT - 100);\n    log.info(&quot;init size:{}&quot;, concurrentHashMap.size());\n\n\n    ForkJoinPool forkJoinPool = new ForkJoinPool(THREAD_COUNT);\n    forkJoinPool.execute(() -&gt; IntStream.rangeClosed(1, 10).parallel().forEach(i -&gt; {\n        \/\/下面的这段复合逻辑需要锁一下这个ConcurrentHashMap\n        synchronized (concurrentHashMap) {\n            int gap = ITEM_COUNT - concurrentHashMap.size();\n            log.info(&quot;gap size:{}&quot;, gap);\n            concurrentHashMap.putAll(getData(gap));\n        }\n    }));\n    forkJoinPool.shutdown();\n    forkJoinPool.awaitTermination(1, TimeUnit.HOURS);\n\n\n    log.info(&quot;finish size:{}&quot;, concurrentHashMap.size());\n    return &quot;OK&quot;;\n}\n<\/code><\/pre><p>重新调用接口，程序的日志输出结果符合预期：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/11\/b8\/1151b5b87f27073725060b76c56d95b8.png?wh=1910*556\" alt=\"\"><\/p><p>可以看到，只有一个线程查询到了需要补100个元素，其他9个线程查询到不需要补元素，最后Map大小为1000。<\/p><p>到了这里，你可能又要问了，使用ConcurrentHashMap全程加锁，还不如使用普通的HashMap呢。<\/p><p>其实不完全是这样。<\/p><p>ConcurrentHashMap提供了一些原子性的简单复合逻辑方法，用好这些方法就可以发挥其威力。这就引申出代码中常见的另一个问题：在使用一些类库提供的高级工具类时，开发人员可能还是按照旧的方式去使用这些新类，因为没有使用其特性，所以无法发挥其威力。<\/p><h2>没有充分了解并发工具的特性，从而无法发挥其威力<\/h2><p>我们来看一个使用Map来统计Key出现次数的场景吧，这个逻辑在业务代码中非常常见。<\/p><ul>\n<li>使用ConcurrentHashMap来统计，Key的范围是10。<\/li>\n<li>使用最多10个并发，循环操作1000万次，每次操作累加随机的Key。<\/li>\n<li>如果Key不存在的话，首次设置值为1。<\/li>\n<\/ul><p>代码如下：<\/p><pre><code>\/\/循环次数\nprivate static int LOOP_COUNT = 10000000;\n\/\/线程数量\nprivate static int THREAD_COUNT = 10;\n\/\/元素数量\nprivate static int ITEM_COUNT = 10;\nprivate Map&lt;String, Long&gt; normaluse() throws InterruptedException {\n    ConcurrentHashMap&lt;String, Long&gt; freqs = new ConcurrentHashMap&lt;&gt;(ITEM_COUNT);\n    ForkJoinPool forkJoinPool = new ForkJoinPool(THREAD_COUNT);\n    forkJoinPool.execute(() -&gt; IntStream.rangeClosed(1, LOOP_COUNT).parallel().forEach(i -&gt; {\n        \/\/获得一个随机的Key\n        String key = &quot;item&quot; + ThreadLocalRandom.current().nextInt(ITEM_COUNT);\n                synchronized (freqs) {      \n                    if (freqs.containsKey(key)) {\n                        \/\/Key存在则+1\n                        freqs.put(key, freqs.get(key) + 1);\n                    } else {\n                        \/\/Key不存在则初始化为1\n                        freqs.put(key, 1L);\n                    }\n                }\n            }\n    ));\n    forkJoinPool.shutdown();\n    forkJoinPool.awaitTermination(1, TimeUnit.HOURS);\n    return freqs;\n}\n<\/code><\/pre><p>我们吸取之前的教训，直接通过锁的方式锁住Map，然后做判断、读取现在的累计值、加1、保存累加后值的逻辑。这段代码在功能上没有问题，但无法充分发挥ConcurrentHashMap的威力，改进后的代码如下：<\/p><pre><code>private Map&lt;String, Long&gt; gooduse() throws InterruptedException {\n    ConcurrentHashMap&lt;String, LongAdder&gt; freqs = new ConcurrentHashMap&lt;&gt;(ITEM_COUNT);\n    ForkJoinPool forkJoinPool = new ForkJoinPool(THREAD_COUNT);\n    forkJoinPool.execute(() -&gt; IntStream.rangeClosed(1, LOOP_COUNT).parallel().forEach(i -&gt; {\n        String key = &quot;item&quot; + ThreadLocalRandom.current().nextInt(ITEM_COUNT);\n                \/\/利用computeIfAbsent()方法来实例化LongAdder，然后利用LongAdder来进行线程安全计数\n                freqs.computeIfAbsent(key, k -&gt; new LongAdder()).increment();\n            }\n    ));\n    forkJoinPool.shutdown();\n    forkJoinPool.awaitTermination(1, TimeUnit.HOURS);\n    \/\/因为我们的Value是LongAdder而不是Long，所以需要做一次转换才能返回\n    return freqs.entrySet().stream()\n            .collect(Collectors.toMap(\n                    e -&gt; e.getKey(),\n                    e -&gt; e.getValue().longValue())\n            );\n}\n<\/code><\/pre><p>在这段改进后的代码中，我们巧妙利用了下面两点：<\/p><ul>\n<li>使用ConcurrentHashMap的原子性方法computeIfAbsent来做复合逻辑操作，判断Key是否存在Value，如果不存在则把Lambda表达式运行后的结果放入Map作为Value，也就是新创建一个LongAdder对象，最后返回Value。<\/li>\n<li>由于computeIfAbsent方法返回的Value是LongAdder，是一个线程安全的累加器，因此可以直接调用其increment方法进行累加。<\/li>\n<\/ul><p><strong>这样在确保线程安全的情况下达到极致性能，把之前7行代码替换为了1行。<\/strong><\/p><p>我们通过一个简单的测试比较一下修改前后两段代码的性能：<\/p><pre><code>@GetMapping(&quot;good&quot;)\npublic String good() throws InterruptedException {\n    StopWatch stopWatch = new StopWatch();\n    stopWatch.start(&quot;normaluse&quot;);\n    Map&lt;String, Long&gt; normaluse = normaluse();\n    stopWatch.stop();\n    \/\/校验元素数量\n    Assert.isTrue(normaluse.size() == ITEM_COUNT, &quot;normaluse size error&quot;);\n    \/\/校验累计总数    \n    Assert.isTrue(normaluse.entrySet().stream()\n                    .mapToLong(item -&gt; item.getValue()).reduce(0, Long::sum) == LOOP_COUNT\n            , &quot;normaluse count error&quot;);\n    stopWatch.start(&quot;gooduse&quot;);\n    Map&lt;String, Long&gt; gooduse = gooduse();\n    stopWatch.stop();\n    Assert.isTrue(gooduse.size() == ITEM_COUNT, &quot;gooduse size error&quot;);\n    Assert.isTrue(gooduse.entrySet().stream()\n                    .mapToLong(item -&gt; item.getValue())\n                    .reduce(0, Long::sum) == LOOP_COUNT\n            , &quot;gooduse count error&quot;);\n    log.info(stopWatch.prettyPrint());\n    return &quot;OK&quot;;\n}\n<\/code><\/pre><p>这段测试代码并无特殊之处，使用StopWatch来测试两段代码的性能，最后跟了一个断言判断Map中元素的个数以及所有Value的和，是否符合预期来校验代码的正确性。测试结果如下：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/75\/3a\/751d484ecd8c3114c15588e7fff3263a.png?wh=922*254\" alt=\"\"><\/p><p>可以看到，<strong>优化后的代码，相比使用锁来操作ConcurrentHashMap的方式，性能提升了10倍<\/strong>。<\/p><p>你可能会问，computeIfAbsent为什么如此高效呢？<\/p><p>答案就在源码最核心的部分，也就是Java自带的Unsafe实现的CAS。它在虚拟机层面确保了写入数据的原子性，比加锁的效率高得多：<\/p><pre><code>    static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i,\n                                        Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) {\n        return U.compareAndSetObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);\n    }\n<\/code><\/pre><p>像ConcurrentHashMap这样的高级并发工具的确提供了一些高级API，只有充分了解其特性才能最大化其威力，而不能因为其足够高级、酷炫盲目使用。<\/p><h2>没有认清并发工具的使用场景，因而导致性能问题<\/h2><p>除了ConcurrentHashMap这样通用的并发工具类之外，我们的工具包中还有些针对特殊场景实现的生面孔。一般来说，针对通用场景的通用解决方案，在所有场景下性能都还可以，属于“万金油”；而针对特殊场景的特殊实现，会有比通用解决方案更高的性能，但一定要在它针对的场景下使用，否则可能会产生性能问题甚至是Bug。<\/p><p>之前在排查一个生产性能问题时，我们发现一段简单的非数据库操作的业务逻辑，消耗了超出预期的时间，在修改数据时操作本地缓存比回写数据库慢许多。查看代码发现，开发同学使用了CopyOnWriteArrayList来缓存大量的数据，而数据变化又比较频繁。<\/p><p>CopyOnWrite是一个时髦的技术，不管是Linux还是Redis都会用到。<strong>在Java中，CopyOnWriteArrayList虽然是一个线程安全的ArrayList，但因为其实现方式是，每次修改数据时都会复制一份数据出来，所以有明显的适用场景，即读多写少或者说希望无锁读的场景。<\/strong><\/p><p>如果我们要使用CopyOnWriteArrayList，那一定是因为场景需要而不是因为足够酷炫。如果读写比例均衡或者有大量写操作的话，使用CopyOnWriteArrayList的性能会非常糟糕。<\/p><p>我们写一段测试代码，来比较下使用CopyOnWriteArrayList和普通加锁方式ArrayList的读写性能吧。在这段代码中我们针对并发读和并发写分别写了一个测试方法，测试两者一定次数的写或读操作的耗时。<\/p><pre><code>\/\/测试并发写的性能\n@GetMapping(&quot;write&quot;)\npublic Map testWrite() {\n    List&lt;Integer&gt; copyOnWriteArrayList = new CopyOnWriteArrayList&lt;&gt;();\n    List&lt;Integer&gt; synchronizedList = Collections.synchronizedList(new ArrayList&lt;&gt;());\n    StopWatch stopWatch = new StopWatch();\n    int loopCount = 100000;\n    stopWatch.start(&quot;Write:copyOnWriteArrayList&quot;);\n    \/\/循环100000次并发往CopyOnWriteArrayList写入随机元素\n    IntStream.rangeClosed(1, loopCount).parallel().forEach(__ -&gt; copyOnWriteArrayList.add(ThreadLocalRandom.current().nextInt(loopCount)));\n    stopWatch.stop();\n    stopWatch.start(&quot;Write:synchronizedList&quot;);\n    \/\/循环100000次并发往加锁的ArrayList写入随机元素\n    IntStream.rangeClosed(1, loopCount).parallel().forEach(__ -&gt; synchronizedList.add(ThreadLocalRandom.current().nextInt(loopCount)));\n    stopWatch.stop();\n    log.info(stopWatch.prettyPrint());\n    Map result = new HashMap();\n    result.put(&quot;copyOnWriteArrayList&quot;, copyOnWriteArrayList.size());\n    result.put(&quot;synchronizedList&quot;, synchronizedList.size());\n    return result;\n}\n\n\/\/帮助方法用来填充List\nprivate void addAll(List&lt;Integer&gt; list) {\n    list.addAll(IntStream.rangeClosed(1, 1000000).boxed().collect(Collectors.toList()));\n}\n\n\/\/测试并发读的性能\n@GetMapping(&quot;read&quot;)\npublic Map testRead() {\n    \/\/创建两个测试对象\n    List&lt;Integer&gt; copyOnWriteArrayList = new CopyOnWriteArrayList&lt;&gt;();\n    List&lt;Integer&gt; synchronizedList = Collections.synchronizedList(new ArrayList&lt;&gt;());\n    \/\/填充数据   \n    addAll(copyOnWriteArrayList);\n    addAll(synchronizedList);\n    StopWatch stopWatch = new StopWatch();\n    int loopCount = 1000000;\n    int count = copyOnWriteArrayList.size();\n    stopWatch.start(&quot;Read:copyOnWriteArrayList&quot;);\n    \/\/循环1000000次并发从CopyOnWriteArrayList随机查询元素\n    IntStream.rangeClosed(1, loopCount).parallel().forEach(__ -&gt; copyOnWriteArrayList.get(ThreadLocalRandom.current().nextInt(count)));\n    stopWatch.stop();\n    stopWatch.start(&quot;Read:synchronizedList&quot;);\n    \/\/循环1000000次并发从加锁的ArrayList随机查询元素\n    IntStream.range(0, loopCount).parallel().forEach(__ -&gt; synchronizedList.get(ThreadLocalRandom.current().nextInt(count)));\n    stopWatch.stop();\n    log.info(stopWatch.prettyPrint());\n    Map result = new HashMap();\n    result.put(&quot;copyOnWriteArrayList&quot;, copyOnWriteArrayList.size());\n    result.put(&quot;synchronizedList&quot;, synchronizedList.size());\n    return result;\n}\n<\/code><\/pre><p>运行程序可以看到，<strong>大量写的场景（10万次add操作），<\/strong><strong>CopyOnWriteArray几乎比同步的ArrayList慢一百倍<\/strong>：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/97\/b4\/9789fe2019a1267b7883606b60e498b4.png?wh=940*252\" alt=\"\"><\/p><p>而在大量读的场景下（100万次get操作），CopyOnWriteArray又比同步的ArrayList快五倍以上：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/30\/36\/30ba652fb3295c58b03f51de0a132436.png?wh=970*270\" alt=\"\"><\/p><p>你可能会问，为何在大量写的场景下，CopyOnWriteArrayList会这么慢呢？<\/p><p>答案就在源码中。以add方法为例，每次add时，都会用Arrays.copyOf创建一个新数组，频繁add时内存的申请释放消耗会很大：<\/p><pre><code>    \/**\n     * Appends the specified element to the end of this list.\n     *\n     * @param e element to be appended to this list\n     * @return {@code true} (as specified by {@link Collection#add})\n     *\/\n    public boolean add(E e) {\n        synchronized (lock) {\n            Object[] elements = getArray();\n            int len = elements.length;\n            Object[] newElements = Arrays.copyOf(elements, len + 1);\n            newElements[len] = e;\n            setArray(newElements);\n            return true;\n        }\n    }\n<\/code><\/pre><h2>重点回顾<\/h2><p>今天，我主要与你分享了，开发人员使用并发工具来解决线程安全问题时容易犯的四类错。<\/p><p>一是，只知道使用并发工具，但并不清楚当前线程的来龙去脉，解决多线程问题却不了解线程。比如，使用ThreadLocal来缓存数据，以为ThreadLocal在线程之间做了隔离不会有线程安全问题，没想到线程重用导致数据串了。请务必记得，在业务逻辑结束之前清理ThreadLocal中的数据。<\/p><p>二是，误以为使用了并发工具就可以解决一切线程安全问题，期望通过把线程不安全的类替换为线程安全的类来一键解决问题。比如，认为使用了ConcurrentHashMap就可以解决线程安全问题，没对复合逻辑加锁导致业务逻辑错误。如果你希望在一整段业务逻辑中，对容器的操作都保持整体一致性的话，需要加锁处理。<\/p><p>三是，没有充分了解并发工具的特性，还是按照老方式使用新工具导致无法发挥其性能。比如，使用了ConcurrentHashMap，但没有充分利用其提供的基于CAS安全的方法，还是使用锁的方式来实现逻辑。你可以阅读一下<a href=\"https:\/\/docs.oracle.com\/javase\/8\/docs\/api\/java\/util\/concurrent\/ConcurrentHashMap.html\">ConcurrentHashMap的文档<\/a>，看一下相关原子性操作API是否可以满足业务需求，如果可以则优先考虑使用。<\/p><p>四是，没有了解清楚工具的适用场景，在不合适的场景下使用了错误的工具导致性能更差。比如，没有理解CopyOnWriteArrayList的适用场景，把它用在了读写均衡或者大量写操作的场景下，导致性能问题。对于这种场景，你可以考虑是用普通的List。<\/p><p>其实，这四类坑之所以容易踩到，原因可以归结为，我们在使用并发工具的时候，并没有充分理解其可能存在的问题、适用场景等。所以最后，<strong>我还要和你分享两点建议<\/strong>：<\/p><ol>\n<li>一定要认真阅读官方文档（比如Oracle JDK文档）。充分阅读官方文档，理解工具的适用场景及其API的用法，并做一些小实验。了解之后再去使用，就可以避免大部分坑。<\/li>\n<li>如果你的代码运行在多线程环境下，那么就会有并发问题，并发问题不那么容易重现，可能需要使用压力测试模拟并发场景，来发现其中的Bug或性能问题。<\/li>\n<\/ol><p>今天用到的代码，我都放在了GitHub上，你可以点击<a href=\"https:\/\/github.com\/JosephZhu1983\/java-common-mistakes\">这个链接<\/a>查看。<\/p><h2>思考与讨论<\/h2><ol>\n<li>今天我们多次用到了ThreadLocalRandom，你觉得是否可以把它的实例设置到静态变量中，在多线程情况下重用呢？<\/li>\n<li>ConcurrentHashMap还提供了putIfAbsent方法，你能否通过查阅<a href=\"https:\/\/docs.oracle.com\/javase\/8\/docs\/api\/java\/util\/concurrent\/ConcurrentHashMap.html\">JDK文档<\/a>，说说computeIfAbsent和putIfAbsent方法的区别？<\/li>\n<\/ol><p>你在使用并发工具时，还遇到过其他坑吗？我是朱晔，欢迎在评论区与我留言分享你的想法，也欢迎你把这篇文章分享给你的朋友或同事，一起交流。<\/p>","footer_cover_data":{"img_url":"","mp_url":"","link_url":""},"article_cover_hidden":false,"column_is_experience":false,"is_required":true,"rate":{},"product_id":100047701,"like_count":322,"had_liked":false,"article_subtitle":"","audio_download_url":"https:\/\/static001.geekbang.org\/resource\/audio\/5f\/ed\/5fdcdac948fa08ba18ebb2a93dc1b9ed.mp3","id":209494,"had_viewed":false,"article_title":"01 | 使用了并发工具类库，线程安全就高枕无忧了吗？","column_bgcolor":"#F6F7FB","share":{"content":"全面避坑 + 最佳实践=健壮代码","title":"朱晔 · Java业务开发常见错误100例","poster":"https:\/\/static001.geekbang.org\/resource\/image\/e8\/54\/e8431409c7d415a2216c38c3c0a74254.jpg","cover":"https:\/\/static001.geekbang.org\/resource\/image\/da\/da\/da765d454b0e5172a07d8a0c085b66da.jpg"},"is_video_preview":false,"article_summary":"我会分享使用并发工具类库容易踩的四类坑，踩坑原因可以归结为：使用并发工具时我们没有充分理解其可能存在的问题、适用场景等。","article_poster_wxlite":"https:\/\/static001.geekbang.org\/render\/screen\/d3\/b5\/d369c79bb1262a113bf0da5e96e8c4b5.jpeg","column_sale_type":2,"article_features":0,"article_could_preview":false,"column_cover":"https:\/\/static001.geekbang.org\/resource\/image\/da\/da\/da765d454b0e5172a07d8a0c085b66da.jpg","column_id":294,"audio_time_arr":{"m":"18","s":"29","h":"00"},"video_time":"","audio_title":"01-zy","audio_md5":"5fdcdac948fa08ba18ebb2a93dc1b9ed","video_size":0,"text_read_percent":0,"comment_count":104,"cid":294,"article_sharetitle":"使用了并发工具类库，线程安全就高枕无忧了吗？","column_is_onboard":true,"article_cshort":"<p>你好，我是朱晔。作为课程的第一讲，我今天要和你聊聊使用并发工具类库相关的话题。<\/p><p>在代码审核讨论的时候，我们有时会听到有关线程安全和并发工具的一些片面的观点和结论，比如“把HashMap改为ConcurrentHashMap，就可以解决并发问题了呀”“要不我们试试无锁的CopyOnWriteArrayList吧，性能更好”。事实上，这些说法都不太准确。<\/p><p>的确，为了方便开发者进行多线程编程，现代编程语言会提供各种并发工具类。但如果我们没有充分了解它们的使用场景、解决的问题，以及最佳实践的话，盲目使用就可能会导致一些坑，小则损失性能，大则无法确保多线程情况下业务逻辑的正确性。<\/p><p>我需要先说明下，这里的并发工具类是指用来解决多线程环境下并发问题的工具类库。一般而言并发工具包括同步器和容器两大类，业务代码中使用并发容器的情况会多一些，我今天分享的例子也会侧重并发容器。<\/p><p>接下来，我们就看看在使用并发工具时，最常遇到哪些坑，以及如何解决、避免这些坑吧。<\/p><h2>没有意识到线程重用导致用户信息错乱的Bug<\/h2><p>之前有业务同学和我反馈，在生产上遇到一个诡异的问题，有时获取到的用户信息是别人的。查看代码后，我发现他使用了ThreadLocal来缓存获取到的用户信息。<\/p>","video_width":0,"column_could_sub":true,"article_ctime":1583744460,"score":"21583744460","video_media_map":{},"video_preview":{},"video":0,"video_time_arr":{"m":"","s":"","h":""},"video_total_seconds":0},"extra":{},"error":{}}