{"code":0,"data":{"video_id":"","sku":"100114001","video_cover":"","author_name":"丁威","text_read_version":0,"audio_size":23022209,"article_cover":"https:\/\/static001.geekbang.org\/resource\/image\/ec\/ae\/ec0fa87bf485269fbddbd2dd23a2edae.jpg","subtitles":{},"product_type":"c1","audio_url":"https:\/\/res001.geekbang.org\/media\/audio\/92\/fb\/92baf5f98c55b42bcbc6cc76615a5efb\/ld\/ld.m3u8","chapter_id":"0","column_had_sub":true,"audio_dubber":"丁威","is_finished":false,"inline_video_subtitles":{},"like":{"had_done":false,"count":1},"neighbors":{"left":{"id":528224,"article_title":"02｜中间件生态（下）：同类型的中间件如何进行选型？"},"right":{"id":530329,"article_title":"04 | 红黑树：图解红黑树的构造过程与应用场景"}},"audio_time":"00:24:02","video_height":0,"rate_percent":0,"article_content":"<p>你好，我是丁威。<\/p><p>从这节课开始，我们就要进行基础篇的学习了。想要熟练使用中间件解决各种各样的问题，首先需要掌握中间件的基础知识。<\/p><p>我认为，中间件主要包括如下三方面的基础：数据结构、JUC和Netty，接下来的两节课，我们先讲数据结构。<\/p><p>数据结构主要解决的是数据的存储方式问题，是程序设计的基座。<\/p><p>按照重要性和复杂程度，我选取了数组和链表、键值对(HashMap)、红黑树、LinkedHashMap和PriorityQueue几种数据结构重点解析。其中，数组与链表是最底层的两种结构，是后续所有数据结构的基础。<\/p><p>我会带你分析每种结构的存储结构、新增元素和搜索元素的方式、扩容机制等，让你迅速抓住数据结构底层的特性。当然，我还会结合一些工业级实践，带你深入理解这些容器背后蕴含的设计理念。<\/p><p>说明一下，数据结构其实并不区分语言，但为了方便阐述，这节课我主要基于Java语言进行讲解。<\/p><h2>数组<\/h2><p>我们先来看下数组。<\/p><p>数组是用于储存多个相同类型数据的集合，它具有顺序性，并且也要求内存空间必须连续。高级编程语言基本都会提供数组的实现。<\/p><p>为了更直观地了解数组的内存布局，我们假设从操作系统申请了128字节的内存空间，它的数据结构可以参考下面这张图：<\/p><!-- [[[read_end]]] --><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/09\/57\/09c4065e6081fc190a87662c0101b357.jpg?wh=1920x505\" alt=\"图片\"><\/p><p>结合这张图我们可以看到，在Java中，数组通常包含下面几个部分。<\/p><ul>\n<li>引用：每一个变量都会在栈中存储数组的引用，我们可以通过引用对数组进行操作，对应上图的 array1、array2。<\/li>\n<li>容量：数组在创建时需要指定容量，一旦创建，无法修改，也就是说，数组并不能自动扩容。<\/li>\n<li>下标：数组可以通过下标对数组中的元素进行随机访问，例如array1[0]表示访问数组中的第一个元素，下标从0开始，其最大值为容量减一。<\/li>\n<\/ul><p>在后面的讲解中，你能看到很多数据结构都是基于数组而构建的。<\/p><p>那么数组有哪些特性呢？这里我想介绍两个我认为最重要的点：<strong>内存连续性和随机访问效率高。<\/strong><\/p><p>我们先来看下内存连续性。<\/p><p>内存连续性的意思是，数组在向操作系统申请内存时，申请的必须是连续的内存空间。我们还是继续用上面这个例子做说明。我们已经创建了array1、array2两个数组，如果想要再申请一个拥有五个int元素的数组，能把这五个元素拆开，分别放在数组1的前面和后面吗？你可以看看下面这张示意图。<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/2e\/bc\/2e13df9e8ea3526801415096d62c72bc.jpg?wh=1920x589\" alt=\"图片\"><\/p><p>答案当然是不可以。<\/p><p>虽然当前内存中剩余可用空间为32个字节，乍一看上去有充足的内存。但是，因为不存在连续的20字节的空间，所以不能直接创建array3。<\/p><p>当我们想要创建20字节长度的array3时，在Java中会触发一次内存回收，如果垃圾回收器支持整理特性，那么垃圾回收器对内存进行回收后，我们就可以得到一个新的布局：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/f2\/b8\/f2caf59b16797abb34fd61d2c5dedfb8.jpg?wh=1920x463\" alt=\"图片\"><\/p><p>经过内存整理后就能创建数组3了。也就是说，如果内存管理不当，确实容易产生内存碎片，从而影响性能。<\/p><p>那我们为什么要把内存设计为连续的呢？换句话说，连续内存有什么好处呢？<\/p><p>这就不得不提到数组一个无可比拟的优势了：<strong>数组的随机访问性能极好<\/strong>。<strong>连续内存确保了地址空间的连续性，寻址非常简单高效。<\/strong><\/p><p>举个例子，我们创建一个存放int数据类型的数组，代码如下：<\/p><pre><code class=\"language-plain\">int[] array1 = new int[10];\n<\/code><\/pre><p>然后我们看下JVM中的布局：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/7b\/d1\/7b5a75b843b04f09349ea95d1077d0d1.jpg?wh=1920x722\" alt=\"图片\"><\/p><p>可以看到，首先内存管理器在栈空间会分配一段空间，用它存储数组在物理内存的起始地址，这个起始地址我们用baseOffset表示。如果是64位操作系统，默认一个变量使用8字节，如果采用了指针压缩技术，可以减少到4字节。<\/p><p><strong>数组能够高效地随机访问数组中的元素，主要原因是它能够根据下标快速计算出真实的物理地址，寻找算法为“baseOffset + index * size”。<\/strong><\/p><p>其中,size为数组中单个元素的长度，是一个常量。在上面这个数组中，存储的元素是int类型的数据，所以size为4。因此，我们根据数组下标就可以迅速找到对应位置存储的数据。<\/p><p>数组这种高效的访问机制在中间件领域有着非常广泛的应用，大名鼎鼎的消息中间件RocketMQ在它的文件设计中就灵活运用了这个特性。<\/p><p>RocketMQ为了追求消息写入时极致的顺序写，会把所有主题的消息全部顺序写入到commitlog文件中。也就是说，commitlog文件中混杂着各个主题的消息，但消息消费时，需要根据主题、队列、消费位置向消息服务器拉取消息。如果想从commitlog文件中读取消息，则需要遍历commitlog文件中的所有消息，检索性能非常低下。<\/p><p>一开始，为了提高检索效率，RocketMQ引入了ConsumeQueue文件，可以理解为commitlog文件按照主题创建索引。<\/p><p>为了在消费端支持消息按tag进行消息过滤，索引数据中需要包含消息的tag信息，它的数据类型是String，索引文件遵循{topic}\/{queueId}，也就是按照主题、队列两级目录存储。单个索引文件的存储结构设计如下图所示：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/37\/cc\/37d00ef801366678bdd99e5966f74ecc.jpg?wh=1920x568\" alt=\"图片\"><\/p><p>索引文件中，每一条消息都包含偏移量、消息长度和tag内容 3个字段。<\/p><ul>\n<li>\n<p>commitlog偏移量<br>\n可以根据该值快速从commitlog文件中找到消息，这也是索引文件的意义。<\/p>\n<\/li>\n<li>\n<p>消息长度<br>\n消息的长度，知道它可以方便我们快速提取一条完整的消息。<\/p>\n<\/li>\n<li>\n<p>tag内容<br>\n由于消息的tag是由用户定义的，例如tagA、createorder等，它的长度可变。在文件存储领域，一般存储可变长的数据，通常会采用“长度字段+具体内容”的存储方式。其中用来存储内容的长度使用固定长度，它是用来记录后边内容的长度。<\/p>\n<\/li>\n<\/ul><p>回到消息消费这个需求，我们根据主题、消费组，消息位置(队列中存储的第N条消息)，能否快速找到消息呢？例如输入 topic:order_topic、queueId:0,offset:2，能不能马上找到第N条消息？<\/p><p>答案是可以找到，但不那么高效。原因是，我们根据topic、queueid，能非常高效地找到对应的索引文件。我们只需要找到对应的topic文件夹，然后在它的子目录中找到对应的队列id文件夹就可以了。但要想从索引文件中找到具体条目，我们还是必须遍历索引文件中的每一个条目，直到到达offset的条目，才能取出对应的commitlog偏移量。<\/p><p>那是否有更高效的索引方式呢？<\/p><p>当然有，我们可以将每一个条目设计成固定长度，然后按照数组下标的方式进行检索。<\/p><p>为了实现每一个条目定长，我们在这里不存储tag的原始字符串，而是存储原始字符串的hashCode，这样就可以确保定长了。你可以看看下面这张设计图：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/6d\/3b\/6ddd2f39e7a4261caeef32248b29893b.jpg?wh=1920x487\" alt=\"图片\"><\/p><p>基于这种设计，如果给定一个offset，我们再想快速提取一条索引就变得非常简单了。<\/p><p>首先，根据 offset * 20(每一个条目的长度)，定位到需要查找条目的起始位置，用startOffset表示。<\/p><p>然后，从startOffset位置开始读取20个字节的长度，就可以得到物理偏移量、消息长度和tag的hashCode了。<\/p><p>接着，我们可以通过hashCode进行第一次过滤，如果遇到hash冲突，就让客户端再根据消息的tag字符串精确过滤一遍。<\/p><p>这种方式，显然借鉴了数组高效访问数据的设计理念，是数组实现理念在文件存储过程中的经典运用。<\/p><p>总之，正是由于数组具有内存连续性，具有随机访问的特性，它在存储设计领域的应用才非常广泛，我们后面介绍的HashMap也引入了数组。<\/p><h2>ArrayList<\/h2><p>不过，数组从严格意义上来说是面向过程编程中的产物，而Java是一门面向对象编程的语言，所以，直接使用数组容易破坏面向对象的编程范式，故面向对象编程语言都会对数组进行更高级别的抽象，在Java中对应的就是ArrayList。<\/p><p>我会从数据存储结构、扩容机制、数据访问特性三个方面和你一起来探究一下ArrayList。<\/p><p>首先我们来看一下ArrayList的底层存储结构，你可以先看下这个示意图：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/ef\/a2\/efc6558677927715d84a4af456d117a2.jpg?wh=1920x357\" alt=\"图片\"><\/p><p>从图中可以看出，ArrayList的底层数据直接使用了数组，是对数组的抽象。<\/p><p>ArrayList相比数组，增加了一个特性，它支持自动扩容。其扩容机制如下图所示：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/48\/db\/48d1bdc69795a3d3b0e03e79eb5fdcdb.jpg?wh=1920x702\" alt=\"\"><\/p><p>扩容的实现有三个要点。<\/p><ul>\n<li>扩容后的容量= 原容量 +（原容量）\/ 2，以 1.5 倍进行扩容。<\/li>\n<li>内部要创建一个新的数组，数组长度为扩容后的新长度。<\/li>\n<li>需要将原数组中的内容拷贝到新的数组，即扩容过程中存在内存复制等较重的操作。<\/li>\n<\/ul><p><strong>注意，只在当前无剩余空间时才会触发扩容。在实际的使用过程中，我们要尽量做好容量评估，减少扩容的发生。因为扩容的成本还是比较高的，存储的数据越多，扩容的成本越高。<\/strong><\/p><p>接下来，我们来看一下ArrayList的数据访问特性。<\/p><ul>\n<li>顺序添加元素的效率高<\/li>\n<\/ul><p>ArrayList顺序添加元素，如果不需要扩容，直接将新的数据添加到elementData[size]位置，然后size加一即可（其中，size表示当前数组中存储的元素个数）。<\/p><p>ArrayList添加元素的时间复杂度为O(1)，也就是说它不会随着存储数据的大小而改变，是非常高效的存储方式。<\/p><ul>\n<li>中间位置插入\/删除元素的效率低<br>\n<img src=\"https:\/\/static001.geekbang.org\/resource\/image\/e7\/b8\/e74e9012db10cd7dc524831c697f5cb8.jpg?wh=1205x858\" alt=\"图片\"><\/li>\n<\/ul><p>在插入元素时，我们将需要插入数据的下标用 index 表示，将 index 之后的依次向后移动(复制到 index + 1)，然后将新数据存储在下标 index的位置。<\/p><p>删除操作与插入类似，只是一个数据是往后移，而删除动作是往前移。<\/p><p>ArrayList在中间位置进行删除的时间复杂度为O(n)，这是一个比较低效的操作。<\/p><ul>\n<li>随机访问性能高<\/li>\n<\/ul><p>由于ArrayList的底层就是数组，因此它拥有高效的随机访问数据特性。<\/p><h2>LinkedList<\/h2><p>除了ArrayList，在数据结构中，还有一种也很经典的数据结构：链表。LinkedList就是链表的具体实现。<\/p><p>我们先来看一下LinkedList的底层存储结构，最后再对比一下它和ArrayList的差异。<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/9f\/73\/9fb78d978bf28813c88aa381cfb93973.jpg?wh=1920x723\" alt=\"图片\"><\/p><p>从上面这张图你可以看到，一个LinkedList对象在内存中通常由两部分组成：LinkedList对象和由Node节点组成的链条。<\/p><p>一个LinkedList对象在内存中主要包含3个字段。<\/p><ul>\n<li>int size：链表中当前存在的Node节点数，主要用来判断是否为空、判断随机访问位点是否存在；<\/li>\n<li>Node first：指向链表的头节点；<\/li>\n<li>Node last：指向链表的尾节点。<\/li>\n<\/ul><p>再来说说由Node节点组成的链条。Node节点用于存储真实的数据，并维护两个指针。分别解释一下。<\/p><ul>\n<li>E item：拥有存储用户数据；<\/li>\n<li>Node prev：前驱节点，指向当前节点的前一个指针；<\/li>\n<li>Node last：后继节点，指向当前节点的下一个节点。<br>\n由这两部分构成的链表具有一个非常典型的特征：<strong>内存的申请无须连续性<\/strong>。这就减少了内存申请的限制。<\/li>\n<\/ul><p>接下来我们来看看如何操作链表。对于链表的操作主要有两类，一类是在链表前后添加或删除节点，一类是在链表中间添加或删除数据。<\/p><p>当你想要在链表前后添加或删除节点时，因为我们在LinkedList对象中持有链表的头尾指针，可以非常快地定位到头部或尾部节点。也就是说，这时如果我们想要增删数据，都只需要更新相关的前驱或后继节点就可以了，具体操作如下图所示：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/71\/a2\/71723714cf880891a0b7a49440bf42a2.jpg?wh=1920x530\" alt=\"图片\"><\/p><p>举个例子，如果我们向尾部节点添加节点，它的代码是这样的：<\/p><pre><code class=\"language-plain\">Node oldLastNode = list.last; \/\/添加数据之前原先的尾部节点\nNode newNode = new Node();\nnewNode.item = 4;\/\/设置用户的值\noldLastNode.next = newNode; \/\/ 将原先尾部节点的next指针更新为新添加的节点\nnewNode.prev = oldLastNode; \/\/ 新添加的节点的prev指向源尾部节点，通过这两步，使新加入的节点添加到链表中\nlist.last = newNode; \/\/ 更新LinkedList的尾部节点为新添加节点\n<\/code><\/pre><p>在链表的尾部、头部添加和删除数据，时间复杂度都是O(1)，比ArrayList在尾部添加节点效率要高。因为当ArrayList需要扩容时，会触发数据的大量复制，而LinkedList是一个无界队列，不存在扩容问题。<\/p><p>如果要在链表的中间添加或删除数据，我们首先需要遍历链表，找到操作节点。因为链表是非连续内存，无法像数组那样直接根据下标快速定位到内存地址。<\/p><p>例如，在下标index为1的后面插入新的数据，它的操作示例图如下：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/bd\/92\/bd79fd4b138507339412e3d325f53d92.jpg?wh=1920x1763\" alt=\"图片\"><\/p><p>我们从上往下看。插入新节点的第一步是需要从头节点开始遍历，找到下标为i=1的节点，然后在该节点的后面插入节点，最后执行插入节点的逻辑。<\/p><p>插入节点的具体实现主要是为了维护链表中相关操作节点的前驱与后继节点。<\/p><p>遍历链表、查询操作节点的时间复杂度为O(n)，然后基于操作节点进行插入与删除动作的时间复杂度为O(1)。<\/p><p>关于链表的知识点就讲到这里。由于链表与数组是数据结构中两种最基本的存储结构，为了让你更直观地了解二者的差异，我也给你画了一个表格，对两种数据结构做了对比：<\/p><h2><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/26\/32\/267cd926d583043d2b1909byy2d37132.jpg?wh=1920x1028\" alt=\"图片\"><\/h2><h2>HashMap<\/h2><p>无论是链表还是数组都是一维的，在现实世界中有一种关系也非常普遍：关联关系。关联关系在计算机领域主要是用键值对来实现，HashMap就是基于哈希表Map接口的具体实现。<\/p><p>JDK1.8版本之前，HashMap的底层存储结构如下图所示：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/7a\/c8\/7a0bdacf9de99f5ef3d064caa7f6ffc8.jpg?wh=1920x906\" alt=\"图片\"><\/p><p>HashMap的存储结构主体是哈希槽与链表的组合，类似一个抽屉。<\/p><p>我们向HashMap中添加一个键值对，用这个例子对HashMap的存储结构做进一步说明。<\/p><p>HashMap内部持有一个Map.Entry[]的数组，俗称哈希槽。当我们往HashMap中添加一个键值对时，HashMap会根据Key的hashCode与槽的总数进行取模，得出槽的位置(也就是数组的下标)，然后判断槽中是否已经存储了数据。如果未存储数据，则直接将待添加的键值对存入指定的槽；如果槽中存在数据，那就将新的数据加入槽对应的链表中，解决诸如哈希冲突的问题。<\/p><p>在HashMap中，单个键值对用一个Map.Entry结构表示，具体字段信息如下。<\/p><ul>\n<li>K key：存储的Key，后续可以用该Key进行查找<\/li>\n<li>V value：存储的Value；<\/li>\n<li>int hash：Key的哈希值；<\/li>\n<li>Ma.Entry ：next 链表。<\/li>\n<\/ul><p>到这里，你可以停下来思考一下，当哈希槽中已经存在数据时，新加入的元素是存储在链表的头部还是尾部呢？<\/p><p>答案是放在头部。代码如下：<\/p><pre><code class=\"language-plain\">\/\/假设新放入的槽位下标用 index 表示,哈希槽用 hashArray 表示\nMap.Entry newEntry = new Map.Entry(key,value);\nnewEntry.next = hashArray[index];\nhashArray[index] = newEntry;\n<\/code><\/pre><p>我们将新增加的元素放到链表的头部，也就是直接放在哈希槽中，然后用next指向原先存在于哈希槽中的元素。<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/0b\/c5\/0b29590ca607556yyc816ff867313ac5.jpg?wh=1920x1041\" alt=\"图片\"><\/p><p>这种方式的妙处在于，只涉及两个指针的修改。如果我们把新增加的元素放入链表的头部，链表的复杂度为O(1)。相反，如果我们把新元素放到链表的尾部，那就需要遍历整条链表，写入复杂度会有所提高，随着哈希表中存储的数据越来越多，那么新增数据的性能将随着链表长度的增加而逐步降低。<\/p><p>介绍完添加元素，我们来看一下元素的查找流程，也就是如何根据Key查找到指定的键值对。<\/p><p>首先，计算Key的hashCode，然后与哈希槽总数进行取模，得到对应哈希槽下标。<\/p><p>然后，访问哈希槽中对应位置的数据。如果数据为空，则返回“未找到元素”。如果哈希槽对应位置的数据不为空，那我们就要判断Key值是否匹配了。如果匹配，则返回当前数据；如果不匹配，则需要遍历哈希槽，如果遍历到链表尾部还没有匹配到任何元素，则返回“未找到元素”。<\/p><p>说到这里，我们不难得出这样一个结论：如果没有发生哈希槽冲突，也就是说如果根据Key可以直接命中哈希槽中的元素，数据读取访问性能非常高。但如果需要从链表中查找数据，则性能下降非常明显，时间复杂度将从O(1)提升到O(n)，这对查找来说就是一个“噩梦”。<\/p><p>一旦出现这种情况，HashMap的结构会变成下面这个样子：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/ae\/80\/ae0cc399328f69c6af771efc396bec80.jpg?wh=1920x624\" alt=\"图片\"><\/p><p>怎么解决这个问题呢？JDK的设计者们给出了两种优化策略。<\/p><p>第一种，对Hash槽进行扩容，让数据尽可能分布到哈希槽上，但不能解决因为哈希冲突导致的链表变长的问题。<\/p><p>第二种，当链表达到指定长度后，将链表结构转换为红黑树，提升检索性能(JDK8开始引入)。<\/p><p>我们先来通过源码深入探究一下HashMap的扩容机制。HashMap的扩容机制由resize方法实现，该方法主要分成两个部分，上半部分处理初始化或扩容容量计算，下半部分处理扩容后的数据复制(重新布局)。<\/p><p>上半部分的具体源码如下：<\/p><pre><code class=\"language-plain\"> &nbsp; &nbsp;\/**\n &nbsp; &nbsp; * Initializes or doubles table size.  If null, allocates in\n &nbsp; &nbsp; * accord with initial capacity target held in field threshold.\n &nbsp; &nbsp; * Otherwise, because we are using power-of-two expansion, the\n &nbsp; &nbsp; * elements from each bin must either stay at same index, or move\n &nbsp; &nbsp; * with a power of two offset in the new table.\n &nbsp; &nbsp; *\n &nbsp; &nbsp; * @return the table\n &nbsp; &nbsp; *\/\n &nbsp; &nbsp;final Node&lt;K,V&gt;[] resize() {\n &nbsp; &nbsp; &nbsp; &nbsp;Node&lt;K,V&gt;[] oldTab = table;\n &nbsp; &nbsp; &nbsp; &nbsp;int oldCap = (oldTab == null) ? 0 : oldTab.length;\n &nbsp; &nbsp; &nbsp; &nbsp;int oldThr = threshold;\n &nbsp; &nbsp; &nbsp; &nbsp;int newCap, newThr = 0;\n &nbsp; &nbsp; &nbsp; &nbsp;if (oldCap &gt; 0) {\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (oldCap &gt;= MAXIMUM_CAPACITY) {\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;threshold = Integer.MAX_VALUE;\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return oldTab;\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;newThr = oldThr &lt;&lt; 1; \/\/ double threshold\n &nbsp; &nbsp; &nbsp;  }\n &nbsp; &nbsp; &nbsp; &nbsp;else if (oldThr &gt; 0) \/\/ initial capacity was placed in threshold\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;newCap = oldThr;\n &nbsp; &nbsp; &nbsp; &nbsp;else { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \/\/ zero initial threshold signifies using defaults\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;newCap = DEFAULT_INITIAL_CAPACITY;\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n &nbsp; &nbsp; &nbsp;  }\n &nbsp; &nbsp; &nbsp; &nbsp;if (newThr == 0) {\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;float ft = (float)newCap * loadFactor;\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  (int)ft : Integer.MAX_VALUE);\n &nbsp; &nbsp; &nbsp;  }\n &nbsp; &nbsp; &nbsp; &nbsp;threshold = newThr;\n &nbsp; &nbsp; &nbsp; &nbsp;@SuppressWarnings({\"rawtypes\",\"unchecked\"})\n &nbsp; &nbsp; &nbsp; &nbsp;Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];\n &nbsp; &nbsp; &nbsp; &nbsp;table = newTab;\n &nbsp; &nbsp; &nbsp;\/\/此处省略数据复制相关代码\n &nbsp;  }\n<\/code><\/pre><p>为了方便你对代码进行理解，我画了一个与之对应的流程图：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/31\/47\/312f3caa99e8563c26b21038d2222347.jpg?wh=1920x1259\" alt=\"图片\"><\/p><p>总结一下扩容的要点。<\/p><ul>\n<li>HashMap的容量并无限制，但超过2的30次幂后不再扩容哈希槽。<\/li>\n<li>哈希槽是按倍数扩容的。<\/li>\n<li>HashMap在不指定容量时，默认初始容量为16。<\/li>\n<\/ul><p>HashMap并不是在无容量可用的时候才扩容。它会先设置一个扩容临界值，当HashMap中的存储的数据量达到设置的阔值时就触发扩容，这个阔值用threshold表示。<\/p><p>我们还引入了一个变量loadFactor来计算阔值，阔值=容量*loadFactor。其中，loadFactor表示加载因子，默认为0.75。<\/p><p>加载因子的引入与HashMap哈希槽的存储结构与存储算法有关。<\/p><p>HashMap在出现哈希冲突时，会引入一个链表，形成“数组+链表”的存储结构。这带来的效果就是，如果HashMap有32个哈希槽，当前存储的数据也刚好有32个，这些数据却不一定全会落在哈希槽中，因为可能存在hash值一样但是不同Key的数据，这时，数据就会进入到链表中。<\/p><p>前面我们也提到过，数据放入链表就容易引起查找性能的下降，所以，<strong>HashMap的设计者为了将数据尽可能地存储到哈希槽中，会提前进行扩容，用更多的空间换来检索性能的提高<\/strong>。<\/p><p>我们再来看一下扩容的下半部分代码。<\/p><p>我们先来看下这段代码：<\/p><pre><code class=\"language-java\">@SuppressWarnings({\"rawtypes\",\"unchecked\"})\nNode&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];\ntable = newTab;\nif (oldTab != null) {\n    for (int j = 0; j &lt; oldCap; ++j) {\n        Node&lt;K,V&gt; e;\n        if ((e = oldTab[j]) != null) {\n            oldTab[j] = null;\n            if (e.next == null)\n                newTab[e.hash &amp; (newCap - 1)] = e;\n            else if (e instanceof TreeNode)\n                ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);\n            else { \/\/ preserve order\n                Node&lt;K,V&gt; loHead = null, loTail = null;\n                Node&lt;K,V&gt; hiHead = null, hiTail = null;\n                Node&lt;K,V&gt; next;\n                do {\n                    next = e.next;\n                    if ((e.hash &amp; oldCap) == 0) {\n                        if (loTail == null)\n                            loHead = e;\n                        else\n                            loTail.next = e;\n                        loTail = e;\n                    }\n                    else {\n                        if (hiTail == null)\n                            hiHead = e;\n                        else\n                            hiTail.next = e;\n                        hiTail = e;\n                    }\n                } while ((e = next) != null);\n                if (loTail != null) {\n                    loTail.next = null;\n                    newTab[j] = loHead;\n                }\n                if (hiTail != null) {\n                    hiTail.next = null;\n                    newTab[j + oldCap] = hiHead;\n                }\n            }\n        }\n    }\n}\n<\/code><\/pre><p>这段代码不难理解，就是按照扩容后的容量创建一个新的哈希槽数组，遍历原先的哈希槽(数组)，然后将数据重新放入到新的哈希槽中，为了保证链表中数据的顺序性，在扩容时采用尾插法。<\/p><p>除了扩容，JDK8之后的版本还有另外一种提升检索能力的措施，那就是在链表长度超过8时，将链表演变为<strong>红黑树<\/strong>。这时的时间复杂度为O(2lgN)，可以有效提升效率。<\/p><p>关于红黑树，我会在下节课详细介绍。<\/p><h2>总结<\/h2><p>这节课，我们介绍了数组、ArrayList、LinkedList、HashMap这几种数据结构。<\/p><p>数组，由于其内存的连续性，可以通过下标的方式高效随机地访问数组中的元素。<\/p><p>数组与链表可以说是数据结构中两种最基本的数据结构，这节课，我们详细对比了两种数据结构的存储特性。<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/26\/32\/267cd926d583043d2b1909byy2d37132.jpg?wh=1920x1028\" alt=\"图片\"><\/p><p>哈希表是我们使用得最多的数据结构，它的底层的设计也很具技巧性。哈希表充分考虑到数组与链表的优劣，扬长避短，HashMap就是这两者的组合体。为了解决链表检索性能低下的问题，HashMap内部又引入了扩容与链表树化两种方式进行性能提升，提高了使用的便利性，降低了使用门槛。<\/p><h2>课后题<\/h2><p>最后，我也给你留两道思考题吧！<\/p><p>1、业界在解决哈希冲突时除了使用链表外，还有其他什么方案？请你对这两者的差异进行简单的对比。<\/p><p>2、HashMap中哈希槽的容量为什么必须为2的倍数？如果不是很理解，推荐你先学习一下位运算，然后在留言区告诉我你的答案。<\/p><p>我们下节课再见！<\/p>","footer_cover_data":{"img_url":"","mp_url":"","link_url":""},"article_cover_hidden":false,"column_is_experience":false,"is_required":true,"rate":{},"product_id":100114001,"like_count":6,"had_liked":false,"article_subtitle":"","audio_download_url":"https:\/\/static001.geekbang.org\/resource\/audio\/92\/fb\/92baf5f98c55b42bcbc6cc76615a5efb.mp3","id":529440,"had_viewed":false,"article_title":"03 | 数组与链表：存储设计的基石有哪些？","column_bgcolor":"#F6F7FB","share":{"content":"吃透中间件，突破系统高并发瓶颈","title":"丁威 · 中间件核心技术与实战","poster":"https:\/\/static001.geekbang.org\/resource\/image\/5d\/2c\/5da39ca9cfdaa40920d01dc0b7667c2c.jpeg","cover":"https:\/\/static001.geekbang.org\/resource\/image\/76\/be\/7691d0fa3c359555fedff3293b0c35be.jpeg"},"is_video_preview":false,"article_summary":"从这节课开始，我们就要进行基础篇的学习了。想要熟练使用中间件解决各种各样的问题，首先需要掌握中间件的基础知识。中间件主要包括三方面的基础：数据结构、JUC和Netty。接下来的两节课，我们先讲数据结构。","article_poster_wxlite":"https:\/\/static001.geekbang.org\/render\/screen\/62\/e6\/62f8848096406779efccded6b0d816e6.jpeg","column_sale_type":2,"article_features":0,"article_could_preview":false,"column_cover":"https:\/\/static001.geekbang.org\/resource\/image\/76\/be\/7691d0fa3c359555fedff3293b0c35be.jpeg","column_id":506,"audio_time_arr":{"m":"24","s":"02","h":"00"},"video_time":"","audio_title":"修改 丁威-03.MP3","audio_md5":"92baf5f98c55b42bcbc6cc76615a5efb","video_size":0,"text_read_percent":0,"comment_count":8,"cid":506,"article_sharetitle":"数组与链表：存储设计的基石有哪些？","column_is_onboard":true,"article_cshort":"<p>你好，我是丁威。<\/p><p>从这节课开始，我们就要进行基础篇的学习了。想要熟练使用中间件解决各种各样的问题，首先需要掌握中间件的基础知识。<\/p><p>我认为，中间件主要包括如下三方面的基础：数据结构、JUC和Netty，接下来的两节课，我们先讲数据结构。<\/p><p>数据结构主要解决的是数据的存储方式问题，是程序设计的基座。<\/p><p>按照重要性和复杂程度，我选取了数组和链表、键值对(HashMap)、红黑树、LinkedHashMap和PriorityQueue几种数据结构重点解析。其中，数组与链表是最底层的两种结构，是后续所有数据结构的基础。<\/p><p>我会带你分析每种结构的存储结构、新增元素和搜索元素的方式、扩容机制等，让你迅速抓住数据结构底层的特性。当然，我还会结合一些工业级实践，带你深入理解这些容器背后蕴含的设计理念。<\/p><p>说明一下，数据结构其实并不区分语言，但为了方便阐述，这节课我主要基于Java语言进行讲解。<\/p><h2>数组<\/h2><p>我们先来看下数组。<\/p><p>数组是用于储存多个相同类型数据的集合，它具有顺序性，并且也要求内存空间必须连续。高级编程语言基本都会提供数组的实现。<\/p><p>为了更直观地了解数组的内存布局，我们假设从操作系统申请了128字节的内存空间，它的数据结构可以参考下面这张图：<\/p>","video_width":0,"column_could_sub":true,"article_ctime":1655395200,"score":"31655395200","video_media_map":{},"video_preview":{},"video":0,"video_time_arr":{"m":"","s":"","h":""},"video_total_seconds":0},"extra":{},"error":{}}