{"code":0,"data":{"video_id":"","sku":"100023901","video_cover":"","author_name":"王宝令","text_read_version":0,"audio_size":8733698,"article_cover":"https:\/\/static001.geekbang.org\/resource\/image\/b4\/da\/b4ba2177ffc160cb9489985170fa81da.jpg","subtitles":{},"product_type":"c1","audio_url":"https:\/\/res001.geekbang.org\/\/media\/audio\/98\/4b\/9804ba239742c26c8e1a8f7c56cfe54b\/ld\/ld.m3u8","chapter_id":"0","column_had_sub":true,"audio_dubber":"王宝令","is_finished":false,"inline_video_subtitles":{},"like":{"had_done":false,"count":209},"neighbors":{"left":{"id":90515,"article_title":"21 | 原子类：无锁工具类的典范"},"right":{"id":91292,"article_title":"23 | Future：如何用多线程实现最优的“烧水泡茶”程序？"}},"audio_time":"00:09:07","video_height":0,"rate_percent":0,"article_content":"<p>虽然在Java语言中创建线程看上去就像创建一个对象一样简单，只需要new Thread()就可以了，但实际上创建线程远不是创建一个对象那么简单。创建对象，仅仅是在JVM的堆里分配一块内存而已；而创建一个线程，却需要调用操作系统内核的API，然后操作系统要为线程分配一系列的资源，这个成本就很高了，所以<strong>线程是一个重量级的对象，应该避免频繁创建和销毁<\/strong>。<\/p><p>那如何避免呢？应对方案估计你已经知道了，那就是线程池。<\/p><p>线程池的需求是如此普遍，所以Java SDK并发包自然也少不了它。但是很多人在初次接触并发包里线程池相关的工具类时，多少会都有点蒙，不知道该从哪里入手，我觉得根本原因在于线程池和一般意义上的池化资源是不同的。一般意义上的池化资源，都是下面这样，当你需要资源的时候就调用acquire()方法来申请资源，用完之后就调用release()释放资源。若你带着这个固有模型来看并发包里线程池相关的工具类时，会很遗憾地发现它们完全匹配不上，Java提供的线程池里面压根就没有申请线程和释放线程的方法。<\/p><pre><code>class XXXPool{\n  \/\/ 获取池化资源\n  XXX acquire() {\n  }\n  \/\/ 释放池化资源\n  void release(XXX x){\n  }\n}  \n<\/code><\/pre><h2>线程池是一种生产者-消费者模式<\/h2><p>为什么线程池没有采用一般意义上池化资源的设计方法呢？如果线程池采用一般意义上池化资源的设计方法，应该是下面示例代码这样。你可以来思考一下，假设我们获取到一个空闲线程T1，然后该如何使用T1呢？你期望的可能是这样：通过调用T1的execute()方法，传入一个Runnable对象来执行具体业务逻辑，就像通过构造函数Thread(Runnable target)创建线程一样。可惜的是，你翻遍Thread对象的所有方法，都不存在类似execute(Runnable target)这样的公共方法。<\/p><!-- [[[read_end]]] --><pre><code>\/\/采用一般意义上池化资源的设计方法\nclass ThreadPool{\n  \/\/ 获取空闲线程\n  Thread acquire() {\n  }\n  \/\/ 释放线程\n  void release(Thread t){\n  }\n} \n\/\/期望的使用\nThreadPool pool；\nThread T1=pool.acquire();\n\/\/传入Runnable对象\nT1.execute(()-&gt;{\n  \/\/具体业务逻辑\n  ......\n});\n<\/code><\/pre><p>所以，线程池的设计，没有办法直接采用一般意义上池化资源的设计方法。那线程池该如何设计呢？目前业界线程池的设计，普遍采用的都是<strong>生产者-消费者模式<\/strong>。线程池的使用方是生产者，线程池本身是消费者。在下面的示例代码中，我们创建了一个非常简单的线程池MyThreadPool，你可以通过它来理解线程池的工作原理。<\/p><pre><code>\/\/简化的线程池，仅用来说明工作原理\nclass MyThreadPool{\n  \/\/利用阻塞队列实现生产者-消费者模式\n  BlockingQueue&lt;Runnable&gt; workQueue;\n  \/\/保存内部工作线程\n  List&lt;WorkerThread&gt; threads \n    = new ArrayList&lt;&gt;();\n  \/\/ 构造方法\n  MyThreadPool(int poolSize, \n    BlockingQueue&lt;Runnable&gt; workQueue){\n    this.workQueue = workQueue;\n    \/\/ 创建工作线程\n    for(int idx=0; idx&lt;poolSize; idx++){\n      WorkerThread work = new WorkerThread();\n      work.start();\n      threads.add(work);\n    }\n  }\n  \/\/ 提交任务\n  void execute(Runnable command){\n    workQueue.put(command);\n  }\n  \/\/ 工作线程负责消费任务，并执行任务\n  class WorkerThread extends Thread{\n    public void run() {\n      \/\/循环取任务并执行\n      while(true){ ①\n        Runnable task = workQueue.take();\n        task.run();\n      } \n    }\n  }  \n}\n\n\/** 下面是使用示例 **\/\n\/\/ 创建有界阻塞队列\nBlockingQueue&lt;Runnable&gt; workQueue = \n  new LinkedBlockingQueue&lt;&gt;(2);\n\/\/ 创建线程池  \nMyThreadPool pool = new MyThreadPool(\n  10, workQueue);\n\/\/ 提交任务  \npool.execute(()-&gt;{\n    System.out.println(&quot;hello&quot;);\n});\n<\/code><\/pre><p>在MyThreadPool的内部，我们维护了一个阻塞队列workQueue和一组工作线程，工作线程的个数由构造函数中的poolSize来指定。用户通过调用execute()方法来提交Runnable任务，execute()方法的内部实现仅仅是将任务加入到workQueue中。MyThreadPool内部维护的工作线程会消费workQueue中的任务并执行任务，相关的代码就是代码①处的while循环。线程池主要的工作原理就这些，是不是还挺简单的？<\/p><h2>如何使用Java中的线程池<\/h2><p>Java并发包里提供的线程池，远比我们上面的示例代码强大得多，当然也复杂得多。Java提供的线程池相关的工具类中，最核心的是<strong>ThreadPoolExecutor<\/strong>，通过名字你也能看出来，它强调的是Executor，而不是一般意义上的池化资源。<\/p><p>ThreadPoolExecutor的构造函数非常复杂，如下面代码所示，这个最完备的构造函数有7个参数。<\/p><pre><code>ThreadPoolExecutor(\n  int corePoolSize,\n  int maximumPoolSize,\n  long keepAliveTime,\n  TimeUnit unit,\n  BlockingQueue&lt;Runnable&gt; workQueue,\n  ThreadFactory threadFactory,\n  RejectedExecutionHandler handler) \n<\/code><\/pre><p>下面我们一一介绍这些参数的意义，你可以<strong>把线程池类比为一个项目组，而线程就是项目组的成员<\/strong>。<\/p><ul>\n<li><strong>corePoolSize<\/strong>：表示线程池保有的最小线程数。有些项目很闲，但是也不能把人都撤了，至少要留corePoolSize个人坚守阵地。<\/li>\n<li><strong>maximumPoolSize<\/strong>：表示线程池创建的最大线程数。当项目很忙时，就需要加人，但是也不能无限制地加，最多就加到maximumPoolSize个人。当项目闲下来时，就要撤人了，最多能撤到corePoolSize个人。<\/li>\n<li><strong>keepAliveTime &amp; unit<\/strong>：上面提到项目根据忙闲来增减人员，那在编程世界里，如何定义忙和闲呢？很简单，一个线程如果在一段时间内，都没有执行任务，说明很闲，keepAliveTime 和 unit 就是用来定义这个“一段时间”的参数。也就是说，如果一个线程空闲了<code>keepAliveTime &amp; unit<\/code>这么久，而且线程池的线程数大于 corePoolSize ，那么这个空闲的线程就要被回收了。<\/li>\n<li><strong>workQueue<\/strong>：工作队列，和上面示例代码的工作队列同义。<\/li>\n<li><strong>threadFactory<\/strong>：通过这个参数你可以自定义如何创建线程，例如你可以给线程指定一个有意义的名字。<\/li>\n<li><strong>handler<\/strong>：通过这个参数你可以自定义任务的拒绝策略。如果线程池中所有的线程都在忙碌，并且工作队列也满了（前提是工作队列是有界队列），那么此时提交任务，线程池就会拒绝接收。至于拒绝的策略，你可以通过handler这个参数来指定。ThreadPoolExecutor已经提供了以下4种策略。\n<ul>\n<li>CallerRunsPolicy：提交任务的线程自己去执行该任务。<\/li>\n<li>AbortPolicy：默认的拒绝策略，会throws RejectedExecutionException。<\/li>\n<li>DiscardPolicy：直接丢弃任务，没有任何异常抛出。<\/li>\n<li>DiscardOldestPolicy：丢弃最老的任务，其实就是把最早进入工作队列的任务丢弃，然后把新任务加入到工作队列。<\/li>\n<\/ul>\n<\/li>\n<\/ul><p>Java在1.6版本还增加了 allowCoreThreadTimeOut(boolean value) 方法，它可以让所有线程都支持超时，这意味着如果项目很闲，就会将项目组的成员都撤走。<\/p><h2>使用线程池要注意些什么<\/h2><p>考虑到ThreadPoolExecutor的构造函数实在是有些复杂，所以Java并发包里提供了一个线程池的静态工厂类Executors，利用Executors你可以快速创建线程池。不过目前大厂的编码规范中基本上都不建议使用Executors了，所以这里我就不再花篇幅介绍了。<\/p><p>不建议使用Executors的最重要的原因是：Executors提供的很多方法默认使用的都是无界的LinkedBlockingQueue，高负载情境下，无界队列很容易导致OOM，而OOM会导致所有请求都无法处理，这是致命问题。所以<strong>强烈建议使用有界队列<\/strong>。<\/p><p>使用有界队列，当任务过多时，线程池会触发执行拒绝策略，线程池默认的拒绝策略会throw RejectedExecutionException 这是个运行时异常，对于运行时异常编译器并不强制catch它，所以开发人员很容易忽略。因此<strong>默认拒绝策略要慎重使用<\/strong>。如果线程池处理的任务非常重要，建议自定义自己的拒绝策略；并且在实际工作中，自定义的拒绝策略往往和降级策略配合使用。<\/p><p>使用线程池，还要注意异常处理的问题，例如通过ThreadPoolExecutor对象的execute()方法提交任务时，如果任务在执行的过程中出现运行时异常，会导致执行任务的线程终止；不过，最致命的是任务虽然异常了，但是你却获取不到任何通知，这会让你误以为任务都执行得很正常。虽然线程池提供了很多用于异常处理的方法，但是最稳妥和简单的方案还是捕获所有异常并按需处理，你可以参考下面的示例代码。<\/p><pre><code>try {\n  \/\/业务逻辑\n} catch (RuntimeException x) {\n  \/\/按需处理\n} catch (Throwable x) {\n  \/\/按需处理\n} \n<\/code><\/pre><h2>总结<\/h2><p>线程池在Java并发编程领域非常重要，很多大厂的编码规范都要求必须通过线程池来管理线程。线程池和普通的池化资源有很大不同，线程池实际上是生产者-消费者模式的一种实现，理解生产者-消费者模式是理解线程池的关键所在。<\/p><p>创建线程池设置合适的线程数非常重要，这部分内容，你可以参考<a href=\"https:\/\/time.geekbang.org\/column\/article\/86666\">《10 | Java线程（中）：创建多少线程才是合适的？》<\/a>的内容。另外<a href=\"time:\/\/mall?url=https%3A%2F%2Fh5.youzan.com%2Fv2%2Fgoods%2F2758xqdzr6uuw\">《Java并发编程实战》<\/a>的第7章《取消与关闭》的7.3节“处理非正常的线程终止” 详细介绍了异常处理的方案，第8章《线程池的使用》对线程池的使用也有更深入的介绍，如果你感兴趣或有需要的话，建议你仔细阅读。<\/p><h2>课后思考<\/h2><p>使用线程池，默认情况下创建的线程名字都类似<code>pool-1-thread-2<\/code>这样，没有业务含义。而很多情况下为了便于诊断问题，都需要给线程赋予一个有意义的名字，那你知道有哪些办法可以给线程池里的线程指定名字吗？<\/p><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。<\/p><p><\/p>","footer_cover_data":{"img_url":"","mp_url":"","link_url":""},"article_cover_hidden":false,"column_is_experience":false,"is_required":true,"rate":{},"product_id":100023901,"like_count":237,"had_liked":false,"article_subtitle":"","audio_download_url":"https:\/\/static001.geekbang.org\/resource\/audio\/98\/4b\/9804ba239742c26c8e1a8f7c56cfe54b.mp3","id":90771,"had_viewed":false,"article_title":"22 | Executor与线程池：如何创建正确的线程池？","column_bgcolor":"#cbd0de","share":{"content":"当面试时问到多线程、锁的问题，你还是答不上来怎么办？推荐给你《Java 并发编程实战》专栏，带你搞懂并发里的那些Bug问题，全面提升你的并发编程能力，大厂面试绝对不是问题。","title":"王宝令 · Java并发编程实战","poster":"https:\/\/static001.geekbang.org\/resource\/image\/ce\/50\/cebb5cfded54f4bfcca4d75ffe915350.jpg","cover":"https:\/\/static001.geekbang.org\/resource\/image\/47\/f1\/47296780442c7fd11ebf97c0749103f1.jpg"},"is_video_preview":false,"article_summary":"线程池在Java并发编程领域非常重要，很多大厂的编码规范都要求必须通过线程池来管理线程。","article_poster_wxlite":"https:\/\/static001.geekbang.org\/render\/screen\/62\/76\/62d65e0f1ab13db9e67283db48a38276.jpeg","column_sale_type":2,"article_features":0,"article_could_preview":false,"column_cover":"https:\/\/static001.geekbang.org\/resource\/image\/47\/f1\/47296780442c7fd11ebf97c0749103f1.jpg","column_id":159,"audio_time_arr":{"m":"09","s":"07","h":"00"},"video_time":"","audio_title":"4.16 宝令 22 (1)_01","audio_md5":"9804ba239742c26c8e1a8f7c56cfe54b","video_size":0,"text_read_percent":0,"comment_count":71,"cid":159,"article_sharetitle":"Executor与线程池：如何创建正确的线程池？","column_is_onboard":true,"article_cshort":"<p>虽然在Java语言中创建线程看上去就像创建一个对象一样简单，只需要new Thread()就可以了，但实际上创建线程远不是创建一个对象那么简单。创建对象，仅仅是在JVM的堆里分配一块内存而已；而创建一个线程，却需要调用操作系统内核的API，然后操作系统要为线程分配一系列的资源，这个成本就很高了，所以<strong>线程是一个重量级的对象，应该避免频繁创建和销毁<\/strong>。<\/p><p>那如何避免呢？应对方案估计你已经知道了，那就是线程池。<\/p><p>线程池的需求是如此普遍，所以Java SDK并发包自然也少不了它。但是很多人在初次接触并发包里线程池相关的工具类时，多少会都有点蒙，不知道该从哪里入手，我觉得根本原因在于线程池和一般意义上的池化资源是不同的。一般意义上的池化资源，都是下面这样，当你需要资源的时候就调用acquire()方法来申请资源，用完之后就调用release()释放资源。若你带着这个固有模型来看并发包里线程池相关的工具类时，会很遗憾地发现它们完全匹配不上，Java提供的线程池里面压根就没有申请线程和释放线程的方法。<\/p><pre><code>class XXXPool{\n  \/\/ 获取池化资源\n  XXX acquire() {\n  }\n  \/\/ 释放池化资源\n  void release(XXX x){\n  }\n}  \n<\/code><\/pre><h2>线程池是一种生产者-消费者模式<\/h2><p>为什么线程池没有采用一般意义上池化资源的设计方法呢？如果线程池采用一般意义上池化资源的设计方法，应该是下面示例代码这样。你可以来思考一下，假设我们获取到一个空闲线程T1，然后该如何使用T1呢？你期望的可能是这样：通过调用T1的execute()方法，传入一个Runnable对象来执行具体业务逻辑，就像通过构造函数Thread(Runnable target)创建线程一样。可惜的是，你翻遍Thread对象的所有方法，都不存在类似execute(Runnable target)这样的公共方法。<\/p>","video_width":0,"column_could_sub":true,"article_ctime":1555516800,"score":"41555516800","video_media_map":{},"video_preview":{},"video":0,"video_time_arr":{"m":"","s":"","h":""},"video_total_seconds":0},"extra":{},"error":{}}