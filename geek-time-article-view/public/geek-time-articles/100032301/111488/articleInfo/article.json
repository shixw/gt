{"code":0,"data":{"video_id":"","sku":"100032301","video_cover":"","author_name":"李玥","text_read_version":0,"audio_size":14643795,"article_cover":"https:\/\/static001.geekbang.org\/resource\/image\/58\/e0\/587caf915efbb8f6255ea8a677c9ebe0.jpg","subtitles":{},"product_type":"c1","audio_url":"https:\/\/res001.geekbang.org\/\/media\/audio\/60\/5e\/6052aad49d746fdf155b535c03d68a5e\/ld\/ld.m3u8","chapter_id":"0","column_had_sub":true,"audio_dubber":"李玥","is_finished":false,"inline_video_subtitles":{},"like":{"had_done":false,"count":184},"neighbors":{"left":{"id":111269,"article_title":"04 | 如何利用事务消息实现分布式事务？"},"right":{"id":111552,"article_title":"06 | 如何处理消费过程中的重复消息？"}},"audio_time":"00:12:12","video_height":0,"rate_percent":0,"article_content":"<p>你好，我是李玥。这节课我们来聊聊丢消息的事儿。<\/p><p>对于刚刚接触消息队列的同学，最常遇到的问题，也是最头痛的问题就是丢消息了。对于大部分业务系统来说，丢消息意味着数据丢失，是完全无法接受的。<\/p><p>其实，现在主流的消息队列产品都提供了非常完善的消息可靠性保证机制，完全可以做到在消息传递过程中，即使发生网络中断或者硬件故障，也能确保消息的可靠传递，不丢消息。<\/p><p>绝大部分丢消息的原因都是由于开发者不熟悉消息队列，没有正确使用和配置消息队列导致的。虽然不同的消息队列提供的API不一样，相关的配置项也不同，但是在保证消息可靠传递这块儿，它们的实现原理是一样的。<\/p><p>这节课我们就来讲一下，消息队列是怎么保证消息可靠传递的，这里面的实现原理是怎么样的。当你熟知原理以后，无论你使用任何一种消息队列，再简单看一下它的API和相关配置项，就能很快知道该如何配置消息队列，写出可靠的代码，避免消息丢失。<\/p><h2>检测消息丢失的方法<\/h2><p>我们说，用消息队列最尴尬的情况不是丢消息，而是消息丢了还不知道。一般而言，一个新的系统刚刚上线，各方面都不太稳定，需要一个磨合期，这个时候，特别需要监控到你的系统中是否有消息丢失的情况。<\/p><p>如果是IT基础设施比较完善的公司，一般都有分布式链路追踪系统，使用类似的追踪系统可以很方便地追踪每一条消息。如果没有这样的追踪系统，这里我提供一个比较简单的方法，来检查是否有消息丢失的情况。<\/p><!-- [[[read_end]]] --><p><strong>我们可以利用消息队列的有序性来验证是否有消息丢失。<\/strong>原理非常简单，在Producer端，我们给每个发出的消息附加一个连续递增的序号，然后在Consumer端来检查这个序号的连续性。<\/p><p>如果没有消息丢失，Consumer收到消息的序号必然是连续递增的，或者说收到的消息，其中的序号必然是上一条消息的序号+1。如果检测到序号不连续，那就是丢消息了。还可以通过缺失的序号来确定丢失的是哪条消息，方便进一步排查原因。<\/p><p>大多数消息队列的客户端都支持拦截器机制，你可以利用这个拦截器机制，在Producer发送消息之前的拦截器中将序号注入到消息中，在Consumer收到消息的拦截器中检测序号的连续性，这样实现的好处是消息检测的代码不会侵入到你的业务代码中，待你的系统稳定后，也方便将这部分检测的逻辑关闭或者删除。<\/p><p>如果是在一个分布式系统中实现这个检测方法，有几个问题需要你注意。<\/p><p>首先，像Kafka和RocketMQ这样的消息队列，它是不保证在Topic上的严格顺序的，只能保证分区上的消息是有序的，所以我们在发消息的时候必须要指定分区，并且，在每个分区单独检测消息序号的连续性。<\/p><p>如果你的系统中Producer是多实例的，由于并不好协调多个Producer之间的发送顺序，所以也需要每个Producer分别生成各自的消息序号，并且需要附加上Producer的标识，在Consumer端按照每个Producer分别来检测序号的连续性。<\/p><p>Consumer实例的数量最好和分区数量一致，做到Consumer和分区一一对应，这样会比较方便地在Consumer内检测消息序号的连续性。<\/p><h2>确保消息可靠传递<\/h2><p>讲完了检测消息丢失的方法，接下来我们一起来看一下，整个消息从生产到消费的过程中，哪些地方可能会导致丢消息，以及应该如何避免消息丢失。<\/p><p>你可以看下这个图，一条消息从生产到消费完成这个过程，可以划分三个阶段，为了方便描述，我给每个阶段分别起了个名字。<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/81\/05\/81a01f5218614efea2838b0808709205.jpg?wh=3268*1447\" alt=\"\"><\/p><ul>\n<li><strong>生产阶段<\/strong>: 在这个阶段，从消息在Producer创建出来，经过网络传输发送到Broker端。<\/li>\n<li><strong>存储阶段<\/strong>: 在这个阶段，消息在Broker端存储，如果是集群，消息会在这个阶段被复制到其他的副本上。<\/li>\n<li><strong>消费阶段<\/strong>: 在这个阶段，Consumer从Broker上拉取消息，经过网络传输发送到Consumer上。<\/li>\n<\/ul><p><strong>1. 生产阶段<\/strong><\/p><p>在生产阶段，消息队列通过最常用的请求确认机制，来保证消息的可靠传递：当你的代码调用发消息方法时，消息队列的客户端会把消息发送到Broker，Broker收到消息后，会给客户端返回一个确认响应，表明消息已经收到了。客户端收到响应后，完成了一次正常消息的发送。<\/p><p>只要Producer收到了Broker的确认响应，就可以保证消息在生产阶段不会丢失。有些消息队列在长时间没收到发送确认响应后，会自动重试，如果重试再失败，就会以返回值或者异常的方式告知用户。<\/p><p><strong>你在编写发送消息代码时，需要注意，正确处理返回值或者捕获异常，就可以保证这个阶段的消息不会丢失。<\/strong>以Kafka为例，我们看一下如何可靠地发送消息：<\/p><p>同步发送时，只要注意捕获异常即可。<\/p><pre><code>try {\n    RecordMetadata metadata = producer.send(record).get();\n    System.out.println(&quot;消息发送成功。&quot;);\n} catch (Throwable e) {\n    System.out.println(&quot;消息发送失败！&quot;);\n    System.out.println(e);\n}\n<\/code><\/pre><p>异步发送时，则需要在回调方法里进行检查。这个地方是需要特别注意的，很多丢消息的原因就是，我们使用了异步发送，却没有在回调中检查发送结果。<\/p><pre><code>producer.send(record, (metadata, exception) -&gt; {\n    if (metadata != null) {\n        System.out.println(&quot;消息发送成功。&quot;);\n    } else {\n        System.out.println(&quot;消息发送失败！&quot;);\n        System.out.println(exception);\n    }\n});\n<\/code><\/pre><p><strong>2. 存储阶段<\/strong><\/p><p>在存储阶段正常情况下，只要Broker在正常运行，就不会出现丢失消息的问题，但是如果Broker出现了故障，比如进程死掉了或者服务器宕机了，还是可能会丢失消息的。<\/p><p><strong>如果对消息的可靠性要求非常高，可以通过配置Broker参数来避免因为宕机丢消息。<\/strong><\/p><p>对于单个节点的Broker，需要配置Broker参数，在收到消息后，将消息写入磁盘后再给Producer返回确认响应，这样即使发生宕机，由于消息已经被写入磁盘，就不会丢失消息，恢复后还可以继续消费。例如，在RocketMQ中，需要将刷盘方式flushDiskType配置为SYNC_FLUSH同步刷盘。<\/p><p>如果是Broker是由多个节点组成的集群，需要将Broker集群配置成：至少将消息发送到2个以上的节点，再给客户端回复发送确认响应。这样当某个Broker宕机时，其他的Broker可以替代宕机的Broker，也不会发生消息丢失。后面我会专门安排一节课，来讲解在集群模式下，消息队列是如何通过消息复制来确保消息的可靠性的。<\/p><p><strong>3. 消费阶段<\/strong><\/p><p>消费阶段采用和生产阶段类似的确认机制来保证消息的可靠传递，客户端从Broker拉取消息后，执行用户的消费业务逻辑，成功后，才会给Broker发送消费确认响应。如果Broker没有收到消费确认响应，下次拉消息的时候还会返回同一条消息，确保消息不会在网络传输过程中丢失，也不会因为客户端在执行消费逻辑中出错导致丢失。<\/p><p>你在编写消费代码时需要注意的是，<strong>不要在收到消息后就立即发送消费确认，而是应该在执行完所有消费业务逻辑之后，再发送消费确认。<\/strong><\/p><p>同样，我们以用Python语言消费RabbitMQ消息为例，来看一下如何实现一段可靠的消费代码：<\/p><pre><code>def callback(ch, method, properties, body):\n    print(&quot; [x] 收到消息 %r&quot; % body)\n    # 在这儿处理收到的消息\n    database.save(body)\n    print(&quot; [x] 消费完成&quot;)\n    # 完成消费业务逻辑后发送消费确认响应\n    ch.basic_ack(delivery_tag = method.delivery_tag)\n\nchannel.basic_consume(queue='hello', on_message_callback=callback)\n<\/code><\/pre><p>你可以看到，在消费的回调方法callback中，正确的顺序是，先是把消息保存到数据库中，然后再发送消费确认响应。这样如果保存消息到数据库失败了，就不会执行消费确认的代码，下次拉到的还是这条消息，直到消费成功。<\/p><h2>小结<\/h2><p>这节课我带大家分析了一条消息从发送到消费整个流程中，消息队列是如何确保消息的可靠性，不会丢失的。这个过程可以分为分三个阶段，每个阶段都需要正确的编写代码并且设置正确的配置项，才能配合消息队列的可靠性机制，确保消息不会丢失。<\/p><ul>\n<li>在生产阶段，你需要捕获消息发送的错误，并重发消息。<\/li>\n<li>在存储阶段，你可以通过配置刷盘和复制相关的参数，让消息写入到多个副本的磁盘上，来确保消息不会因为某个Broker宕机或者磁盘损坏而丢失。<\/li>\n<li>在消费阶段，你需要在处理完全部消费业务逻辑之后，再发送消费确认。<\/li>\n<\/ul><p>你在理解了这几个阶段的原理后，如果再出现丢消息的情况，应该可以通过在代码中加一些日志的方式，很快定位到是哪个阶段出了问题，然后再进一步深入分析，快速找到问题原因。<\/p><h2>思考题<\/h2><p>我刚刚讲到，如果消息在网络传输过程中发送错误，由于发送方收不到确认，会通过重发来保证消息不丢失。但是，如果确认响应在网络传输时丢失，也会导致重发消息。也就是说，<strong>无论是Broker还是Consumer都是有可能收到重复消息的，<\/strong>那我们在编写消费代码时，就需要考虑这种情况，你可以想一下，在消费消息的代码中，该如何处理这种重复消息，才不会影响业务逻辑的正确性？欢迎在留言区与我分享讨论。<\/p><p>感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给你的朋友。<\/p><p><\/p>","footer_cover_data":{"img_url":"","mp_url":"","link_url":""},"article_cover_hidden":false,"column_is_experience":false,"is_required":true,"rate":{},"product_id":100032301,"like_count":232,"had_liked":false,"article_subtitle":"无","audio_download_url":"https:\/\/static001.geekbang.org\/resource\/audio\/60\/5e\/6052aad49d746fdf155b535c03d68a5e.mp3","id":111488,"had_viewed":false,"article_title":"05 | 如何确保消息不会丢失?","column_bgcolor":"#F6F7FB","share":{"content":"从源码角度全面解析MQ的设计与实现","title":"李玥 · 消息队列高手课","poster":"https:\/\/static001.geekbang.org\/resource\/image\/ba\/99\/bac84697627cdb82a34619f808320799.jpg","cover":"https:\/\/static001.geekbang.org\/resource\/image\/b8\/9e\/b8626890ae4c266c81f47d3744d9579e.jpg"},"is_video_preview":false,"article_summary":"用消息队列最尴尬的情况不是丢消息，而是消息丢了还不知道。","article_poster_wxlite":"https:\/\/static001.geekbang.org\/render\/screen\/1c\/15\/1c63d5cc5d59415371ca06e619978115.jpeg","column_sale_type":1,"article_features":0,"article_could_preview":false,"column_cover":"https:\/\/static001.geekbang.org\/resource\/image\/b8\/9e\/b8626890ae4c266c81f47d3744d9579e.jpg","column_id":212,"audio_time_arr":{"m":"12","s":"12","h":"00"},"video_time":"","audio_title":"李05更改","audio_md5":"6052aad49d746fdf155b535c03d68a5e","video_size":0,"text_read_percent":0,"comment_count":139,"cid":212,"article_sharetitle":"如何确保消息不会丢失?","column_is_onboard":true,"article_cshort":"<p>你好，我是李玥。这节课我们来聊聊丢消息的事儿。<\/p><p>对于刚刚接触消息队列的同学，最常遇到的问题，也是最头痛的问题就是丢消息了。对于大部分业务系统来说，丢消息意味着数据丢失，是完全无法接受的。<\/p><p>其实，现在主流的消息队列产品都提供了非常完善的消息可靠性保证机制，完全可以做到在消息传递过程中，即使发生网络中断或者硬件故障，也能确保消息的可靠传递，不丢消息。<\/p><p>绝大部分丢消息的原因都是由于开发者不熟悉消息队列，没有正确使用和配置消息队列导致的。虽然不同的消息队列提供的API不一样，相关的配置项也不同，但是在保证消息可靠传递这块儿，它们的实现原理是一样的。<\/p><p>这节课我们就来讲一下，消息队列是怎么保证消息可靠传递的，这里面的实现原理是怎么样的。当你熟知原理以后，无论你使用任何一种消息队列，再简单看一下它的API和相关配置项，就能很快知道该如何配置消息队列，写出可靠的代码，避免消息丢失。<\/p><h2>检测消息丢失的方法<\/h2><p>我们说，用消息队列最尴尬的情况不是丢消息，而是消息丢了还不知道。一般而言，一个新的系统刚刚上线，各方面都不太稳定，需要一个磨合期，这个时候，特别需要监控到你的系统中是否有消息丢失的情况。<\/p><p>如果是IT基础设施比较完善的公司，一般都有分布式链路追踪系统，使用类似的追踪系统可以很方便地追踪每一条消息。如果没有这样的追踪系统，这里我提供一个比较简单的方法，来检查是否有消息丢失的情况。<\/p>","video_width":0,"column_could_sub":true,"article_ctime":1564588800,"score":"21564588800","video_media_map":{},"video_preview":{},"video":0,"video_time_arr":{"m":"","s":"","h":""},"video_total_seconds":0},"extra":{},"error":{}}