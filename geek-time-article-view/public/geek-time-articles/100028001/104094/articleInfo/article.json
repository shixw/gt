{"code":0,"data":{"video_id":"","sku":"100028001","video_cover":"","author_name":"刘超","text_read_version":0,"audio_size":10654848,"article_cover":"https:\/\/static001.geekbang.org\/resource\/image\/55\/86\/552a1c6a45bd2b7d791f5bbd585eb686.jpg","subtitles":{},"product_type":"c1","audio_url":"https:\/\/res001.geekbang.org\/\/media\/audio\/46\/04\/4614247beaaad69c1f8c0735f5dfd904\/ld\/ld.m3u8","chapter_id":"0","column_had_sub":true,"audio_dubber":"李良","is_finished":false,"inline_video_subtitles":{},"like":{"had_done":false,"count":112},"neighbors":{"left":{"id":103541,"article_title":"17 | 并发容器的使用：识别不同场景下最优容器"},"right":{"id":104521,"article_title":"19 | 如何用协程来优化多线程业务？"}},"audio_time":"00:11:06","video_height":0,"rate_percent":0,"article_content":"<p>你好，我是刘超。<\/p><p>还记得我在16讲中说过“线程池的线程数量设置过多会导致线程竞争激烈”吗？今天再补一句，如果线程数量设置过少的话，还会导致系统无法充分利用计算机资源。那么如何设置才不会影响系统性能呢？<\/p><p>其实线程池的设置是有方法的，不是凭借简单的估算来决定的。<span class=\"orange\">今天我们就来看看究竟有哪些计算方法可以复用，<\/span>线程池中各个参数之间又存在怎样的关系。<\/p><h2>线程池原理<\/h2><p>开始优化之前，我们先来看看线程池的实现原理，有助于你更好地理解后面的内容。<\/p><p>在HotSpot VM的线程模型中，Java线程被一对一映射为内核线程。Java在使用线程执行程序时，需要创建一个内核线程；当该Java线程被终止时，这个内核线程也会被回收。因此Java线程的创建与销毁将会消耗一定的计算机资源，从而增加系统的性能开销。<\/p><p>除此之外，大量创建线程同样会给系统带来性能问题，因为内存和CPU资源都将被线程抢占，如果处理不当，就会发生内存溢出、CPU使用率超负荷等问题。<\/p><p>为了解决上述两类问题，Java提供了线程池概念，对于频繁创建线程的业务场景，线程池可以创建固定的线程数量，并且在操作系统底层，轻量级进程将会把这些线程映射到内核。<\/p><p><span class=\"orange\">线程池可以提高线程复用，又可以固定最大线程使用量，防止无限制地创建线程。<\/span>当程序提交一个任务需要一个线程时，会去线程池中查找是否有空闲的线程，若有，则直接使用线程池中的线程工作，若没有，会去判断当前已创建的线程数量是否超过最大线程数量，如未超过，则创建新线程，如已超过，则进行排队等待或者直接抛出异常。<\/p><!-- [[[read_end]]] --><h2>线程池框架Executor<\/h2><p>Java最开始提供了ThreadPool实现了线程池，为了更好地实现用户级的线程调度，更有效地帮助开发人员进行多线程开发，Java提供了一套Executor框架。<\/p><p>这个框架中包括了ScheduledThreadPoolExecutor和ThreadPoolExecutor两个核心线程池。前者是用来定时执行任务，后者是用来执行被提交的任务。鉴于这两个线程池的核心原理是一样的，下面我们就重点看看ThreadPoolExecutor类是如何实现线程池的。<\/p><p>Executors实现了以下四种类型的ThreadPoolExecutor：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/8d\/69\/8d3c1654add00cb63645f1332e4eb669.jpg?wh=1240*486\" alt=\"\"><\/p><p>Executors利用工厂模式实现的四种线程池，我们在使用的时候需要结合生产环境下的实际场景。不过我不太推荐使用它们，因为选择使用Executors提供的工厂类，将会忽略很多线程池的参数设置，工厂类一旦选择设置默认参数，就很容易导致无法调优参数设置，从而产生性能问题或者资源浪费。<\/p><p>这里<span class=\"orange\">我建议你使用ThreadPoolExecutor自我定制一套线程池<\/span>。进入四种工厂类后，我们可以发现除了newScheduledThreadPool类，其它类均使用了ThreadPoolExecutor类进行实现，你可以通过以下代码简单看下该方法：<\/p><pre><code>    public ThreadPoolExecutor(int corePoolSize,\/\/线程池的核心线程数量\n                              int maximumPoolSize,\/\/线程池的最大线程数\n                              long keepAliveTime,\/\/当线程数大于核心线程数时，多余的空闲线程存活的最长时间\n                              TimeUnit unit,\/\/时间单位\n                              BlockingQueue&lt;Runnable&gt; workQueue,\/\/任务队列，用来储存等待执行任务的队列\n                              ThreadFactory threadFactory,\/\/线程工厂，用来创建线程，一般默认即可\n                              RejectedExecutionHandler handler) \/\/拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务\n<\/code><\/pre><p>我们还可以通过下面这张图来了解下线程池中各个参数的相互关系：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/66\/e6\/667149d07c494c29a23c1c08b9c0dbe6.jpg?wh=1666*1042\" alt=\"\"><\/p><p>通过上图，我们发现线程池有两个线程数的设置，一个为核心线程数，一个为最大线程数。在创建完线程池之后，默认情况下，线程池中并没有任何线程，等到有任务来才创建线程去执行任务。<\/p><p>但有一种情况排除在外，就是调用prestartAllCoreThreads()或者prestartCoreThread()方法的话，可以提前创建等于核心线程数的线程数量，这种方式被称为预热，在抢购系统中就经常被用到。<\/p><p>当创建的线程数等于 corePoolSize 时，提交的任务会被加入到设置的阻塞队列中。当队列满了，会创建线程执行任务，直到线程池中的数量等于maximumPoolSize。<\/p><p>当线程数量已经等于maximumPoolSize时， 新提交的任务无法加入到等待队列，也无法创建非核心线程直接执行，我们又没有为线程池设置拒绝策略，这时线程池就会抛出RejectedExecutionException异常，即线程池拒绝接受这个任务。<\/p><p>当线程池中创建的线程数量超过设置的corePoolSize，在某些线程处理完任务后，如果等待keepAliveTime时间后仍然没有新的任务分配给它，那么这个线程将会被回收。线程池回收线程时，会对所谓的“核心线程”和“非核心线程”一视同仁，直到线程池中线程的数量等于设置的corePoolSize参数，回收过程才会停止。<\/p><p>即使是corePoolSize线程，在一些非核心业务的线程池中，如果长时间地占用线程数量，也可能会影响到核心业务的线程池，这个时候就需要把没有分配任务的线程回收掉。<\/p><p>我们可以通过allowCoreThreadTimeOut设置项要求线程池：将包括“核心线程”在内的，没有任务分配的所有线程，在等待keepAliveTime时间后全部回收掉。<\/p><p>我们可以通过下面这张图来了解下线程池的线程分配流程：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/b1\/b0\/b13aa36ef3b15a98fab1755ac36101b0.jpg?wh=746*950\" alt=\"\"><\/p><h2>计算线程数量<\/h2><p>了解完线程池的实现原理和框架，我们就可以动手实践优化线程池的设置了。<\/p><p>我们知道，环境具有多变性，设置一个绝对精准的线程数其实是不\b大可能的，但我们可以通过一些实际操作因素来计算出一个合理的线程数，避免由于线程池设置不合理而导致的性能问题。下面我们就来看看具体的计算方法。<\/p><p>一般多线程执行的任务类型可以分为CPU密集型和I\/O密集型，根据不同的任务类型，我们计算线程数的方法也不一样。<\/p><p><strong>CPU密集型任务：<\/strong>这种任务消耗的主要是CPU资源，可以将线程数设置为N（CPU核心数）+1，比CPU核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用CPU的空闲时间。<\/p><p>下面我们用一个例子来验证下这个方法的可行性，通过观察CPU密集型任务在不同线程数下的性能情况就可以得出结果，你可以点击<a href=\"https:\/\/github.com\/nickliuchao\/threadpollsizetest\">Github<\/a>下载到本地运行测试：<\/p><pre><code>public class CPUTypeTest implements Runnable {\n\n\t\/\/整体执行时间，包括在队列中等待的时间\n\tList&lt;Long&gt; wholeTimeList;\n\t\/\/真正执行时间\n\tList&lt;Long&gt; runTimeList;\n\t\n\tprivate long initStartTime = 0;\n\t\n\t\/**\n\t * 构造函数\n\t * @param runTimeList\n\t * @param wholeTimeList\n\t *\/\n\tpublic CPUTypeTest(List&lt;Long&gt; runTimeList, List&lt;Long&gt; wholeTimeList) {\n\t\tinitStartTime = System.currentTimeMillis();\n\t\tthis.runTimeList = runTimeList;\n\t\tthis.wholeTimeList = wholeTimeList;\n\t}\n\t\n\t\/**\n\t * 判断素数\n\t * @param number\n\t * @return\n\t *\/\n\tpublic boolean isPrime(final int number) {\n\t\tif (number &lt;= 1)\n\t\t\treturn false;\n\n\n\t\tfor (int i = 2; i &lt;= Math.sqrt(number); i++) {\n\t\t\tif (number % i == 0)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t\/**\n\t * 計算素数\n\t * @param number\n\t * @return\n\t *\/\n\tpublic int countPrimes(final int lower, final int upper) {\n\t\tint total = 0;\n\t\tfor (int i = lower; i &lt;= upper; i++) {\n\t\t\tif (isPrime(i))\n\t\t\t\ttotal++;\n\t\t}\n\t\treturn total;\n\t}\n\n\tpublic void run() {\n\t\tlong start = System.currentTimeMillis();\n\t\tcountPrimes(1, 1000000);\n\t\tlong end = System.currentTimeMillis();\n\n\n\t\tlong wholeTime = end - initStartTime;\n\t\tlong runTime = end - start;\n\t\twholeTimeList.add(wholeTime);\n\t\trunTimeList.add(runTime);\n\t\tSystem.out.println(&quot;单个线程花费时间：&quot; + (end - start));\n\t}\n}\n<\/code><\/pre><p>测试代码在4核 intel i5 CPU机器上的运行时间变化如下：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/c5\/f9\/c54224d1ed2d579a550650693c70e4f9.jpg?wh=1628*924\" alt=\"\"><\/p><p>综上可知：当线程数量太小，同一时间大量请求将被阻塞在线程队列中排队等待执行线程，此时CPU没有得到充分利用；当线程数量太大，被创建的执行线程同时在争取CPU资源，又会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。通过测试可知，4~6个线程数是最合适的。<\/p><p><strong>I\/O密集型任务：<\/strong>这种任务应用起来，系统会用大部分的时间来处理I\/O交互，而线程在处理I\/O的时间段内不会占用CPU来处理，这时就可以将CPU交出给其它线程使用。因此在I\/O密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是2N。<\/p><p>这里我们还是通过一个例子来验证下这个公式是否可以标准化：<\/p><pre><code>public class IOTypeTest implements Runnable {\n\n\t\/\/整体执行时间，包括在队列中等待的时间\n\tVector&lt;Long&gt; wholeTimeList;\n\t\/\/真正执行时间\n\tVector&lt;Long&gt; runTimeList;\n\t\n\tprivate long initStartTime = 0;\n\t\n\t\/**\n\t * 构造函数\n\t * @param runTimeList\n\t * @param wholeTimeList\n\t *\/\n\tpublic IOTypeTest(Vector&lt;Long&gt; runTimeList, Vector&lt;Long&gt; wholeTimeList) {\n\t\tinitStartTime = System.currentTimeMillis();\n\t\tthis.runTimeList = runTimeList;\n\t\tthis.wholeTimeList = wholeTimeList;\n\t}\n\t\n\t\/**\n\t *IO操作\n\t * @param number\n\t * @return\n\t * @throws IOException \n\t *\/\n\tpublic void readAndWrite() throws IOException {\n\t\tFile sourceFile = new File(&quot;D:\/test.txt&quot;);\n        \/\/创建输入流\n        BufferedReader input = new BufferedReader(new FileReader(sourceFile));\n        \/\/读取源文件,写入到新的文件\n        String line = null;\n        while((line = input.readLine()) != null){\n            \/\/System.out.println(line);\n        }\n        \/\/关闭输入输出流\n        input.close();\n\t}\n\n\tpublic void run() {\n\t\tlong start = System.currentTimeMillis();\n\t\ttry {\n\t\t\treadAndWrite();\n\t\t} catch (IOException e) {\n\t\t\t\/\/ TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t\tlong end = System.currentTimeMillis();\n\n\n\t\tlong wholeTime = end - initStartTime;\n\t\tlong runTime = end - start;\n\t\twholeTimeList.add(wholeTime);\n\t\trunTimeList.add(runTime);\n\t\tSystem.out.println(&quot;单个线程花费时间：&quot; + (end - start));\n\t}\n}\n<\/code><\/pre><p>备注：由于测试代码读取2MB大小的文件，涉及到大内存，所以在运行之前，我们需要调整JVM的堆内存空间：-Xms4g -Xmx4g，避免发生频繁的FullGC，影响测试结果。<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/0b\/88\/0bb0fe79bc9fc3c386815e3d0bfcf088.jpg?wh=1572*848\" alt=\"\"><\/p><p>通过测试结果，我们可以看到每个线程所花费的时间。当线程数量在8时，线程平均执行时间是最佳的，这个线程数量和我们的计算公式所得的结果就差不多。<\/p><p>看完以上两种情况下的线程计算方法，你可能还想说，在平常的应用场景中，我们常常遇不到这两种极端情况，<strong>那么碰上一些常规的业务操作，比如，通过一个线程池实现向用户定时推送消息的业务，我们又该如何设置线程池的数量呢？<\/strong><\/p><p>此时我们可以参考以下公式来计算线程数：<\/p><pre><code>线程数=N（CPU核数）*（1+WT（线程等待时间）\/ST（线程时间运行时间））\n<\/code><\/pre><p>我们可以通过JDK自带的工具VisualVM来查看WT\/ST比例，以下例子是基于运行纯CPU运算的例子，我们可以看到：<\/p><pre><code>WT（线程等待时间）= 36788ms [线程运行总时间] - 36788ms[ST（线程时间运行时间）]= 0\n线程数=N（CPU核数）*（1+ 0 [WT（线程等待时间）]\/36788ms[ST（线程时间运行时间）]）= N（CPU核数）\n<\/code><\/pre><p>这跟我们之前通过CPU密集型的计算公式N+1所得出的结果差不多。<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/32\/65\/3214039ef8f15076084a363a9f0b0b65.jpg?wh=2372*1254\" alt=\"\"><\/p><p>综合来看，我们可以根据自己的业务场景，从“N+1”和“2N”两个公式中选出一个适合的，计算出一个大概的线程数量，之后通过实际压测，逐渐往“增大线程数量”和“减小线程数量”这两个方向调整，然后观察整体的处理时间变化，最终确定一个具体的线程数量。<\/p><h2>总结<\/h2><p>今天我们主要学习了线程池的实现原理，Java线程的创建和消耗会给系统带来性能开销，因此Java提供了线程池来复用线程，提高程序的并发效率。<\/p><p>Java通过用户线程与内核线程结合的1:1线程模型来实现，Java将线程的调度和管理设置在了用户态，提供了一套Executor框架来帮助开发人员提高效率。Executor框架不仅包括了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，可以说Executor框架为并发编程提供了一个完善的架构体系。<\/p><p>在不同的业务场景以及不同配置的部署机器中，线程池的线程数量设置是不一样的。其设置不宜过大，也不宜过小，<span class=\"orange\">要根据具体情况，计算出一个大概的数值，再通过实际的性能测试，计算出一个合理的线程数量。<\/span><\/p><p>我们要提高线程池的处理能力，一定要先保证一个合理的线程数量，也就是保证CPU处理线程的最大化。在此前提下，我们再增大线程池队列，通过队列将来不及处理的线程缓存起来。在设置缓存队列时，我们要尽量使用一个有界队列，以防因队列过大而导致的内存溢出问题。<\/p><h2>思考题<\/h2><p>在程序中，除了并行段代码，还有串行段代码。那么当程序同时存在串行和并行操作时，优化并行操作是不是优化系统的关键呢？<\/p><p>期待在留言区看到你的见解。也欢迎你点击“请朋友读”，把今天的内容分享给身边的朋友，邀请他一起讨论。<\/p><p><\/p>","footer_cover_data":{"img_url":"","mp_url":"","link_url":""},"article_cover_hidden":false,"column_is_experience":false,"is_required":true,"rate":{},"product_id":100028001,"like_count":143,"had_liked":false,"article_subtitle":"无","audio_download_url":"https:\/\/static001.geekbang.org\/resource\/audio\/46\/04\/4614247beaaad69c1f8c0735f5dfd904.mp3","id":104094,"had_viewed":false,"article_title":"18 | 如何设置线程池大小？","column_bgcolor":"#F6F7FB","share":{"content":"覆盖80%以上Java应用调优场景","title":"刘超 · Java性能调优实战","poster":"https:\/\/static001.geekbang.org\/resource\/image\/ed\/99\/edfa939ff065cb8368ed4227930df399.jpg","cover":"https:\/\/static001.geekbang.org\/resource\/image\/b2\/01\/b2f97b2cbefe40e19af4d28508387e01.jpg"},"is_video_preview":false,"article_summary":"线程数量的设置不是凭借简单的估算来决定的，今天我们就来看看究竟有哪些计算方法可以复用。","article_poster_wxlite":"https:\/\/static001.geekbang.org\/render\/screen\/4c\/ad\/4c317558d0de0234f291f32842c782ad.jpeg","column_sale_type":2,"article_features":0,"article_could_preview":false,"column_cover":"https:\/\/static001.geekbang.org\/resource\/image\/b2\/01\/b2f97b2cbefe40e19af4d28508387e01.jpg","column_id":185,"audio_time_arr":{"m":"11","s":"06","h":"00"},"video_time":"","audio_title":"刘超-18","audio_md5":"4614247beaaad69c1f8c0735f5dfd904","video_size":0,"text_read_percent":0,"comment_count":61,"cid":185,"article_sharetitle":"如何设置线程池大小？","column_is_onboard":true,"article_cshort":"<p>你好，我是刘超。<\/p><p>还记得我在16讲中说过“线程池的线程数量设置过多会导致线程竞争激烈”吗？今天再补一句，如果线程数量设置过少的话，还会导致系统无法充分利用计算机资源。那么如何设置才不会影响系统性能呢？<\/p><p>其实线程池的设置是有方法的，不是凭借简单的估算来决定的。<span class=\"orange\">今天我们就来看看究竟有哪些计算方法可以复用，<\/span>线程池中各个参数之间又存在怎样的关系。<\/p><h2>线程池原理<\/h2><p>开始优化之前，我们先来看看线程池的实现原理，有助于你更好地理解后面的内容。<\/p><p>在HotSpot VM的线程模型中，Java线程被一对一映射为内核线程。Java在使用线程执行程序时，需要创建一个内核线程；当该Java线程被终止时，这个内核线程也会被回收。因此Java线程的创建与销毁将会消耗一定的计算机资源，从而增加系统的性能开销。<\/p><p>除此之外，大量创建线程同样会给系统带来性能问题，因为内存和CPU资源都将被线程抢占，如果处理不当，就会发生内存溢出、CPU使用率超负荷等问题。<\/p><p>为了解决上述两类问题，Java提供了线程池概念，对于频繁创建线程的业务场景，线程池可以创建固定的线程数量，并且在操作系统底层，轻量级进程将会把这些线程映射到内核。<\/p><p><span class=\"orange\">线程池可以提高线程复用，又可以固定最大线程使用量，防止无限制地创建线程。<\/span>当程序提交一个任务需要一个线程时，会去线程池中查找是否有空闲的线程，若有，则直接使用线程池中的线程工作，若没有，会去判断当前已创建的线程数量是否超过最大线程数量，如未超过，则创建新线程，如已超过，则进行排队等待或者直接抛出异常。<\/p>","video_width":0,"column_could_sub":true,"article_ctime":1561737600,"score":"41561737600","video_media_map":{},"video_preview":{},"video":0,"video_time_arr":{"m":"","s":"","h":""},"video_total_seconds":0},"extra":{},"error":{}}