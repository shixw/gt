{"code":0,"data":{"video_id":"","sku":"100028001","video_cover":"","author_name":"刘超","text_read_version":0,"audio_size":6579975,"article_cover":"https:\/\/static001.geekbang.org\/resource\/image\/20\/4c\/20f4530ac7397d8be83e6b041f6d9f4c.jpg","subtitles":{},"product_type":"c1","audio_url":"https:\/\/res001.geekbang.org\/\/media\/audio\/fb\/7e\/fb48248bfb9c075ce52914582bcba07e\/ld\/ld.m3u8","chapter_id":"0","column_had_sub":true,"audio_dubber":"李良","is_finished":false,"inline_video_subtitles":{},"like":{"had_done":false,"count":96},"neighbors":{"left":{"id":111288,"article_title":"30 | 生产者消费者模式：电商库存设计优化"},"right":{"id":112160,"article_title":"32 | 答疑课堂：模块五思考题集锦"}},"audio_time":"00:06:52","video_height":0,"rate_percent":0,"article_content":"<p>你好，我是刘超。<\/p><p>开始今天的学习之前，我想先请你思考一个问题。假设现在有这样一个需求，让你设计一个装修功能，用户可以动态选择不同的装修功能来装饰自己的房子。例如，水电装修、天花板以及粉刷墙等属于基本功能，而设计窗帘装饰窗户、设计吊顶装饰房顶等未必是所有用户都需要的，这些功能则需要实现动态添加。还有就是一旦有新的装修功能，我们也可以实现动态添加。如果要你来负责，你会怎么设计呢？<\/p><p>此时你可能会想了，通常给一个对象添加功能，要么直接修改代码，在对象中添加相应的功能，要么派生对应的子类来扩展。然而，前者每次都需要修改对象的代码，这显然不是理想的面向对象设计，即便后者是通过派生对应的子类来扩展，也很难满足复杂的随意组合功能需求。<\/p><p>面对这种情况，使用装饰器模式应该再合适不过了。它的优势我想你多少知道一点，我在这里总结一下。<\/p><p>装饰器模式能够实现为对象动态添加装修功能，它是从一个对象的外部来给对象添加功能，所以有非常灵活的扩展性，我们可以在对原来的代码毫无修改的前提下，为对象添加新功能。除此之外，装饰器模式还能够实现对象的动态组合，借此我们可以很灵活地给动态组合的对象，匹配所需要的功能。<\/p><p>下面我们就通过实践，具体看看该模式的优势。<\/p><!-- [[[read_end]]] --><h2>什么是装饰器模式？<\/h2><p>在这之前，我先简单介绍下什么是装饰器模式。装饰器模式包括了以下几个角色：接口、具体对象、装饰类、具体装饰类。<\/p><p>接口定义了具体对象的一些实现方法；具体对象定义了一些初始化操作，比如开头设计装修功能的案例中，水电装修、天花板以及粉刷墙等都是初始化操作；装饰类则是一个抽象类，主要用来初始化具体对象的一个类；其它的具体装饰类都继承了该抽象类。<\/p><p>下面我们就通过装饰器模式来实现下装修功能，代码如下：<\/p><pre><code>\/**\n * 定义一个基本装修接口\n * @author admin\n *\n *\/\npublic interface IDecorator {\n\t\n\t\/**\n\t * 装修方法\n\t *\/\n\tvoid decorate();\n\n}\n<\/code><\/pre><pre><code>\/**\n * 装修基本类\n * @author admin\n *\n *\/\npublic class Decorator implements IDecorator{\n\n\t\/**\n\t * 基本实现方法\n\t *\/\n\tpublic void decorate() {\n\t\tSystem.out.println(&quot;水电装修、天花板以及粉刷墙。。。&quot;);\n\t}\n\n}\n<\/code><\/pre><pre><code>\/**\n * 基本装饰类\n * @author admin\n *\n *\/\npublic abstract class BaseDecorator implements IDecorator{\n\n\tprivate IDecorator decorator;\n\t\n\tpublic BaseDecorator(IDecorator decorator) {\n\t\tthis.decorator = decorator;\n\t}\n\t\n\t\/**\n\t * 调用装饰方法\n\t *\/\n\tpublic void decorate() {\n\t\tif(decorator != null) {\n\t\t\tdecorator.decorate();\n\t\t}\n\t}\n}\n<\/code><\/pre><pre><code>\/**\n * 窗帘装饰类\n * @author admin\n *\n *\/\npublic class CurtainDecorator extends BaseDecorator{\n\n\tpublic CurtainDecorator(IDecorator decorator) {\n\t\tsuper(decorator);\n\t}\n\t\n\t\/**\n\t * 窗帘具体装饰方法\n\t *\/\n\t@Override\n\tpublic void decorate() {\n\t\tSystem.out.println(&quot;窗帘装饰。。。&quot;);\n\t\tsuper.decorate();\n\t}\n\n}\n<\/code><\/pre><pre><code>    public static void main( String[] args )\n    {\n    \tIDecorator decorator = new Decorator();\n    \tIDecorator curtainDecorator = new CurtainDecorator(decorator);\n    \tcurtainDecorator.decorate();\n        \n    }\n<\/code><\/pre><p>运行结果：<\/p><pre><code>窗帘装饰。。。\n水电装修、天花板以及粉刷墙。。。\n<\/code><\/pre><p>通过这个案例，我们可以了解到：如果我们想要在基础类上添加新的装修功能，只需要基于抽象类BaseDecorator去实现继承类，通过构造函数调用父类，以及重写装修方法实现装修窗帘的功能即可。在main函数中，我们通过实例化装饰类，调用装修方法，即可在基础装修的前提下，获得窗帘装修功能。<\/p><p>基于装饰器模式实现的装修功能的代码结构简洁易读，业务逻辑也非常清晰，并且如果我们需要扩展新的装修功能，只需要新增一个继承了抽象装饰类的子类即可。<\/p><p>在这个案例中，我们仅实现了业务扩展功能，接下来，我将通过装饰器模式优化电商系统中的商品价格策略，实现不同促销活动的灵活组合。<\/p><h2>优化电商系统中的商品价格策略<\/h2><p>相信你一定不陌生，购买商品时经常会用到的限时折扣、红包、抵扣券以及特殊抵扣金等，种类很多，如果换到开发视角，实现起来就更复杂了。<\/p><p>例如，每逢双十一，为了加大商城的优惠力度，开发往往要设计红包+限时折扣或红包+抵扣券等组合来实现多重优惠。而在平时，由于某些特殊原因，商家还会赠送特殊抵扣券给购买用户，而特殊抵扣券+各种优惠又是另一种组合方式。<\/p><p>要实现以上这类组合优惠的功能，最快、最普遍的实现方式就是通过大量if-else的方式来实现。但这种方式包含了大量的逻辑判断，致使其他开发人员很难读懂业务， 并且一旦有新的优惠策略或者价格组合策略出现，就需要修改代码逻辑。<\/p><p>这时，刚刚介绍的装饰器模式就很适合用在这里，其相互独立、自由组合以及方便动态扩展功能的特性，可以很好地解决if-else方式的弊端。下面我们就用装饰器模式动手实现一套商品价格策略的优化方案。<\/p><p>首先，我们先建立订单和商品的属性类，在本次案例中，为了保证简洁性，我只建立了几个关键字段。以下几个重要属性关系为，主订单包含若干详细订单，详细订单中记录了商品信息，商品信息中包含了促销类型信息，一个商品可以包含多个促销类型（本案例只讨论单个促销和组合促销）：<\/p><pre><code>\/**\n * 主订单\n * @author admin\n *\n *\/\npublic class Order {\n\t\n\tprivate int id; \/\/订单ID\n\tprivate String orderNo; \/\/订单号\n\tprivate BigDecimal totalPayMoney; \/\/总支付金额\n\tprivate List&lt;OrderDetail&gt; list; \/\/详细订单列表\n}\n<\/code><\/pre><pre><code>\/**\n * 详细订单\n * @author admin\n *\n *\/\npublic class OrderDetail {\n\tprivate int id; \/\/详细订单ID\n\tprivate int orderId;\/\/主订单ID\n\tprivate Merchandise merchandise; \/\/商品详情\n\tprivate BigDecimal payMoney; \/\/支付单价\n}\n<\/code><\/pre><pre><code>\/**\n * 商品\n * @author admin\n *\n *\/\npublic class Merchandise {\n\t\n\tprivate String sku;\/\/商品SKU\n\tprivate String name; \/\/商品名称\n\tprivate BigDecimal price; \/\/商品单价\n\tprivate Map&lt;PromotionType, SupportPromotions&gt; supportPromotions; \/\/支持促销类型\n}\n<\/code><\/pre><pre><code>\/**\n * 促销类型\n * @author admin\n *\n *\/\npublic class SupportPromotions implements Cloneable{\n\n\tprivate int id;\/\/该商品促销的ID\n\tprivate PromotionType promotionType;\/\/促销类型 1\\优惠券 2\\红包\n\tprivate int priority; \/\/优先级\n\tprivate UserCoupon userCoupon; \/\/用户领取该商品的优惠券\n\tprivate UserRedPacket userRedPacket; \/\/用户领取该商品的红包\n\t\n\t\/\/重写clone方法\n    public SupportPromotions clone(){\n    \tSupportPromotions supportPromotions = null;\n        try{\n        \tsupportPromotions = (SupportPromotions)super.clone();\n        }catch(CloneNotSupportedException e){\n            e.printStackTrace();\n        }\n        return supportPromotions;\n    }\n}\n<\/code><\/pre><pre><code>\/**\n * 优惠券\n * @author admin\n *\n *\/\npublic class UserCoupon {\n\t\n\tprivate int id; \/\/优惠券ID\n\tprivate int userId; \/\/领取优惠券用户ID\n\tprivate String sku; \/\/商品SKU\n\tprivate BigDecimal coupon; \/\/优惠金额\n}\n<\/code><\/pre><pre><code>\/**\n * 红包\n * @author admin\n *\n *\/\npublic class UserRedPacket {\n\n\tprivate int id; \/\/红包ID\n\tprivate int userId; \/\/领取用户ID\n\tprivate String sku; \/\/商品SKU\n\tprivate BigDecimal redPacket; \/\/领取红包金额\n}\n<\/code><\/pre><p>接下来，我们再建立一个计算支付金额的接口类以及基本类：<\/p><pre><code>\/**\n * 计算支付金额接口类\n * @author admin\n *\n *\/\npublic interface IBaseCount {\n\t\n\tBigDecimal countPayMoney(OrderDetail orderDetail);\n\n}\n<\/code><\/pre><pre><code>\/**\n * 支付基本类\n * @author admin\n *\n *\/\npublic class BaseCount implements IBaseCount{\n\n\tpublic BigDecimal countPayMoney(OrderDetail orderDetail) {\norderDetail.setPayMoney(orderDetail.getMerchandise().getPrice());\n\t\tSystem.out.println(&quot;商品原单价金额为：&quot; +  orderDetail.getPayMoney());\n\t\t\n\t\treturn orderDetail.getPayMoney();\n\t}\n\n}\n<\/code><\/pre><p>然后，我们再建立一个计算支付金额的抽象类，由抽象类调用基本类：<\/p><pre><code>\/**\n * 计算支付金额的抽象类\n * @author admin\n *\n *\/\npublic abstract class BaseCountDecorator implements IBaseCount{\n\t\n\tprivate IBaseCount count;\n\t\n\tpublic BaseCountDecorator(IBaseCount count) {\n\t\tthis.count = count;\n\t}\n\n\tpublic BigDecimal countPayMoney(OrderDetail orderDetail) {\n\t\tBigDecimal payTotalMoney = new BigDecimal(0);\n\t\tif(count!=null) {\n\t\t\tpayTotalMoney = count.countPayMoney(orderDetail);\n\t\t}\n\t\treturn payTotalMoney;\n\t}\n}\n<\/code><\/pre><p>然后，我们再通过继承抽象类来实现我们所需要的修饰类（优惠券计算类、红包计算类）：<\/p><pre><code>\/**\n * 计算使用优惠券后的金额\n * @author admin\n *\n *\/\npublic class CouponDecorator extends BaseCountDecorator{\n\n\tpublic CouponDecorator(IBaseCount count) {\n\t\tsuper(count);\n\t}\n\t\n\tpublic BigDecimal countPayMoney(OrderDetail orderDetail) {\n\t\tBigDecimal payTotalMoney = new BigDecimal(0);\n\t\tpayTotalMoney = super.countPayMoney(orderDetail);\n\t\tpayTotalMoney = countCouponPayMoney(orderDetail);\n\t\treturn payTotalMoney;\n\t}\n\t\n\tprivate BigDecimal countCouponPayMoney(OrderDetail orderDetail) {\n\t\t\n\t\tBigDecimal coupon =  orderDetail.getMerchandise().getSupportPromotions().get(PromotionType.COUPON).getUserCoupon().getCoupon();\n\t\tSystem.out.println(&quot;优惠券金额：&quot; + coupon);\n\t\t\n\t\torderDetail.setPayMoney(orderDetail.getPayMoney().subtract(coupon));\n\t\treturn orderDetail.getPayMoney();\n\t}\n}\n<\/code><\/pre><pre><code>\/**\n * 计算使用红包后的金额\n * @author admin\n *\n *\/\npublic class RedPacketDecorator extends BaseCountDecorator{\n\n\tpublic RedPacketDecorator(IBaseCount count) {\n\t\tsuper(count);\n\t}\n\t\n\tpublic BigDecimal countPayMoney(OrderDetail orderDetail) {\n\t\tBigDecimal payTotalMoney = new BigDecimal(0);\n\t\tpayTotalMoney = super.countPayMoney(orderDetail);\n\t\tpayTotalMoney = countCouponPayMoney(orderDetail);\n\t\treturn payTotalMoney;\n\t}\n\t\n\tprivate BigDecimal countCouponPayMoney(OrderDetail orderDetail) {\n\t\t\n\t\tBigDecimal redPacket = orderDetail.getMerchandise().getSupportPromotions().get(PromotionType.REDPACKED).getUserRedPacket().getRedPacket();\n\t\tSystem.out.println(&quot;红包优惠金额：&quot; + redPacket);\n\t\t\n\t\torderDetail.setPayMoney(orderDetail.getPayMoney().subtract(redPacket));\n\t\treturn orderDetail.getPayMoney();\n\t}\n}\n<\/code><\/pre><p>最后，我们通过一个工厂类来组合商品的促销类型：<\/p><pre><code>\/**\n * 计算促销后的支付价格\n * @author admin\n *\n *\/\npublic class PromotionFactory {\n\t\n\tpublic static BigDecimal getPayMoney(OrderDetail orderDetail) {\n\t\t\n\t\t\/\/获取给商品设定的促销类型\n\t\tMap&lt;PromotionType, SupportPromotions&gt; supportPromotionslist = orderDetail.getMerchandise().getSupportPromotions();\n\t\t\n\t\t\/\/初始化计算类\n\t\tIBaseCount baseCount = new BaseCount();\n\t\tif(supportPromotionslist!=null &amp;&amp; supportPromotionslist.size()&gt;0) {\n\t\t\tfor(PromotionType promotionType: supportPromotionslist.keySet()) {\/\/遍历设置的促销类型，通过装饰器组合促销类型\n\t\t\t\tbaseCount = protmotion(supportPromotionslist.get(promotionType), baseCount);\n\t\t\t}\n\t\t}\n\t\treturn baseCount.countPayMoney(orderDetail);\n\t}\n\t\n\t\/**\n\t * 组合促销类型\n\t * @param supportPromotions\n\t * @param baseCount\n\t * @return\n\t *\/\n\tprivate static IBaseCount protmotion(SupportPromotions supportPromotions, IBaseCount baseCount) {\n\t\tif(supportPromotions.getPromotionType()==PromotionType.COUPON) {\n\t\t\tbaseCount = new CouponDecorator(baseCount);\n\t\t}else if(supportPromotions.getPromotionType()==PromotionType.REDPACKED) {\n\t\t\tbaseCount = new RedPacketDecorator(baseCount);\n\t\t}\n\t\treturn baseCount;\n\t}\n\n}\n<\/code><\/pre><pre><code>    public static void main( String[] args ) throws InterruptedException, IOException\n    {\n    \tOrder order = new Order();\n    \tinit(order);\n    \t\n    \tfor(OrderDetail orderDetail: order.getList()) {\n    \t\tBigDecimal payMoney = PromotionFactory.getPayMoney(orderDetail);\n    \t\torderDetail.setPayMoney(payMoney);\n    \t\tSystem.out.println(&quot;最终支付金额：&quot; + orderDetail.getPayMoney());\n    \t}\n    }\n<\/code><\/pre><p>运行结果：<\/p><pre><code>商品原单价金额为：20\n优惠券金额：3\n红包优惠金额：10\n最终支付金额：7\n<\/code><\/pre><p>以上源码可以通过 <a href=\"https:\/\/github.com\/nickliuchao\/decorator.git\">Github<\/a> 下载运行。通过以上案例可知：使用装饰器模式设计的价格优惠策略，实现各个促销类型的计算功能都是相互独立的类，并且可以通过工厂类自由组合各种促销类型。<\/p><h2>总结<\/h2><p>这讲介绍的装饰器模式主要用来优化业务的复杂度，它不仅简化了我们的业务代码，还优化了业务代码的结构设计，使得整个业务逻辑清晰、易读易懂。<\/p><p>通常，装饰器模式用于扩展一个类的功能，且支持动态添加和删除类的功能。在装饰器模式中，装饰类和被装饰类都只关心自身的业务，不相互干扰，真正实现了解耦。<\/p><h2>思考题<\/h2><p>责任链模式、策略模式与装饰器模式有很多相似之处。平时，这些设计模式除了在业务中被用到以外，在架构设计中也经常被用到，你是否在源码中见过这几种设计模式的使用场景呢？欢迎你与大家分享。<\/p><p><\/p>","footer_cover_data":{"img_url":"","mp_url":"","link_url":""},"article_cover_hidden":false,"column_is_experience":false,"is_required":true,"rate":{},"product_id":100028001,"like_count":123,"had_liked":false,"article_subtitle":"无","audio_download_url":"https:\/\/static001.geekbang.org\/resource\/audio\/fb\/7e\/fb48248bfb9c075ce52914582bcba07e.mp3","id":111600,"had_viewed":false,"article_title":"31 | 装饰器模式：如何优化电商系统中复杂的商品价格策略？","column_bgcolor":"#F6F7FB","share":{"content":"覆盖80%以上Java应用调优场景","title":"刘超 · Java性能调优实战","poster":"https:\/\/static001.geekbang.org\/resource\/image\/ed\/99\/edfa939ff065cb8368ed4227930df399.jpg","cover":"https:\/\/static001.geekbang.org\/resource\/image\/b2\/01\/b2f97b2cbefe40e19af4d28508387e01.jpg"},"is_video_preview":false,"article_summary":"装饰器模式能够实现为对象动态添加功能，还能够实现对象的动态组合。","article_poster_wxlite":"https:\/\/static001.geekbang.org\/render\/screen\/d3\/32\/d33f0cbec1f6690f2de004850611ba32.jpeg","column_sale_type":2,"article_features":0,"article_could_preview":false,"column_cover":"https:\/\/static001.geekbang.org\/resource\/image\/b2\/01\/b2f97b2cbefe40e19af4d28508387e01.jpg","column_id":185,"audio_time_arr":{"m":"06","s":"52","h":"00"},"video_time":"","audio_title":"金山刘超30-1","audio_md5":"fb48248bfb9c075ce52914582bcba07e","video_size":0,"text_read_percent":0,"comment_count":29,"cid":185,"article_sharetitle":"装饰器模式：如何优化电商系统中复杂的商品价格策略？","column_is_onboard":true,"article_cshort":"<p>你好，我是刘超。<\/p><p>开始今天的学习之前，我想先请你思考一个问题。假设现在有这样一个需求，让你设计一个装修功能，用户可以动态选择不同的装修功能来装饰自己的房子。例如，水电装修、天花板以及粉刷墙等属于基本功能，而设计窗帘装饰窗户、设计吊顶装饰房顶等未必是所有用户都需要的，这些功能则需要实现动态添加。还有就是一旦有新的装修功能，我们也可以实现动态添加。如果要你来负责，你会怎么设计呢？<\/p><p>此时你可能会想了，通常给一个对象添加功能，要么直接修改代码，在对象中添加相应的功能，要么派生对应的子类来扩展。然而，前者每次都需要修改对象的代码，这显然不是理想的面向对象设计，即便后者是通过派生对应的子类来扩展，也很难满足复杂的随意组合功能需求。<\/p><p>面对这种情况，使用装饰器模式应该再合适不过了。它的优势我想你多少知道一点，我在这里总结一下。<\/p><p>装饰器模式能够实现为对象动态添加装修功能，它是从一个对象的外部来给对象添加功能，所以有非常灵活的扩展性，我们可以在对原来的代码毫无修改的前提下，为对象添加新功能。除此之外，装饰器模式还能够实现对象的动态组合，借此我们可以很灵活地给动态组合的对象，匹配所需要的功能。<\/p><p>下面我们就通过实践，具体看看该模式的优势。<\/p>","video_width":0,"column_could_sub":true,"article_ctime":1564588800,"score":"61564588800","video_media_map":{},"video_preview":{},"video":0,"video_time_arr":{"m":"","s":"","h":""},"video_total_seconds":0},"extra":{},"error":{}}