{"code":0,"data":{"video_id":"","sku":"100028001","video_cover":"","author_name":"刘超","text_read_version":0,"audio_size":11504256,"article_cover":"https:\/\/static001.geekbang.org\/resource\/image\/65\/8a\/6554c83eb7a7f7cee40c188411efc98a.jpg","subtitles":{},"product_type":"c1","audio_url":"https:\/\/res001.geekbang.org\/\/media\/audio\/8c\/70\/8cf1eb4d5700805bb5faed3a97546070\/ld\/ld.m3u8","chapter_id":"0","column_had_sub":true,"audio_dubber":"李良","is_finished":false,"inline_video_subtitles":{},"like":{"had_done":false,"count":92},"neighbors":{"left":{"id":104094,"article_title":"18 | 如何设置线程池大小？"},"right":{"id":105234,"article_title":"20 | 答疑课堂：模块三热点问题解答"}},"audio_time":"00:11:59","video_height":0,"rate_percent":0,"article_content":"<p>你好，我是刘超。<\/p><p>近一两年，国内很多互联网公司开始使用或转型Go语言，其中一个很重要的原因就是Go语言优越的性能表现，而这个优势与Go实现的轻量级线程Goroutines（协程Coroutine）不无关系。那么Go协程的实现与Java线程的实现有什么区别呢？<\/p><h2>线程实现模型<\/h2><p>了解协程和线程的区别之前，我们不妨先来了解下底层实现线程几种方式，为后面的学习打个基础。<\/p><p>实现线程主要有三种方式：轻量级进程和内核线程一对一相互映射实现的1:1线程模型、用户线程和内核线程实现的N:1线程模型以及用户线程和轻量级进程混合实现的N:M线程模型。<\/p><h3>1:1线程模型<\/h3><p>以上我提到的内核线程（Kernel-Level Thread, KLT）是由操作系统内核支持的线程，内核通过调度器对线程进行调度，并负责完成线程的切换。<\/p><p>我们知道在Linux操作系统编程中，往往都是通过fork()函数创建一个子进程来代表一个内核中的线程。一个进程调用fork()函数后，系统会先给新的进程分配资源，例如，存储数据和代码的空间。然后把原来进程的所有值都复制到新的进程中，只有少数值与原来进程的值（比如PID）不同，这相当于复制了一个主进程。<\/p><p>采用fork()创建子进程的方式来实现并行运行，会产生大量冗余数据，即占用大量内存空间，又消耗大量CPU时间用来初始化内存空间以及复制数据。<\/p><!-- [[[read_end]]] --><p>如果是一份一样的数据，为什么不共享主进程的这一份数据呢？这时候轻量级进程（Light Weight Process，即LWP）出现了。<\/p><p>相对于fork()系统调用创建的线程来说，LWP使用clone()系统调用创建线程，该函数是将部分父进程的资源的数据结构进行复制，复制内容可选，且没有被复制的资源可以通过指针共享给子进程。因此，轻量级进程的运行单元更小，运行速度更快。LWP是跟内核线程一对一映射的，每个LWP都是由一个内核线程支持。<\/p><h3>N:1线程模型<\/h3><p>1:1线程模型由于跟内核是一对一映射，所以在线程创建、切换上都存在用户态和内核态的切换，性能开销比较大。除此之外，它还存在局限性，主要就是指系统的资源有限，不能支持创建大量的LWP。<\/p><p>N:1线程模型就可以很好地解决1:1线程模型的这两个问题。<\/p><p>该线程模型是在用户空间完成了线程的创建、同步、销毁和调度，已经不需要内核的帮助了，也就是说在线程创建、同步、销毁的过程中不会产生用户态和内核态的空间切换，因此线程的操作非常快速且低消耗。<\/p><h3>N:M线程模型<\/h3><p>N:1线程模型的缺点在于操作系统不能感知用户态的线程，因此容易造成某一个线程进行系统调用内核线程时被阻塞，从而导致整个进程被阻塞。<\/p><p>N:M线程模型是基于上述两种线程模型实现的一种混合线程管理模型，即支持用户态线程通过LWP与内核线程连接，用户态的线程数量和内核态的LWP数量是N:M的映射关系。<\/p><p><strong>了解完这三个线程模型，你就可以清楚地了解到Go协程的实现与Java线程的实现有什么区别了。<\/strong><\/p><p>JDK 1.8 Thread.java  中  Thread#start  方法的实现，实际上是通过Native调用start0方法实现的；在Linux下， JVM Thread的实现是基于pthread_create实现的，而pthread_create实际上是调用了clone()完成系统调用创建线程的。<\/p><p>所以，目前Java在Linux操作系统下采用的是用户线程加轻量级线程，一个用户线程映射到一个内核线程，即1:1线程模型。由于线程是通过内核调度，从一个线程切换到另一个线程就涉及到了上下文切换。<\/p><p>而Go语言是使用了N:M线程模型实现了自己的调度器，它在N个内核线程上多路复用（或调度）M个协程，协程的上下文切换是在用户态由协程调度器完成的，因此不需要陷入内核，相比之下，这个代价就很小了。<\/p><h2>协程的实现原理<\/h2><p>协程不只在Go语言中实现了，其实目前大部分语言都实现了自己的一套协程，包括C#、erlang、python、lua、javascript、ruby等。<\/p><p>相对于协程，你可能对进程和线程更为熟悉。进程一般代表一个应用服务，在一个应用服务中可以创建多个线程，而协程与进程、线程的概念不一样，<span class=\"orange\">我们可以将协程看作是一个类函数或者一块函数中的代码，<\/span>我们可以在一个主线程里面轻松创建多个协程。<\/p><p>程序调用协程与调用函数不一样的是，协程可以通过暂停或者阻塞的方式将协程的执行挂起，而其它协程可以继续执行。这里的挂起只是在程序中（用户态）的挂起，同时将代码执行权转让给其它协程使用，待获取执行权的协程执行完成之后，将从挂起点唤醒挂起的协程。 协程的挂起和唤醒是通过一个调度器来完成的。<\/p><p>结合下图，你可以更清楚地了解到基于N:M线程模型实现的协程是如何工作的。<\/p><p>假设程序中默认创建两个线程为协程使用，在主线程中创建协程ABCD…，分别存储在就绪队列中，调度器首先会分配一个工作线程A执行协程A，另外一个工作线程B执行协程B，其它创建的协程将会放在队列中进行排队等待。<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/9b\/72\/9b0a301337fa868eab1b9d32e6fcbd72.jpg?wh=666*870\" alt=\"\"><\/p><p>当协程A调用暂停方法或被阻塞时，协程A会进入到挂起队列，调度器会调用等待队列中的其它协程抢占线程A执行。当协程A被唤醒时，它需要重新进入到就绪队列中，通过调度器抢占线程，如果抢占成功，就继续执行协程A，失败则继续等待抢占线程。<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/be\/94\/bebdfb057a9243e640515900eec4ed94.jpg?wh=656*874\" alt=\"\"><\/p><p>相比线程，协程少了由于同步资源竞争带来的CPU上下文切换，I\/O密集型的应用比较适合使用，特别是在网络请求中，有较多的时间在等待后端响应，协程可以保证线程不会阻塞在等待网络响应中，充分利用了多核多线程的能力。而对于CPU密集型的应用，由于在多数情况下CPU都比较繁忙，协程的优势就不是特别明显了。<\/p><h2>Kilim协程框架<\/h2><p>虽然这么多的语言都实现了协程，但目前Java原生语言暂时还不支持协程。不过你也不用泄气，我们可以通过协程框架在Java中使用协程。<\/p><p>目前Kilim协程框架在Java中应用得比较多，通过这个框架，开发人员就可以低成本地在Java中使用协程了。<\/p><p>在Java中引入 <a href=\"https:\/\/github.com\/kilim\/kilim\">Kilim<\/a> ，和我们平时引入第三方组件不太一样，除了引入jar包之外，还需要通过Kilim提供的织入（Weaver）工具对Java代码编译生成的字节码进行增强处理，比如，识别哪些方式是可暂停的，对相关的方法添加上下文处理。通常有以下四种方式可以实现这种织入操作：<\/p><ul>\n<li>在编译时使用maven插件；<\/li>\n<li>在运行时调用kilim.tools.Weaver工具；<\/li>\n<li>在运行时使用kilim.tools.Kilim invoking调用Kilim的类文件；<\/li>\n<li>在main函数添加 if (kilim.tools.Kilim.trampoline(false,args)) return。<\/li>\n<\/ul><p>Kilim框架包含了四个核心组件，分别为：任务载体（Task）、任务上下文（Fiber）、任务调度器（Scheduler）以及通信载体（Mailbox）。<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/20\/13\/20e81165d99c5fc1a55424156e15ff13.jpg?wh=880*690\" alt=\"\"><\/p><p>Task对象主要用来执行业务逻辑，我们可以把这个比作多线程的Thread，与Thread类似，Task中也有一个run方法，不过在Task中方法名为execute，我们可以将协程里面要做的业务逻辑操作写在execute方法中。<\/p><p>与Thread实现的线程一样，Task实现的协程也有状态，包括：Ready、Running、Pausing、Paused以及Done总共五种。Task对象被创建后，处于Ready状态，在调用execute()方法后，协程处于Running状态，在运行期间，协程可以被暂停，暂停中的状态为Pausing，暂停后的状态为Paused，暂停后的协程可以被再次唤醒。协程正常结束后的状态为Done。<\/p><p>Fiber对象与Java的线程栈类似，主要用来维护Task的执行堆栈，Fiber是实现N:M线程映射的关键。<\/p><p>Scheduler是Kilim实现协程的核心调度器，Scheduler负责分派Task给指定的工作者线程WorkerThread执行，工作者线程WorkerThread默认初始化个数为机器的CPU个数。<\/p><p>Mailbox对象类似一个邮箱，协程之间可以依靠邮箱来进行通信和数据共享。协程与线程最大的不同就是，线程是通过共享内存来实现数据共享，而协程是使用了通信的方式来实现了数据共享，主要就是为了避免内存共享数据而带来的线程安全问题。<\/p><h2>协程与线程的性能比较<\/h2><p>接下来，我们通过一个简单的生产者和消费者的案例，来对比下协程和线程的性能。可通过 <a href=\"https:\/\/github.com\/nickliuchao\/coroutine\">Github<\/a> 下载本地运行代码。<\/p><p>Java多线程实现源码：<\/p><pre><code>public class MyThread {\n\tprivate static Integer count = 0;\/\/\n\tprivate static final Integer FULL = 10; \/\/最大生产数量\n\tprivate static String LOCK = &quot;lock&quot;; \/\/资源锁\n\n\tpublic static void main(String[] args) {\n\t\tMyThread test1 = new MyThread();\n\n\t\tlong start = System.currentTimeMillis();\n\n\t\tList&lt;Thread&gt; list = new ArrayList&lt;Thread&gt;();\n\t\tfor (int i = 0; i &lt; 1000; i++) {\/\/创建五个生产者线程\n\t\t\tThread thread = new Thread(test1.new Producer());\n\t\t\tthread.start();\n\t\t\tlist.add(thread);\n\t\t}\n\n\t\tfor (int i = 0; i &lt; 1000; i++) {\/\/创建五个消费者线程\n\t\t\tThread thread = new Thread(test1.new Consumer());\n\t\t\tthread.start();\n\t\t\tlist.add(thread);\n\t\t}\n\n\t\ttry {\n\t\t\tfor (Thread thread : list) {\n\t\t\t\tthread.join();\/\/等待所有线程执行完\n\t\t\t}\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\tlong end = System.currentTimeMillis();\n\t\tSystem.out.println(&quot;子线程执行时长：&quot; + (end - start));\n\t}\n    \/\/生产者\n\tclass Producer implements Runnable {\n\t\tpublic void run() {\n\t\t\tfor (int i = 0; i &lt; 10; i++) {\n\t\t\t\tsynchronized (LOCK) {\n\t\t\t\t\twhile (count == FULL) {\/\/当数量满了时\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tLOCK.wait();\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcount++;\n\t\t\t\t\tSystem.out.println(Thread.currentThread().getName() + &quot;生产者生产，目前总共有&quot; + count);\n\t\t\t\t\tLOCK.notifyAll();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n    \/\/消费者\n\tclass Consumer implements Runnable {\n\t\tpublic void run() {\n\t\t\tfor (int i = 0; i &lt; 10; i++) {\n\t\t\t\tsynchronized (LOCK) {\n\t\t\t\t\twhile (count == 0) {\/\/当数量为零时   \n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tLOCK.wait();\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcount--;\n\t\t\t\t\tSystem.out.println(Thread.currentThread().getName() + &quot;消费者消费，目前总共有&quot; + count);\n\t\t\t\t\tLOCK.notifyAll();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n<\/code><\/pre><p>Kilim协程框架实现源码：<\/p><pre><code>public class Coroutine  {\n\n\t\tstatic Map&lt;Integer, Mailbox&lt;Integer&gt;&gt; mailMap = new HashMap&lt;Integer, Mailbox&lt;Integer&gt;&gt;();\/\/为每个协程创建一个信箱，由于协程中不能多个消费者共用一个信箱，需要为每个消费者提供一个信箱，这也是协程通过通信来保证共享变量的线程安全的一种方式\n\n\tpublic static void main(String[] args) {\n\n\t\tif (kilim.tools.Kilim.trampoline(false,args)) return;\n\t\tProperties propes = new Properties();\n\t\tpropes.setProperty(&quot;kilim.Scheduler.numThreads&quot;, &quot;1&quot;);\/\/设置一个线程\n\t\tSystem.setProperties(propes);\n\t\tlong startTime = System.currentTimeMillis();\n\t\tfor (int i = 0; i &lt; 1000; i++) {\/\/创建一千生产者\n\t\t\tMailbox&lt;Integer&gt; mb = new Mailbox&lt;Integer&gt;(1, 10);\n\t\t\tnew Producer(i, mb).start();\n\t\t\tmailMap.put(i, mb);\n\t\t}\n\t\t\n\t\tfor (int i = 0; i &lt; 1000; i++) {\/\/创建一千个消费者\n\t\t\tnew Consumer(mailMap.get(i)).start();\n\t\t}\n\t\t\n\t\tTask.idledown();\/\/开始运行\n\t\t\n\t\t long endTime = System.currentTimeMillis();\n\t        \n\t     System.out.println( Thread.currentThread().getName()  + &quot;总计花费时长：&quot; + (endTime- startTime));\n\t}\n\t\n}\n<\/code><\/pre><pre><code>\/\/生产者\npublic class Producer extends Task&lt;Object&gt; {\n\n\tInteger count = null;\n\tMailbox&lt;Integer&gt; mb = null;\n\n\tpublic Producer(Integer count, Mailbox&lt;Integer&gt; mb) {\n\t\tthis.count = count;\n\t\tthis.mb = mb;\n\t}\n\n\tpublic void execute() throws Pausable {\n\t\tcount = count*10;\n\t\tfor (int i = 0; i &lt; 10; i++) {\n\t\t\tmb.put(count);\/\/当空间不足时，阻塞协程线程\n\t\t\tSystem.out.println(Thread.currentThread().getName() + &quot;生产者生产，目前总共有&quot; + mb.size() + &quot;生产了：&quot; + count);\n\t\t\tcount++;\n\t\t}\n\t}\n}\n<\/code><\/pre><pre><code>\/\/消费者\npublic class Consumer extends Task&lt;Object&gt; {\n\n\tMailbox&lt;Integer&gt; mb = null;\n\n\tpublic Consumer(Mailbox&lt;Integer&gt; mb) {\n\t\tthis.mb = mb;\n\t}\n\n\t\/**\n\t * 执行\n\t *\/\n\tpublic void execute() throws Pausable {\n\t\tInteger c = null;\n\t\tfor (int i = 0; i &lt; 10000; i++)  {\n\t\t\tc = mb.get();\/\/获取消息，阻塞协程线程\n\t\t\t\n\t\t\tif (c == null) {\n\t\t\t\tSystem.out.println(&quot;计数&quot;);\n\t\t\t}else {\n\t\t\t\tSystem.out.println(Thread.currentThread().getName() + &quot;消费者消费，目前总共有&quot; + mb.size() + &quot;消费了：&quot; + c);\n\t\t\t\tc = null;\n\t\t\t}\n\t\t}\n\t}\n}\n<\/code><\/pre><p>在这个案例中，我创建了1000个生产者和1000个消费者，每个生产者生产10个产品，1000个消费者同时消费产品。我们可以看到两个例子运行的结果如下：<\/p><pre><code>多线程执行时长：2761\n<\/code><\/pre><pre><code>协程执行时长：1050\n<\/code><\/pre><p>通过上述性能对比，我们可以发现：在有严重阻塞的场景下，协程的性能更胜一筹。其实，<span class=\"orange\">I\/O阻塞型场景也就是协程在Java中的主要应用。<\/span><\/p><h2>总结<\/h2><p>协程和线程密切相关，协程可以认为是运行在线程上的代码块，协程提供的挂起操作会使协程暂停执行，而不会导致线程阻塞。<\/p><p>协程又是一种轻量级资源，即使创建了上千个协程，对于系统来说也不是很大的负担，但如果在程序中创建上千个线程，那系统可真就压力山大了。可以说，<span class=\"orange\">协程的设计方式极大地提高了线程的使用率。<\/span><\/p><p>通过今天的学习，当其他人侃侃而谈Go语言在网络编程中的优势时，相信你不会一头雾水。学习Java的我们也不要觉得，协程离我们很遥远了。协程是一种设计思想，不仅仅局限于某一门语言，况且Java已经可以借助协程框架实现协程了。<\/p><p>但话说回来，协程还是在Go语言中的应用较为成熟，在Java中的协程目前还不是很稳定，重点是缺乏大型项目的验证，可以说Java的协程设计还有很长的路要走。<\/p><h2>思考题<\/h2><p>在Java中，除了Kilim框架，你知道还有其它协程框架也可以帮助Java实现协程吗？你使用过吗？<\/p><p>期待在留言区看到你的见解。也欢迎你点击“请朋友读”，把今天的内容分享给身边的朋友，邀请他一起讨论。<\/p><p><\/p>","footer_cover_data":{"img_url":"","mp_url":"","link_url":""},"article_cover_hidden":false,"column_is_experience":false,"is_required":true,"rate":{},"product_id":100028001,"like_count":112,"had_liked":false,"article_subtitle":"无","audio_download_url":"https:\/\/static001.geekbang.org\/resource\/audio\/8c\/70\/8cf1eb4d5700805bb5faed3a97546070.mp3","id":104521,"had_viewed":false,"article_title":"19 | 如何用协程来优化多线程业务？","column_bgcolor":"#F6F7FB","share":{"content":"覆盖80%以上Java应用调优场景","title":"刘超 · Java性能调优实战","poster":"https:\/\/static001.geekbang.org\/resource\/image\/ed\/99\/edfa939ff065cb8368ed4227930df399.jpg","cover":"https:\/\/static001.geekbang.org\/resource\/image\/b2\/01\/b2f97b2cbefe40e19af4d28508387e01.jpg"},"is_video_preview":false,"article_summary":"协程是一种设计思想，不仅仅局限于某一门语言，Java已经可以借助协程框架实现协程了。","article_poster_wxlite":"https:\/\/static001.geekbang.org\/render\/screen\/ea\/49\/ea53bc212b304227628ce7b6b6a3ca49.jpeg","column_sale_type":1,"article_features":0,"article_could_preview":false,"column_cover":"https:\/\/static001.geekbang.org\/resource\/image\/b2\/01\/b2f97b2cbefe40e19af4d28508387e01.jpg","column_id":185,"audio_time_arr":{"m":"11","s":"59","h":"00"},"video_time":"","audio_title":"Java性能19","audio_md5":"8cf1eb4d5700805bb5faed3a97546070","video_size":0,"text_read_percent":0,"comment_count":34,"cid":185,"article_sharetitle":"Java如何用协程来优化多线程业务？","column_is_onboard":true,"article_cshort":"<p>你好，我是刘超。<\/p><p>近一两年，国内很多互联网公司开始使用或转型Go语言，其中一个很重要的原因就是Go语言优越的性能表现，而这个优势与Go实现的轻量级线程Goroutines（协程Coroutine）不无关系。那么Go协程的实现与Java线程的实现有什么区别呢？<\/p><h2>线程实现模型<\/h2><p>了解协程和线程的区别之前，我们不妨先来了解下底层实现线程几种方式，为后面的学习打个基础。<\/p><p>实现线程主要有三种方式：轻量级进程和内核线程一对一相互映射实现的1:1线程模型、用户线程和内核线程实现的N:1线程模型以及用户线程和轻量级进程混合实现的N:M线程模型。<\/p><h3>1:1线程模型<\/h3><p>以上我提到的内核线程（Kernel-Level Thread, KLT）是由操作系统内核支持的线程，内核通过调度器对线程进行调度，并负责完成线程的切换。<\/p><p>我们知道在Linux操作系统编程中，往往都是通过fork()函数创建一个子进程来代表一个内核中的线程。一个进程调用fork()函数后，系统会先给新的进程分配资源，例如，存储数据和代码的空间。然后把原来进程的所有值都复制到新的进程中，只有少数值与原来进程的值（比如PID）不同，这相当于复制了一个主进程。<\/p><p>采用fork()创建子进程的方式来实现并行运行，会产生大量冗余数据，即占用大量内存空间，又消耗大量CPU时间用来初始化内存空间以及复制数据。<\/p>","video_width":0,"column_could_sub":true,"article_ctime":1561996800,"score":"41561996800","video_media_map":{},"video_preview":{},"video":0,"video_time_arr":{"m":"","s":"","h":""},"video_total_seconds":0},"extra":{},"error":{}}