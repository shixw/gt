{"code":0,"data":{"video_id":"","sku":"100077001","video_cover":"","author_name":"傅健","text_read_version":0,"audio_size":14756563,"article_cover":"https:\/\/static001.geekbang.org\/resource\/image\/bf\/yy\/bf50352e846a49131858dc0d9e659cyy.jpg","subtitles":{},"product_type":"c1","audio_url":"https:\/\/res001.geekbang.org\/media\/audio\/99\/f2\/99f86639d1b9f4a664f86fbeb13a54f2\/ld\/ld.m3u8","chapter_id":"0","column_had_sub":true,"audio_dubber":"傅健","is_finished":false,"inline_video_subtitles":{},"like":{"had_done":false,"count":5},"neighbors":{"left":{"id":381193,"article_title":"19 | Spring 事务常见错误（上）"},"right":{"id":382710,"article_title":"21 | Spring Rest Template 常见错误"}},"audio_time":"00:15:24","video_height":0,"rate_percent":0,"article_content":"<p>你好，我是傅健。<\/p><p>通过上一节课的学习，我们了解了 Spring 事务的原理，并解决了几个常见的问题。这节课我们将继续讨论事务中的另外两个问题，一个是关于事务的传播机制，另一个是关于多数据源的切换问题，通过这两个问题，你可以更加深入地了解 Spring 事务的核心机制。<\/p><h2>案例 1：嵌套事务回滚错误<\/h2><p>上一节课我们完成了学生注册功能，假设我们需要对这个功能继续进行扩展，当学生注册完成后，需要给这个学生登记一门英语必修课，并更新这门课的登记学生数。为此，我添加了两个表。<\/p><ol>\n<li>课程表 course，记录课程名称和注册的学生数。<\/li>\n<\/ol><pre><code>CREATE TABLE `course` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `course_name` varchar(64) DEFAULT NULL,\n  `number` int(11) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n<\/code><\/pre><ol start=\"2\">\n<li>学生选课表 student_course，记录学生表 student 和课程表 course 之间的多对多关联。<\/li>\n<\/ol><pre><code>CREATE TABLE `student_course` (\n  `student_id` int(11) NOT NULL,\n  `course_id` int(11) NOT NULL\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n<\/code><\/pre><p>同时我为课程表初始化了一条课程信息，id = 1，course_name = \"英语\"，number = 0。<\/p><p>接下来我们完成用户的相关操作，主要包括两部分。<\/p><ol>\n<li>新增学生选课记录<\/li>\n<\/ol><pre><code>@Mapper\npublic interface StudentCourseMapper {\n    @Insert(&quot;INSERT INTO `student_course`(`student_id`, `course_id`) VALUES (#{studentId}, #{courseId})&quot;)\n    void saveStudentCourse(@Param(&quot;studentId&quot;) Integer studentId, @Param(&quot;courseId&quot;) Integer courseId);\n}\n<\/code><\/pre><ol start=\"2\">\n<li>课程登记学生数 + 1<\/li>\n<\/ol><pre><code>@Mapper\npublic interface CourseMapper {\n    @Update(&quot;update `course` set number = number + 1 where id = #{id}&quot;)\n    void addCourseNumber(int courseId);\n}\n<\/code><\/pre><p>我们增加了一个新的业务类 CourseService，用于实现相关业务逻辑。分别调用了上述两个方法来保存学生与课程的关联关系，并给课程注册人数+1。最后，别忘了给这个方法加上事务注解。<\/p><!-- [[[read_end]]] --><pre><code>@Service\npublic class CourseService {\n    @Autowired\n    private CourseMapper courseMapper;\n\n    @Autowired\n    private StudentCourseMapper studentCourseMapper;\n\n    \/\/注意这个方法标记了“Transactional”\n    @Transactional(rollbackFor = Exception.class)\n    public void regCourse(int studentId) throws Exception {\n        studentCourseMapper.saveStudentCourse(studentId, 1);\n        courseMapper.addCourseNumber(1);\n    }\n}\n\n<\/code><\/pre><p>我们在之前的 StudentService.saveStudent() 中调用了 regCourse()，实现了完整的业务逻辑。为了避免注册课程的业务异常导致学生信息无法保存，在这里 catch 了注册课程方法中抛出的异常。我们希望的结果是，当注册课程发生错误时，只回滚注册课程部分，保证学生信息依然正常。<\/p><pre><code>@Service\npublic class StudentService {\n  \/\/省略非关键代码\n  @Transactional(rollbackFor = Exception.class)\n  public void saveStudent(String realname) throws Exception {\n      Student student = new Student();\n      student.setRealname(realname);\n      studentService.doSaveStudent(student);\n      try {\n          courseService.regCourse(student.getId());\n      } catch (Exception e) {\n          e.printStackTrace();\n      }\n  }\n  \/\/省略非关键代码\n}\n<\/code><\/pre><p>为了验证异常是否符合预期，我们在 regCourse() 里抛出了一个注册失败的异常：<\/p><pre><code>@Transactional(rollbackFor = Exception.class)\npublic void regCourse(int studentId) throws Exception {\n    studentCourseMapper.saveStudentCourse(studentId, 1);\n    courseMapper.addCourseNumber(1);\n    throw new Exception(&quot;注册失败&quot;);\n}\n<\/code><\/pre><p>运行一下这段代码，在控制台里我们看到了以下提示信息：<\/p><pre><code>java.lang.Exception: 注册失败\n\tat com.spring.puzzle.others.transaction.example3.CourseService.regCourse(CourseService.java:22)\n\/\/......省略非关键代码.....\nException in thread &quot;main&quot; org.springframework.transaction.UnexpectedRollbackException: Transaction rolled back because it has been marked as rollback-only\n\tat org.springframework.transaction.support.AbstractPlatformTransactionManager.processRollback(AbstractPlatformTransactionManager.java:873)\n\tat org.springframework.transaction.support.AbstractPlatformTransactionManager.commit(AbstractPlatformTransactionManager.java:710)\n\tat org.springframework.transaction.interceptor.TransactionAspectSupport.commitTransactionAfterReturning(TransactionAspectSupport.java:533)\n\tat org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:304)\n\tat org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:98)\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\n\tat org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:688)\n\tat com.spring.puzzle.others.transaction.example3.StudentService$$EnhancerBySpringCGLIB$$50cda404.saveStudent(&lt;generated&gt;)\n\tat com.spring.puzzle.others.transaction.example3.AppConfig.main(AppConfig.java:22)\n<\/code><\/pre><p>其中，注册失败部分的异常符合预期，但是后面又多了一个这样的错误提示：Transaction rolled back because it has been marked as rollback-only。<\/p><p>最后的结果是，学生和选课的信息都被回滚了，显然这并不符合我们的预期。我们期待的结果是即便内部事务regCourse()发生异常，外部事务saveStudent()俘获该异常后，内部事务应自行回滚，不影响外部事务。那么这是什么原因造成的呢？我们需要研究一下 Spring 的源码，来找找答案。<\/p><h3>案例解析<\/h3><p>在做进一步的解析之前，我们可以先通过伪代码把整个事务的结构梳理一下：<\/p><pre><code>  \/\/ 外层事务\n  @Transactional(rollbackFor = Exception.class)\n  public void saveStudent(String realname) throws Exception {\n      \/\/......省略逻辑代码.....\n      studentService.doSaveStudent(student);\n      try {\n        \/\/ 嵌套的内层事务\n        @Transactional(rollbackFor = Exception.class)\n        public void regCourse(int studentId) throws Exception {\n          \/\/......省略逻辑代码.....\n        }\n      } catch (Exception e) {\n          e.printStackTrace();\n      }\n  }\n<\/code><\/pre><p>可以看出来，整个业务是包含了 2 层事务，外层的 saveStudent() 的事务和内层的 regCourse() 事务。<\/p><p>在 Spring 声明式的事务处理中，有一个属性 propagation，表示打算对这些方法怎么使用事务，即一个带事务的方法调用了另一个带事务的方法，被调用的方法它怎么处理自己事务和调用方法事务之间的关系。<\/p><p>其中 propagation 有7种配置：REQUIRED、SUPPORTS、MANDATORY、REQUIRES_NEW、NOT_SUPPORTED、NEVER、NESTED。默认是 REQUIRED，它的含义是：如果本来有事务，则加入该事务，如果没有事务，则创建新的事务。<\/p><p>结合我们的伪代码示例，因为在 saveStudent() 上声明了一个外部的事务，就已经存在一个事务了，在propagation值为默认的REQUIRED的情况下， regCourse() 就会加入到已有的事务中，两个方法共用一个事务。<\/p><p>我们再来看下  Spring 事务处理的核心，其关键实现参考TransactionAspectSupport.invokeWithinTransaction()：<\/p><pre><code>protected Object invokeWithinTransaction(Method method, @Nullable Class&lt;?&gt; targetClass,\n      final InvocationCallback invocation) throws Throwable {\n \n   TransactionAttributeSource tas = getTransactionAttributeSource();\n   final TransactionAttribute txAttr = (tas != null ? tas.getTransactionAttribute(method, targetClass) : null);\n   final PlatformTransactionManager tm = determineTransactionManager(txAttr);\n   final String joinpointIdentification = methodIdentification(method, targetClass, txAttr);\n   if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) {\n      \/\/ 是否需要创建一个事务\n      TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);\n      Object retVal = null;\n      try {\n         \/\/ 调用具体的业务方法\n         retVal = invocation.proceedWithInvocation();\n      }\n      catch (Throwable ex) {\n         \/\/ 当发生异常时进行处理\n         completeTransactionAfterThrowing(txInfo, ex);\n         throw ex;\n      }\n      finally {\n         cleanupTransactionInfo(txInfo);\n      }\n      \/\/ 正常返回时提交事务\n      commitTransactionAfterReturning(txInfo);\n      return retVal;\n   }\n   \/\/......省略非关键代码.....\n}\n<\/code><\/pre><p>整个方法完成了事务的一整套处理逻辑，如下：<\/p><ol>\n<li>检查是否需要创建事务；<\/li>\n<li>调用具体的业务方法进行处理；<\/li>\n<li>提交事务；<\/li>\n<li>处理异常。<\/li>\n<\/ol><p>这里要格外注意的是，当前案例是两个事务嵌套的场景，外层事务 doSaveStudent()和内层事务 regCourse()，每个事务都会调用到这个方法。所以，这个方法会被调用两次。下面我们来具体来看下内层事务对异常的处理。<\/p><p>当捕获了异常，会调用TransactionAspectSupport.completeTransactionAfterThrowing() 进行异常处理：<\/p><pre><code>protected void completeTransactionAfterThrowing(@Nullable TransactionInfo txInfo, Throwable ex) {\n   if (txInfo != null &amp;&amp; txInfo.getTransactionStatus() != null) {\n      if (txInfo.transactionAttribute != null &amp;&amp; txInfo.transactionAttribute.rollbackOn(ex)) {\n         try {\n            txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());\n         }\n         catch (TransactionSystemException ex2) {\n            logger.error(&quot;Application exception overridden by rollback exception&quot;, ex);\n            ex2.initApplicationException(ex);\n            throw ex2;\n         }\n         catch (RuntimeException | Error ex2) {\n            logger.error(&quot;Application exception overridden by rollback exception&quot;, ex);\n            throw ex2;\n         }\n      }\n      \/\/......省略非关键代码.....\n   }\n}\n<\/code><\/pre><p>在这个方法里，我们对异常类型做了一些检查，当符合声明中的定义后，执行了具体的 rollback 操作，这个操作是通过 TransactionManager.rollback() 完成的：<\/p><pre><code>public final void rollback(TransactionStatus status) throws TransactionException {\n   if (status.isCompleted()) {\n      throw new IllegalTransactionStateException(\n            &quot;Transaction is already completed - do not call commit or rollback more than once per transaction&quot;);\n   }\n\n   DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;\n   processRollback(defStatus, false);\n}\n<\/code><\/pre><p>而 rollback() 是在 AbstractPlatformTransactionManager 中实现的，继续调用了 processRollback()：<\/p><pre><code>private void processRollback(DefaultTransactionStatus status, boolean unexpected) {\n   try {\n      boolean unexpectedRollback = unexpected;\n\n      if (status.hasSavepoint()) {\n         \/\/ 有保存点\n         status.rollbackToHeldSavepoint();\n      }\n      else if (status.isNewTransaction()) {\n         \/\/ 是否为一个新的事务\n         doRollback(status);\n      }\n      else {\n        \/\/ 处于一个更大的事务中\n        if (status.hasTransaction()) {\n           \/\/ 分支1\n           if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) {\n              doSetRollbackOnly(status);\n           }\n        }\n        if (!isFailEarlyOnGlobalRollbackOnly()) {\n           unexpectedRollback = false;\n        }\n      }\n\n      \/\/ 省略非关键代码 \n      if (unexpectedRollback) {\n         throw new UnexpectedRollbackException(\n               &quot;Transaction rolled back because it has been marked as rollback-only&quot;);\n      }\n   }\n   finally {\n      cleanupAfterCompletion(status);\n   }\n}\n<\/code><\/pre><p>这个方法里区分了三种不同类型的情况：<\/p><ol>\n<li>是否有保存点；<\/li>\n<li>是否为一个新的事务；<\/li>\n<li>是否处于一个更大的事务中。<\/li>\n<\/ol><p>在这里，因为我们用的是默认的传播类型REQUIRED，嵌套的事务并没有开启一个新的事务，所以在这种情况下，当前事务是处于一个更大的事务中，所以会走到情况3分支1的代码块下。<\/p><p>这里有两个判断条件来确定是否设置为仅回滚：<br>\nif (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure())<\/p><p>满足任何一个，都会执行 doSetRollbackOnly() 操作。isLocalRollbackOnly 在当前的情况下是 false，所以是否分设置为仅回滚就由 isGlobalRollbackOnParticipationFailure() 这个方法来决定了，其默认值为 true， 即是否回滚交由外层事务统一决定 。<\/p><p>显然这里的条件得到了满足，从而执行 doSetRollbackOnly：<\/p><pre><code>protected void doSetRollbackOnly(DefaultTransactionStatus status) {\n   DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();\n   txObject.setRollbackOnly();\n}\n<\/code><\/pre><p>以及最终调用到的<strong>DataSourceTransactionObject中的setRollbackOnly()：<\/strong><\/p><pre><code>public void setRollbackOnly() {\n   getConnectionHolder().setRollbackOnly();\n}\n<\/code><\/pre><p>到这一步，内层事务的操作基本执行完毕，它处理了异常，并最终调用到了<strong>DataSourceTransactionObject中的setRollbackOnly()<\/strong>。<\/p><p>接下来，我们来看外层事务。因为在外层事务中，我们自己的代码捕获了内层抛出来的异常，所以这个异常不会继续往上抛，最后的事务会在 TransactionAspectSupport.invokeWithinTransaction() 中的 commitTransactionAfterReturning() 中进行处理：<\/p><pre><code>protected void commitTransactionAfterReturning(@Nullable TransactionInfo txInfo) {\n   if (txInfo != null &amp;&amp; txInfo.getTransactionStatus() != null) {     txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());\n   }\n}\n<\/code><\/pre><p>在这个方法里我们执行了 commit 操作，代码如下：<\/p><pre><code>public final void commit(TransactionStatus status) throws TransactionException {\n   \/\/......省略非关键代码.....\n   if (!shouldCommitOnGlobalRollbackOnly() &amp;&amp; defStatus.isGlobalRollbackOnly()) {\n      processRollback(defStatus, true);\n      return;\n   }\n\n   processCommit(defStatus);\n}\n<\/code><\/pre><p>在 AbstractPlatformTransactionManager.commit()中，当满足了 shouldCommitOnGlobalRollbackOnly() 和 defStatus.isGlobalRollbackOnly()，就会回滚，否则会继续提交事务。其中shouldCommitOnGlobalRollbackOnly()的作用为，如果发现了事务被标记了全局回滚，并且在发生了全局回滚的情况下，判断是否应该提交事务，这个方法的默认实现是返回了 false，这里我们不需要关注它，继续查看isGlobalRollbackOnly()的实现：<\/p><pre><code>public boolean isGlobalRollbackOnly() {\n   return ((this.transaction instanceof SmartTransactionObject) &amp;&amp;\n         ((SmartTransactionObject) this.transaction).isRollbackOnly());\n}\n<\/code><\/pre><p>这个方法最终进入了<strong>DataSourceTransactionObject类中的isRollbackOnly()：<\/strong><\/p><pre><code>public boolean isRollbackOnly() {\n   return getConnectionHolder().isRollbackOnly();\n}\n<\/code><\/pre><p>现在让我们再次回顾一下之前的内部事务处理结果，其最终调用到的是<strong>DataSourceTransactionObject中的setRollbackOnly()：<\/strong><\/p><pre><code>public void setRollbackOnly() {\n   getConnectionHolder().setRollbackOnly();\n}\n<\/code><\/pre><p>isRollbackOnly()和setRollbackOnly()这两个方法的执行本质都是对ConnectionHolder中rollbackOnly属性标志位的存取，而ConnectionHolder则存在于DefaultTransactionStatus类实例的transaction属性之中。<\/p><p>至此，答案基本浮出水面了，我们把整个逻辑串在一起就是：外层事务是否回滚的关键，最终取决于<strong>DataSourceTransactionObject类中的isRollbackOnly()，而该方法的返回值，正是我们在内层异常的时候设置的<\/strong>。<\/p><p>所以最终外层事务也被回滚了，从而在控制台中打印出异常信息：\"Transaction rolled back because it has been marked as rollback-only\"。<\/p><p>所以到这里，问题也就清楚了，Spring默认的事务传播属性为REQUIRED，如我们之前介绍的，它的含义是：如果本来有事务，则加入该事务，如果没有事务，则创建新的事务，因而内外两层事务都处于同一个事务中。所以，当我们在 regCourse()中抛出异常，并触发了回滚操作时，这个回滚会进一步传播，从而把 saveStudent() 也回滚了。最终导致整个事务都被回滚了。<\/p><h3>问题修正<\/h3><p>从上述案例解析中，我们了解到，Spring 在处理事务过程中，有个默认的传播属性 REQUIRED，在整个事务的调用链上，任何一个环节抛出的异常都会导致全局回滚。<\/p><p>知道了这个结论，修改方法也就很简单了，我们只需要对传播属性进行修改，把类型改成 REQUIRES_NEW 就可以了。于是这部分代码就修改成这样：<\/p><pre><code>@Transactional(rollbackFor = Exception.class, propagation = Propagation.REQUIRES_NEW)\npublic void regCourse(int studentId) throws Exception {\n    studentCourseMapper.saveStudentCourse(studentId, 1);\n    courseMapper.addCourseNumber(1);\n    throw new Exception(&quot;注册失败&quot;);\n}\n<\/code><\/pre><p>运行一下看看：<\/p><pre><code>java.lang.Exception: 注册失败\n\tat com.spring.puzzle.others.transaction.example3.CourseService.regCourse(CourseService.java:22)\n<\/code><\/pre><p>异常正常抛出，注册课程部分的数据没有保存，但是学生还是正常注册成功。这意味着此时Spring 只对注册课程这部分的数据进行了回滚，并没有传播到上一级。<\/p><p>这里我简单解释下这个过程：<\/p><ul>\n<li>当子事务声明为 Propagation.REQUIRES_NEW 时，在 TransactionAspectSupport.invokeWithinTransaction() 中调用 createTransactionIfNecessary() 就会创建一个新的事务，独立于外层事务。<\/li>\n<li>而在 AbstractPlatformTransactionManager.processRollback() 进行 rollback 处理时，因为 status.isNewTransaction() 会因为它处于一个新的事务中而返回 true，所以它走入到了另一个分支，执行了 doRollback() 操作，让这个子事务单独回滚，不会影响到主事务。<\/li>\n<\/ul><p>至此，这个问题得到了很好的解决。<\/p><h2>案例 2：多数据源间切换之谜<\/h2><p>在前面的案例中，我们完成了学生注册功能和课程注册功能。假设新需求又来了，每个学生注册的时候，需要给他们发一张校园卡，并给校园卡里充入 50 元钱。但是这个校园卡管理系统是一个第三方系统，使用的是另一套数据库，这样我们就需要在一个事务中同时操作两个数据库。<\/p><p>第三方的 Card 表如下：<\/p><pre><code>CREATE TABLE `card` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `student_id` int(11) DEFAULT NULL,\n  `balance` int(11) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n<\/code><\/pre><p>对应的 Card 对象如下：<\/p><pre><code>public class Card {\n    private Integer id;\n    private Integer studentId;\n    private Integer balance;\n    \/\/省略 Get\/Set 方法\n}\n<\/code><\/pre><p>对应的 Mapper 接口如下，里面包含了一个 saveCard 的 insert 语句，用于创建一条校园卡记录：<\/p><pre><code>@Mapper\npublic interface CardMapper {\n    @Insert(&quot;INSERT INTO `card`(`student_id`, `balance`) VALUES (#{studentId}, #{balance})&quot;)\n    @Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;)\n    int saveCard(Card card);\n}\n<\/code><\/pre><p>Card 的业务类如下，里面实现了卡与学生 ID 关联，以及充入 50 元的操作：<\/p><pre><code>@Service\npublic class CardService {\n    @Autowired\n    private CardMapper cardMapper;\n\n    @Transactional\n    public void createCard(int studentId) throws Exception {\n        Card card = new Card();\n        card.setStudentId(studentId);\n        card.setBalance(50);\n        cardMapper.saveCard(card);\n    }\n}\n<\/code><\/pre><h3>案例解析<\/h3><p>这是一个相对常见的需求，学生注册和发卡都要在一个事务里完成，但是我们都默认只会连一个数据源，之前我们一直连的都是学生信息这个数据源，在这里，我们还需要对校园卡的数据源进行操作。于是，我们需要在一个事务里完成对两个数据源的操作，该如何实现这样的功能呢？<\/p><p>我们继续从 Spring 的源码中寻找答案。在 Spring 里有这样一个抽象类 AbstractRoutingDataSource，这个类相当于 DataSource 的路由中介，在运行时根据某种 key 值来动态切换到所需的 DataSource 上。通过实现这个类就可以实现我们期望的动态数据源切换。<\/p><p>这里强调一下，这个类里有这么几个关键属性：<\/p><ul>\n<li>targetDataSources 保存了 key 和数据库连接的映射关系；<\/li>\n<li>defaultTargetDataSource 标识默认的连接；<\/li>\n<li>resolvedDataSources 存储数据库标识和数据源的映射关系。<\/li>\n<\/ul><pre><code>public abstract class AbstractRoutingDataSource extends AbstractDataSource implements InitializingBean {\n\n   @Nullable\n   private Map&lt;Object, Object&gt; targetDataSources;\n\n   @Nullable\n   private Object defaultTargetDataSource;\n\n   private boolean lenientFallback = true;\n\n   private DataSourceLookup dataSourceLookup = new JndiDataSourceLookup();\n\n   @Nullable\n   private Map&lt;Object, DataSource&gt; resolvedDataSources;\n\n   @Nullable\n   private DataSource resolvedDefaultDataSource;\n \n   \/\/省略非关键代码\n}\n<\/code><\/pre><p>AbstractRoutingDataSource 实现了 InitializingBean 接口，并覆写了 afterPropertiesSet()。该方法会在初始化 Bean 的时候执行，将多个 DataSource 初始化到 resolvedDataSources。这里的 targetDataSources 属性存储了将要切换的多数据源 Bean 信息。<\/p><pre><code>@Override\npublic void afterPropertiesSet() {\n   if (this.targetDataSources == null) {\n      throw new IllegalArgumentException(&quot;Property 'targetDataSources' is required&quot;);\n   }\n   this.resolvedDataSources = new HashMap&lt;&gt;(this.targetDataSources.size());\n   this.targetDataSources.forEach((key, value) -&gt; {\n      Object lookupKey = resolveSpecifiedLookupKey(key);\n      DataSource dataSource = resolveSpecifiedDataSource(value);\n      this.resolvedDataSources.put(lookupKey, dataSource);\n   });\n   if (this.defaultTargetDataSource != null) {\n      this.resolvedDefaultDataSource = resolveSpecifiedDataSource(this.defaultTargetDataSource);\n   }\n}\n<\/code><\/pre><p>获取数据库连接的是 getConnection()，它调用了 determineTargetDataSource()来创建连接：<\/p><pre><code>@Override\npublic Connection getConnection() throws SQLException {\n   return determineTargetDataSource().getConnection();\n}\n\n@Override\npublic Connection getConnection(String username, String password) throws SQLException {\n   return determineTargetDataSource().getConnection(username, password);\n}\n<\/code><\/pre><p>determineTargetDataSource()是整个部分的核心，它的作用就是动态切换数据源。有多少个数据源，就存多少个数据源在 targetDataSources 中。<\/p><p>targetDataSources 是一个 Map 类型的属性，key 表示每个数据源的名字，value 对应的是每个数据源 DataSource。<\/p><pre><code>protected DataSource determineTargetDataSource() {\n   Assert.notNull(this.resolvedDataSources, &quot;DataSource router not initialized&quot;);\n   Object lookupKey = determineCurrentLookupKey();\n   DataSource dataSource = this.resolvedDataSources.get(lookupKey);\n   if (dataSource == null &amp;&amp; (this.lenientFallback || lookupKey == null)) {\n      dataSource = this.resolvedDefaultDataSource;\n   }\n   if (dataSource == null) {\n      throw new IllegalStateException(&quot;Cannot determine target DataSource for lookup key [&quot; + lookupKey + &quot;]&quot;);\n   }\n   return dataSource;\n}\n<\/code><\/pre><p>而选择哪个数据源又是由 determineCurrentLookupKey()来决定的，此方法是抽象方法，需要我们继承 AbstractRoutingDataSource 抽象类来重写此方法。该方法返回一个 key，该 key 是 Bean 中的 beanName，并赋值给 lookupKey，由此 key 可以通过 resolvedDataSources 属性的键来获取对应的 DataSource 值，从而达到数据源切换的效果。<\/p><pre><code>protected abstract Object determineCurrentLookupKey();\n<\/code><\/pre><p>这样看来，这个方法的实现就得由我们完成了。接下来我们将会完成一系列相关的代码，解决这个问题。<\/p><h3>问题修正<\/h3><p>首先，我们创建一个 MyDataSource 类，继承了 AbstractRoutingDataSource，并覆写了 determineCurrentLookupKey()：<\/p><pre><code>public class MyDataSource extends AbstractRoutingDataSource {\n    private static final ThreadLocal&lt;String&gt; key = new ThreadLocal&lt;String&gt;();\n\n    @Override\n    protected Object determineCurrentLookupKey() {\n        return key.get();\n    }\n\n    public static void setDataSource(String dataSource) {\n        key.set(dataSource);\n    }\n\n    public static String getDatasource() {\n        return key.get();\n    }\n\n    public static void clearDataSource() {\n        key.remove();\n    }\n}\n\n<\/code><\/pre><p>其次，我们需要修改 JdbcConfig。这里我新写了一个 dataSource，将原来的 dataSource 改成 dataSourceCore，再将新定义的 dataSourceCore 和 dataSourceCard 放进一个 Map，对应的 key 分别是 core 和 card，并把 Map 赋值给 setTargetDataSources<\/p><pre><code>public class JdbcConfig {\n    \/\/省略非关键代码\n    @Value(&quot;${card.driver}&quot;)\n    private String cardDriver;\n\n    @Value(&quot;${card.url}&quot;)\n    private String cardUrl;\n\n    @Value(&quot;${card.username}&quot;)\n    private String cardUsername;\n\n    @Value(&quot;${card.password}&quot;)\n    private String cardPassword;\n\n    @Autowired\n    @Qualifier(&quot;dataSourceCard&quot;)\n    private DataSource dataSourceCard;\n\n    @Autowired\n    @Qualifier(&quot;dataSourceCore&quot;)\n    private DataSource dataSourceCore;\n\n    \/\/省略非关键代码\n\n    @Bean(name = &quot;dataSourceCore&quot;)\n    public DataSource createCoreDataSource() {\n        DriverManagerDataSource ds = new DriverManagerDataSource();\n        ds.setDriverClassName(driver);\n        ds.setUrl(url);\n        ds.setUsername(username);\n        ds.setPassword(password);\n        return ds;\n    }\n\n    @Bean(name = &quot;dataSourceCard&quot;)\n    public DataSource createCardDataSource() {\n        DriverManagerDataSource ds = new DriverManagerDataSource();\n        ds.setDriverClassName(cardDriver);\n        ds.setUrl(cardUrl);\n        ds.setUsername(cardUsername);\n        ds.setPassword(cardPassword);\n        return ds;\n    }\n\n    @Bean(name = &quot;dataSource&quot;)\n    public MyDataSource createDataSource() {\n        MyDataSource myDataSource = new MyDataSource();\n        Map&lt;Object, Object&gt; map = new HashMap&lt;&gt;();\n        map.put(&quot;core&quot;, dataSourceCore);\n        map.put(&quot;card&quot;, dataSourceCard);\n        myDataSource.setTargetDataSources(map);\n        myDataSource.setDefaultTargetDataSource(dataSourceCore);\n        return myDataSource;\n    }\n\n    \/\/省略非关键代码\n}\n<\/code><\/pre><p>最后还剩下一个问题，setDataSource 这个方法什么时候执行呢？<\/p><p>我们可以用 Spring AOP 来设置，把配置的数据源类型都设置成注解标签， Service层中在切换数据源的方法上加上注解标签，就会调用相应的方法切换数据源。<\/p><p>我们定义了一个新的注解 @DataSource，可以直接加在 Service()上，实现数据库切换：<\/p><pre><code>@Documented\n@Target({ElementType.TYPE, ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface DataSource {\n    String value();\n\n    String core = &quot;core&quot;;\n\n    String card = &quot;card&quot;;\n}\n<\/code><\/pre><p>声明方法如下：<\/p><pre><code>@DataSource(DataSource.card)\n<\/code><\/pre><p>另外，我们还需要写一个 Spring AOP 来对相应的服务方法进行拦截，完成数据源的切换操作。特别要注意的是，这里要加上一个 @Order(1) 标记它的初始化顺序。这个 Order 值一定要比事务的 AOP 切面的值小，这样可以获得更高的优先级，否则自动切换数据源将会失效。<\/p><pre><code>@Aspect\n@Service\n@Order(1)\npublic class DataSourceSwitch {\n    @Around(&quot;execution(* com.spring.puzzle.others.transaction.example3.CardService.*(..))&quot;)\n    public void around(ProceedingJoinPoint point) throws Throwable {\n        Signature signature = point.getSignature();\n        MethodSignature methodSignature = (MethodSignature) signature;\n        Method method = methodSignature.getMethod();\n        if (method.isAnnotationPresent(DataSource.class)) {\n            DataSource dataSource = method.getAnnotation(DataSource.class);\n            MyDataSource.setDataSource(dataSource.value());\n            System.out.println(&quot;数据源切换至：&quot; + MyDataSource.getDatasource());\n        }\n        point.proceed();\n        MyDataSource.clearDataSource();\n        System.out.println(&quot;数据源已移除！&quot;);\n    }\n}\n<\/code><\/pre><p>最后，我们实现了 Card 的发卡逻辑，在方法前声明了切换数据库：<\/p><pre><code>@Service\npublic class CardService {\n    @Autowired\n    private CardMapper cardMapper;\n\n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    @DataSource(DataSource.card)\n    public void createCard(int studentId) throws Exception {\n        Card card = new Card();\n        card.setStudentId(studentId);\n        card.setBalance(50);\n        cardMapper.saveCard(card);\n    }\n}\n<\/code><\/pre><p>并在 saveStudent() 里调用了发卡逻辑：<\/p><pre><code>@Transactional(rollbackFor = Exception.class)\npublic void saveStudent(String realname) throws Exception {\n    Student student = new Student();\n    student.setRealname(realname);\n    studentService.doSaveStudent(student);\n    try {\n        courseService.regCourse(student.getId());\n        cardService.createCard(student.getId());\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n<\/code><\/pre><p>执行一下，一切正常，两个库的数据都可以正常保存了。<\/p><p>最后我们来看一下整个过程的调用栈，重新过一遍流程（这里我略去了不重要的部分）。<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/5d\/bc\/5d1801904d9472b54e7e049ff17220bc.png?wh=1124*252\" alt=\"\"><\/p><p>在创建了事务以后，会通过 DataSourceTransactionManager.doBegin()获取相应的数据库连接：<\/p><pre><code>protected void doBegin(Object transaction, TransactionDefinition definition) {\n   DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;\n   Connection con = null;\n\n   try {\n      if (!txObject.hasConnectionHolder() ||\ntxObject.getConnectionHolder().isSynchronizedWithTransaction()) {\n         Connection newCon = obtainDataSource().getConnection();\n         txObject.setConnectionHolder(new ConnectionHolder(newCon), true);\n      }\n\n      \/\/省略非关键代码\n}\n<\/code><\/pre><p>这里的 obtainDataSource().getConnection() 调用到了 AbstractRoutingDataSource.getConnection()，这就与我们实现的功能顺利会师了。<\/p><pre><code>public Connection getConnection() throws SQLException {\n   return determineTargetDataSource().getConnection();\n}\n<\/code><\/pre><h2>重点回顾<\/h2><p>通过以上两个案例，相信你对 Spring 的事务机制已经有了深刻的认识，最后总结下重点：<\/p><ul>\n<li>Spring 在事务处理中有一个很重要的属性 Propagation，主要用来配置当前需要执行的方法如何使用事务，以及与其它事务之间的关系。<\/li>\n<li>Spring 默认的传播属性是 REQUIRED，在有事务状态下执行，如果当前没有事务，则创建新的事务；<\/li>\n<li>Spring 事务是可以对多个数据源生效，它提供了一个抽象类 AbstractRoutingDataSource，通过实现这个抽象类，我们可以实现自定义的数据库切换。<\/li>\n<\/ul><h2>思考题<\/h2><p>结合案例2，请你思考这样一个问题：在这个案例中，我们在 CardService类方法上声明了这样的事务传播属性，@Transactional(propagation = Propagation.REQUIRES_NEW)，如果使用 Spring 的默认声明行不行，为什么？<\/p><p>期待你的思考，我们留言区见！<\/p>","footer_cover_data":{"img_url":"","mp_url":"","link_url":""},"article_cover_hidden":false,"column_is_experience":false,"is_required":true,"rate":{},"product_id":100077001,"like_count":28,"had_liked":false,"article_subtitle":"无","audio_download_url":"https:\/\/static001.geekbang.org\/resource\/audio\/99\/f2\/99f86639d1b9f4a664f86fbeb13a54f2.mp3","id":382150,"had_viewed":false,"article_title":"20 | Spring 事务常见错误（下）","column_bgcolor":"#F6F7FB","share":{"content":"Spring 开发老兵 10 年避坑心法","title":"傅健 · Spring编程常见错误50例","poster":"https:\/\/static001.geekbang.org\/resource\/image\/81\/cf\/81d9cef44e90ff4890d04b735fd135cf.jpg","cover":"https:\/\/static001.geekbang.org\/resource\/image\/82\/a2\/829d02f2fc0e10860d7b5401f2160ba2.jpg"},"is_video_preview":false,"article_summary":"深入了解 Spring 事务的核心机制。","article_poster_wxlite":"https:\/\/static001.geekbang.org\/render\/screen\/d8\/0d\/d8d1d4aeac4548fd9c5eb5d6e798b60d.jpeg","column_sale_type":2,"article_features":0,"article_could_preview":false,"column_cover":"https:\/\/static001.geekbang.org\/resource\/image\/82\/a2\/829d02f2fc0e10860d7b5401f2160ba2.jpg","column_id":408,"audio_time_arr":{"m":"15","s":"24","h":"00"},"video_time":"","audio_title":"傅健-20","audio_md5":"99f86639d1b9f4a664f86fbeb13a54f2","video_size":0,"text_read_percent":0,"comment_count":8,"cid":408,"article_sharetitle":"Spring 事务常见错误（下）","column_is_onboard":true,"article_cshort":"<p>你好，我是傅健。<\/p><p>通过上一节课的学习，我们了解了 Spring 事务的原理，并解决了几个常见的问题。这节课我们将继续讨论事务中的另外两个问题，一个是关于事务的传播机制，另一个是关于多数据源的切换问题，通过这两个问题，你可以更加深入地了解 Spring 事务的核心机制。<\/p><h2>案例 1：嵌套事务回滚错误<\/h2><p>上一节课我们完成了学生注册功能，假设我们需要对这个功能继续进行扩展，当学生注册完成后，需要给这个学生登记一门英语必修课，并更新这门课的登记学生数。为此，我添加了两个表。<\/p><ol>\n<li>课程表 course，记录课程名称和注册的学生数。<\/li>\n<\/ol><pre><code>CREATE TABLE `course` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `course_name` varchar(64) DEFAULT NULL,\n  `number` int(11) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n<\/code><\/pre><ol start=\"2\">\n<li>学生选课表 student_course，记录学生表 student 和课程表 course 之间的多对多关联。<\/li>\n<\/ol><pre><code>CREATE TABLE `student_course` (\n  `student_id` int(11) NOT NULL,\n  `course_id` int(11) NOT NULL\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n<\/code><\/pre><p>同时我为课程表初始化了一条课程信息，id = 1，course_name = \"英语\"，number = 0。<\/p><p>接下来我们完成用户的相关操作，主要包括两部分。<\/p><ol>\n<li>新增学生选课记录<\/li>\n<\/ol><pre><code>@Mapper\npublic interface StudentCourseMapper {\n    @Insert(&quot;INSERT INTO `student_course`(`student_id`, `course_id`) VALUES (#{studentId}, #{courseId})&quot;)\n    void saveStudentCourse(@Param(&quot;studentId&quot;) Integer studentId, @Param(&quot;courseId&quot;) Integer courseId);\n}\n<\/code><\/pre><ol start=\"2\">\n<li>课程登记学生数 + 1<\/li>\n<\/ol><pre><code>@Mapper\npublic interface CourseMapper {\n    @Update(&quot;update `course` set number = number + 1 where id = #{id}&quot;)\n    void addCourseNumber(int courseId);\n}\n<\/code><\/pre><p>我们增加了一个新的业务类 CourseService，用于实现相关业务逻辑。分别调用了上述两个方法来保存学生与课程的关联关系，并给课程注册人数+1。最后，别忘了给这个方法加上事务注解。<\/p>","video_width":0,"column_could_sub":true,"article_ctime":1622995200,"score":"41622995200","video_media_map":{},"video_preview":{},"video":0,"video_time_arr":{"m":"","s":"","h":""},"video_total_seconds":0},"extra":{},"error":{}}