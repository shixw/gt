{"code":0,"data":{"video_id":"","sku":"100077001","video_cover":"","author_name":"傅健","text_read_version":0,"audio_size":16529647,"article_cover":"https:\/\/static001.geekbang.org\/resource\/image\/8a\/28\/8aabdbacf6534db3df8543b86f62f328.jpg","subtitles":{},"product_type":"c1","audio_url":"https:\/\/res001.geekbang.org\/media\/audio\/29\/83\/298ec04b83a2e5d9d0306a7a0c224483\/ld\/ld.m3u8","chapter_id":"0","column_had_sub":true,"audio_dubber":"傅健","is_finished":false,"inline_video_subtitles":{},"like":{"had_done":false,"count":4},"neighbors":{"left":{"id":369989,"article_title":"06｜Spring AOP 常见错误（下）"},"right":{"id":371184,"article_title":"08｜答疑现场：Spring Core 篇思考题合集"}},"audio_time":"00:17:15","video_height":0,"rate_percent":0,"article_content":"<p>你好，我是傅健，这节课我们聊聊Spring事件上的常见错误。<\/p><p>前面的几讲中，我们介绍了Spring依赖注入、AOP等核心功能点上的常见错误。而作为Spring 的关键功能支撑，Spring事件是一个相对独立的点。或许你从没有在自己的项目中使用过Spring事件，但是你一定见过它的相关日志。而且在未来的编程实践中，你会发现，一旦你用上了Spring事件，往往完成的都是一些有趣的、强大的功能，例如动态配置。那么接下来我就来讲讲Spring事件上都有哪些常见的错误。<\/p><h2>案例1：试图处理并不会抛出的事件<\/h2><p>Spring事件的设计比较简单。说白了，就是监听器设计模式在Spring中的一种实现，参考下图：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/34\/c6\/349f79e396276ab3744c04b0a29eccc6.jpg?wh=3634*2283\" alt=\"\"><\/p><p>从图中我们可以看出，Spring事件包含以下三大组件。<\/p><ol>\n<li>事件（Event）：用来区分和定义不同的事件，在Spring中，常见的如ApplicationEvent和AutoConfigurationImportEvent，它们都继承于java.util.EventObject。<\/li>\n<li>事件广播器（Multicaster）：负责发布上述定义的事件。例如，负责发布ApplicationEvent 的ApplicationEventMulticaster就是Spring中一种常见的广播器。<\/li>\n<li>事件监听器（Listener）：负责监听和处理广播器发出的事件，例如ApplicationListener就是用来处理ApplicationEventMulticaster发布的ApplicationEvent，它继承于JDK的 EventListener，我们可以看下它的定义来验证这个结论：<\/li>\n<\/ol><!-- [[[read_end]]] --><blockquote>\n<p>public interface ApplicationListener&lt;E extends ApplicationEvent&gt; extends EventListener {<br>\nvoid onApplicationEvent(E event);<br>\n}<\/p>\n<\/blockquote><p>当然，虽然在上述组件中，任何一个都是缺一不可的，但是功能模块命名不见得完全贴合上述提及的关键字，例如发布AutoConfigurationImportEvent的广播器就不含有Multicaster字样。它的发布是由AutoConfigurationImportSelector来完成的。<\/p><p>对这些基本概念和实现有了一定的了解后，我们就可以开始解析那些常见的错误。闲话少说，我们先来看下面这段基于Spring Boot技术栈的代码：<\/p><pre><code>@Slf4j\n@Component\npublic class MyContextStartedEventListener implements ApplicationListener&lt;ContextStartedEvent&gt; {\n\n  public void onApplicationEvent(final ContextStartedEvent event) {\n    log.info(&quot;{} received: {}&quot;, this.toString(), event);\n  }\n\n}\n<\/code><\/pre><p>很明显，这段代码定义了一个监听器MyContextStartedEventListener，试图拦截ContextStartedEvent。因为在很多Spring初级开发者眼中，Spring运转的核心就是一个Context的维护，那么启动Spring自然会启动Context，于是他们是很期待出现类似下面的日志的：<\/p><blockquote>\n<p>2021-03-07 07:08:21.197 INFO 2624 --- [nio-8080-exec-1] c.s.p.l.e.MyContextStartedEventListener : com.spring.puzzle.class7.example1.MyContextStartedEventListener@d33d5a <strong>received<\/strong>: org.springframework.context.event.<strong>ContextStartedEvent<\/strong>[source=org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@19b56c0, started on Sun Mar 07 07:07:57 CST 2021]<\/p>\n<\/blockquote><p>但是当我们启动Spring Boot后，会发现并不会拦截到这个事件，如何理解这个错误呢？<\/p><h3>案例解析<\/h3><p>在Spring事件运用上，这是一个常见的错误，就是不假思索地认为一个框架只要定义了一个事件，那么一定会抛出来。例如，在本案例中，ContextStartedEvent就是Spring内置定义的事件，而Spring Boot本身会创建和运维Context，表面看起来这个事件的抛出是必然的，但是这个事件一定会在Spring Boot启动时抛出来么？<\/p><p>答案明显是否定的，我们首先看下要抛出这个事件需要调用的方法是什么？在Spring Boot中，这个事件的抛出只发生在一处，即位于方法AbstractApplicationContext#start中。<\/p><pre><code>@Override\npublic void start() {\n   getLifecycleProcessor().start();\n   publishEvent(new ContextStartedEvent(this));\n}\n<\/code><\/pre><p>也就是说，只有上述方法被调用，才会抛出ContextStartedEvent，但是这个方法在Spring Boot启动时会被调用么？我们可以查看Spring启动方法中围绕Context的关键方法调用，代码如下：<\/p><pre><code>public ConfigurableApplicationContext run(String... args) {\n      \/\/省略非关键代码\n      context = createApplicationContext();\n      \/\/省略非关键代码\n      prepareContext(context, environment, listeners, applicationArguments, printedBanner);\n      refreshContext(context);\n      \/\/省略非关键代码 \n      return context;\n}\n<\/code><\/pre><p>我们发现围绕Context、Spring Boot的启动只做了两个关键工作：创建Context和Refresh  Context。其中Refresh的关键代码如下：<\/p><pre><code>protected void refresh(ApplicationContext applicationContext) {\n   Assert.isInstanceOf(AbstractApplicationContext.class, applicationContext);\n   ((AbstractApplicationContext) applicationContext).refresh();\n}\n<\/code><\/pre><p>很明显，Spring启动最终调用的是AbstractApplicationContext#refresh，并不是 AbstractApplicationContext#start。在这样的残酷现实下，ContextStartedEvent自然不会被抛出，不抛出，自然也不可能被捕获。所以这样的错误也就自然发生了。<\/p><h3>问题修正<\/h3><p>针对这个案例，有了源码的剖析，我们可以很快找到问题发生的原因，但是修正这个问题还要去追溯我们到底想要的是什么？我们可以分两种情况来考虑。<\/p><p><strong>1.  假设我们是误读了ContextStartedEvent。<\/strong><\/p><p>针对这种情况，往往是因为我们确实想在Spring Boot启动时拦截一个启动事件，但是我们粗略扫视相关事件后，误以为ContextStartedEvent就是我们想要的。针对这种情况，我们只需要把监听事件的类型修改成真正发生的事件即可，例如在本案例中，我们可以修正如下：<\/p><pre><code>@Component\npublic class MyContextRefreshedEventListener implements ApplicationListener&lt;ContextRefreshedEvent&gt; {\n\n  public void onApplicationEvent(final ContextRefreshedEvent event) {\n    log.info(&quot;{} received: {}&quot;, this.toString(), event);\n  }\n\n}\n<\/code><\/pre><p>我们监听ContextRefreshedEvent而非ContextStartedEvent。ContextRefreshedEvent的抛出可以参考方法AbstractApplicationContext#finishRefresh，它本身正好是Refresh操作中的一步。<\/p><pre><code>protected void finishRefresh() {\n   \/\/省略非关键代码\n   initLifecycleProcessor();\n   \/\/ Propagate refresh to lifecycle processor first.\n   getLifecycleProcessor().onRefresh();\n   \/\/ Publish the final event.\n   publishEvent(new ContextRefreshedEvent(this));\n   \/\/省略非关键代码\n}\n<\/code><\/pre><p><strong>2.  假设我们就是想要处理ContextStartedEvent。<\/strong><\/p><p>这种情况下，我们真的需要去调用AbstractApplicationContext#start方法。例如，我们可以使用下面的代码来让这个事件抛出：<\/p><pre><code>@RestController\npublic class HelloWorldController {\n\n    @Autowired\n    private AbstractApplicationContext applicationContext;\n\n    @RequestMapping(path = &quot;publishEvent&quot;, method = RequestMethod.GET)\n    public String notifyEvent(){\n        applicationContext.start();       \n        return &quot;ok&quot;;\n    };\n}\n<\/code><\/pre><p>我们随便找一处来Autowired一个AbstractApplicationContext，然后直接调用其start()就能让事件抛出来。<\/p><p>很明显，这种抛出并不难，但是作为题外话，我们可以思考下为什么要去调用start()呢？start()本身在Spring Boot中有何作用？<\/p><p>如果我们去翻阅这个方法，我们会发现start()是org.springframework.context.Lifecycle定义的方法，而它在Spring Boot的默认实现中是去执行所有Lifecycle Bean的启动方法，这点可以参考DefaultLifecycleProcessor#startBeans方法来验证：<\/p><pre><code>private void startBeans(boolean autoStartupOnly) {\n   Map&lt;String, Lifecycle&gt; lifecycleBeans = getLifecycleBeans();\n   Map&lt;Integer, LifecycleGroup&gt; phases = new HashMap&lt;&gt;();\n   lifecycleBeans.forEach((beanName, bean) -&gt; {\n      if (!autoStartupOnly || (bean instanceof SmartLifecycle &amp;&amp; ((SmartLifecycle) bean).isAutoStartup())) {\n         int phase = getPhase(bean);\n         LifecycleGroup group = phases.get(phase);\n         if (group == null) {\n            group = new LifecycleGroup(phase, this.timeoutPerShutdownPhase, lifecycleBeans, autoStartupOnly);\n            phases.put(phase, group);\n         }\n         group.add(beanName, bean);\n      }\n   });\n   if (!phases.isEmpty()) {\n      List&lt;Integer&gt; keys = new ArrayList&lt;&gt;(phases.keySet());\n      Collections.sort(keys);\n      for (Integer key : keys) {\n         phases.get(key).start();\n      }\n   }\n}\n<\/code><\/pre><p>说起来比较抽象，我们可以去写一个Lifecycle Bean，代码如下：<\/p><pre><code>@Component\n@Slf4j\npublic class MyLifeCycle implements Lifecycle {\n\n    private volatile boolean running = false;\n\n    @Override\n    public void start() {\n       log.info(&quot;lifecycle start&quot;);\n       running = true;\n    }\n\n    @Override\n    public void stop() {\n       log.info(&quot;lifecycle stop&quot;);\n       running = false;\n    }\n\n    @Override\n    public boolean isRunning() {\n        return running;\n    }\n\n}\n<\/code><\/pre><p>当我们再次运行Spring Boot时，只要执行了AbstractApplicationContext的start()，就会输出上述代码定义的行为：输出LifeCycle start日志。<\/p><p>通过这个Lifecycle Bean的使用，AbstractApplicationContext的start要做的事，我们就清楚多了。它和Refresh()不同，Refresh()是初始化和加载所有需要管理的Bean，而start只有在有Lifecycle Bean时才有被调用的价值。那么我们自定义Lifecycle Bean一般是用来做什么呢？例如，可以用它来实现运行中的启停。这里不再拓展，你可以自己做更深入的探索。<\/p><p>通过这个案例，我们搞定了第一类错误。而从这个错误中，我们也得出了一个启示：<strong>当一个事件拦截不了时，我们第一个要查的是拦截的事件类型对不对，执行的代码能不能抛出它。<\/strong>把握好这点，也就事半功倍了。<\/p><h2>案例2：监听事件的体系不对<\/h2><p>通过案例1的学习，我们可以保证事件的抛出，但是抛出的事件就一定能被我们监听到么？我们再来看这样一个案例，首先上代码：<\/p><pre><code>@Slf4j\n@Component\npublic class MyApplicationEnvironmentPreparedEventListener implements ApplicationListener&lt;ApplicationEnvironmentPreparedEvent &gt; {\n\n    public void onApplicationEvent(final ApplicationEnvironmentPreparedEvent event) {\n        log.info(&quot;{} received: {}&quot;, this.toString(), event);\n    }\n\n}\n<\/code><\/pre><p>这里我们试图处理ApplicationEnvironmentPreparedEvent。期待出现拦截事件的日志如下：<\/p><blockquote>\n<p>2021-03-07 09:12:08.886 INFO 27064 --- [ restartedMain] licationEnvironmentPreparedEventListener : com.spring.puzzle.class7.example2.MyApplicationEnvironmentPreparedEventListener@2b093d received: org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent[source=org.springframework.boot.SpringApplication@122b9e6]<\/p>\n<\/blockquote><p>有了案例1的经验，首先我们就可以查看下这个事件的抛出会不会存在问题。这个事件在Spring中是由EventPublishingRunListener#environmentPrepared方法抛出，代码如下：<\/p><pre><code>@Override\npublic void environmentPrepared(ConfigurableEnvironment environment) {\n   this.initialMulticaster\n         .multicastEvent(new ApplicationEnvironmentPreparedEvent(this.application, this.args, environment));\n}\n<\/code><\/pre><p>现在我们调试下代码，你会发现这个方法在Spring启动时一定经由SpringApplication#prepareEnvironment方法调用，调试截图如下：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/f6\/fe\/f6e5b92bd2db8a3db93f53ff2a7944fe.png?wh=1005*251\" alt=\"\"><\/p><p>表面上看，既然代码会被调用，事件就会抛出，那么我们在最开始定义的监听器就能处理，但是我们真正去运行程序时会发现，效果和案例1是一样的，都是监听器的处理并不执行，即拦截不了。这又是为何？<\/p><h3>案例解析<\/h3><p>实际上，这是在Spring事件处理上非常容易犯的一个错误，即监听的体系不一致。通俗点说，就是“驴头不对马嘴”。我们首先来看下关于ApplicationEnvironmentPreparedEvent的处理，它相关的两大组件是什么？<\/p><ol>\n<li>广播器：这个事件的广播器是EventPublishingRunListener的initialMulticaster，代码参考如下：<\/li>\n<\/ol><pre><code>public class EventPublishingRunListener implements SpringApplicationRunListener, Ordered {\n   \/\/省略非关键代码\n   private final SimpleApplicationEventMulticaster initialMulticaster;\n\n   public EventPublishingRunListener(SpringApplication application, String[] args) {\n      \/\/省略非关键代码\n      this.initialMulticaster = new SimpleApplicationEventMulticaster();\n      for (ApplicationListener&lt;?&gt; listener : application.getListeners()) {\n         this.initialMulticaster.addApplicationListener(listener);\n      }\n   }\n }\n<\/code><\/pre><ol start=\"2\">\n<li>监听器：这个事件的监听器同样位于EventPublishingRunListener中，获取方式参考关键代码行：<\/li>\n<\/ol><blockquote>\n<p>this.initialMulticaster.addApplicationListener(listener);<\/p>\n<\/blockquote><p>如果继续查看代码，我们会发现这个事件的监听器就存储在SpringApplication#Listeners中，调试下就可以找出所有的监听器，截图如下：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/14\/6b\/145f6d0a20a6f82fa8f6f08c7a08666b.png?wh=677*379\" alt=\"\"><\/p><p>从中我们可以发现并不存在我们定义的MyApplicationEnvironmentPreparedEventListener，这是为何？<\/p><p>还是查看代码，当Spring Boot被构建时，会使用下面的方法去寻找上述监听器：<\/p><blockquote>\n<p>setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));<\/p>\n<\/blockquote><p>而上述代码最终寻找Listeners的候选者，参考代码 SpringFactoriesLoader#loadSpringFactories中的关键行：<\/p><blockquote>\n<p>\/\/下面的FACTORIES_RESOURCE_LOCATION定义为 \"META-INF\/spring.factories\"<br>\nclassLoader.getResources(FACTORIES_RESOURCE_LOCATION) :<\/p>\n<\/blockquote><p>我们可以寻找下这样的文件（spring.factories），确实可以发现类似的定义：<\/p><pre><code>org.springframework.context.ApplicationListener=\\\norg.springframework.boot.ClearCachesApplicationListener,\\\norg.springframework.boot.builder.ParentContextCloserApplicationListener,\\\norg.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor,\\\n\/\/省略其他监听器 \n<\/code><\/pre><p>说到这里，相信你已经意识到本案例的问题所在。我们定义的监听器并没有被放置在META-INF\/spring.factories中，实际上，我们的监听器监听的体系是另外一套，其关键组件如下：<\/p><ol>\n<li>广播器：即AbstractApplicationContext#applicationEventMulticaster；<\/li>\n<li>监听器：由上述提及的META-INF\/spring.factories中加载的监听器以及扫描到的 ApplicationListener类型的Bean共同组成。<\/li>\n<\/ol><p>这样比较后，我们可以得出一个结论：<strong>我们定义的监听器并不能监听到initialMulticaster广播出的ApplicationEnvironmentPreparedEvent。<\/strong><\/p><h3>问题修正<\/h3><p>现在就到了解决问题的时候了，我们可以把自定义监听器注册到initialMulticaster广播体系中，这里提供两种方法修正问题。<\/p><ol>\n<li>在构建Spring Boot时，添加MyApplicationEnvironmentPreparedEventListener：<\/li>\n<\/ol><pre><code>@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        MyApplicationEnvironmentPreparedEventListener myApplicationEnvironmentPreparedEventListener = new MyApplicationEnvironmentPreparedEventListener();\n        SpringApplication springApplication = new SpringApplicationBuilder(Application.class).listeners(myApplicationEnvironmentPreparedEventListener).build();\n        springApplication.run(args);\n    }\n}\n<\/code><\/pre><ol start=\"2\">\n<li>使用META-INF\/spring.factories，即在\/src\/main\/resources下面新建目录META-INF，然后新建一个对应的spring.factories文件：<\/li>\n<\/ol><pre><code>org.springframework.context.ApplicationListener=\\\ncom.spring.puzzle.listener.example2.MyApplicationEnvironmentPreparedEventListener\n<\/code><\/pre><p>通过上述两种修改方式，即可完成事件的监听，很明显第二种方式要优于第一种，至少完全用原生的方式去解决，而不是手工实例化一个MyApplicationEnvironmentPreparedEventListener。这点还是挺重要的。<\/p><p>反思这个案例的错误，结论就是<strong>对于事件一定要注意“驴头”（监听器）对上“马嘴”（广播）<\/strong>。<\/p><h2>案例3：部分事件监听器失效<\/h2><p>通过前面案例的解析，我们可以确保事件在合适的时机被合适的监听器所捕获。但是理想总是与现实有差距，有些时候，我们可能还会发现部分事件监听器一直失效或偶尔失效。这里我们可以写一段代码来模拟偶尔失效的场景，首先我们完成一个自定义事件和两个监听器，代码如下：<\/p><pre><code>public class MyEvent extends ApplicationEvent {\n    public MyEvent(Object source) {\n        super(source);\n    }\n}\n\n@Component\n@Order(1)\npublic class MyFirstEventListener implements ApplicationListener&lt;MyEvent&gt; {\n\n    Random random = new Random();\n\n    @Override\n    public void onApplicationEvent(MyEvent event) {\n        log.info(&quot;{} received: {}&quot;, this.toString(), event);\n        \/\/模拟部分失效\n        if(random.nextInt(10) % 2 == 1)\n            throw new RuntimeException(&quot;exception happen on first listener&quot;);\n    }\n}\n\n@Component\n@Order(2)\npublic class MySecondEventListener implements ApplicationListener&lt;MyEvent&gt; {\n    @Override\n    public void onApplicationEvent(MyEvent event) {\n        log.info(&quot;{} received: {}&quot;, this.toString(), event);\n    }\n}\n\n<\/code><\/pre><p>这里监听器MyFirstEventListener的优先级稍高，且执行过程中会有50%的概率抛出异常。然后我们再写一个Controller来触发事件的发送：<\/p><pre><code>@RestController\n@Slf4j\npublic class HelloWorldController {\n\n    @Autowired\n    private AbstractApplicationContext applicationContext;\n\n    @RequestMapping(path = &quot;publishEvent&quot;, method = RequestMethod.GET)\n    public String notifyEvent(){\n        log.info(&quot;start to publish event&quot;);\n        applicationContext.publishEvent(new MyEvent(UUID.randomUUID()));\n        return &quot;ok&quot;;\n    };\n}\n<\/code><\/pre><p>完成这些代码后，我们就可以使用<a href=\"http:\/\/localhost:8080\/publishEvent\">http:\/\/localhost:8080\/publishEvent<\/a> 来测试监听器的接收和执行了。观察测试结果，我们会发现监听器MySecondEventListener有一半的概率并没有接收到任何事件。可以说，我们使用了最简化的代码模拟出了部分事件监听器偶尔失效的情况。当然在实际项目中，抛出异常这个根本原因肯定不会如此明显，但还是可以借机举一反三的。那么如何理解这个问题呢？<\/p><h3>案例解析<\/h3><p>这个案例非常简易，如果你稍微有些开发经验的话，大概也能推断出原因：处理器的执行是顺序执行的，在执行过程中，如果一个监听器执行抛出了异常，则后续监听器就得不到被执行的机会了。这里我们可以通过Spring源码看下事件是如何被执行的？<\/p><p>具体而言，当广播一个事件，执行的方法参考 SimpleApplicationEventMulticaster#multicastEvent(ApplicationEvent)：<\/p><pre><code>@Override\npublic void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) {\n   ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));\n   Executor executor = getTaskExecutor();\n   for (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) {\n      if (executor != null) {\n         executor.execute(() -&gt; invokeListener(listener, event));\n      }\n      else {\n         invokeListener(listener, event);\n      }\n   }\n}\n<\/code><\/pre><p>上述方法通过Event类型等信息调用getApplicationListeners获取了具有执行资格的所有监听器（在本案例中，即为MyFirstEventListener和MySecondEventListener），然后按顺序去执行。最终每个监听器的执行是通过invokeListener()来触发的，调用的是接口方法 ApplicationListener#onApplicationEvent。执行逻辑可参考如下代码：<\/p><pre><code>protected void invokeListener(ApplicationListener&lt;?&gt; listener, ApplicationEvent event) {\n   ErrorHandler errorHandler = getErrorHandler();\n   if (errorHandler != null) {\n      try {\n         doInvokeListener(listener, event);\n      }\n      catch (Throwable err) {\n         errorHandler.handleError(err);\n      }\n   }\n   else {\n      doInvokeListener(listener, event);\n   }\n}\n\nprivate void doInvokeListener(ApplicationListener listener, ApplicationEvent event) {\n   try {\n      listener.onApplicationEvent(event);\n   }\n   catch (ClassCastException ex) {\n        \/\/省略非关键代码\n      }\n      else {\n         throw ex;\n      }\n   }\n}\n<\/code><\/pre><p>这里我们并没有去设置什么org.springframework.util.ErrorHandler，也没有绑定什么Executor 来执行任务，所以针对本案例的情况，我们可以看出：<strong>最终事件的执行是由同一个线程按顺序来完成的，任何一个报错，都会导致后续的监听器执行不了。<\/strong><\/p><h3>问题修正<\/h3><p>怎么解决呢？好办，我提供两种方案给你。<\/p><p><strong>1.  确保监听器的执行不会抛出异常。<\/strong><\/p><p>既然我们使用多个监听器，我们肯定是希望它们都能执行的，所以我们一定要保证每个监听器的执行不会被其他监听器影响。基于这个思路，我们修改案例代码如下：<\/p><pre><code>@Component\n@Order(1)\npublic class MyFirstEventListener implements ApplicationListener&lt;MyEvent&gt; {\n    @Override\n    public void onApplicationEvent(MyEvent event) {\n        try {\n          \/\/ 省略事件处理相关代码\n        }catch(Throwable throwable){\n            \/\/write error\/metric to alert\n        }\n\n    }\n}\n<\/code><\/pre><p><strong>2.  使用org.springframework.util.ErrorHandler。<\/strong><\/p><p>通过上面的案例解析，我们发现，假设我们设置了一个ErrorHandler，那么就可以用这个ErrorHandler去处理掉异常，从而保证后续事件监听器处理不受影响。我们可以使用下面的代码来修正问题：<\/p><pre><code>SimpleApplicationEventMulticaster simpleApplicationEventMulticaster = applicationContext.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, SimpleApplicationEventMulticaster.class);\n    simpleApplicationEventMulticaster.setErrorHandler(TaskUtils.LOG_AND_SUPPRESS_ERROR_HANDLER);\n<\/code><\/pre><p>其中LOG_AND_SUPPRESS_ERROR_HANDLER的实现如下：<\/p><pre><code>public static final ErrorHandler LOG_AND_SUPPRESS_ERROR_HANDLER = new LoggingErrorHandler();\n\nprivate static class LoggingErrorHandler implements ErrorHandler {\n\n   private final Log logger = LogFactory.getLog(LoggingErrorHandler.class);\n\n   @Override\n   public void handleError(Throwable t) {\n      logger.error(&quot;Unexpected error occurred in scheduled task&quot;, t);\n   }\n}\n<\/code><\/pre><p>对比下方案1，使用ErrorHandler有一个很大的优势，就是我们不需要在某个监听器中都重复类似下面的代码了：<\/p><pre><code>try {\n    \/\/省略事件处理过程\n    }catch(Throwable throwable){\n    \/\/write error\/metric to alert\n}\n<\/code><\/pre><p>这么看的话，其实Spring的设计还是很全面的，它考虑了各种各样的情况。但是Spring使用者往往都不会去了解其内部实现，这样就会遇到各种各样的问题。相反，如果你对其实现有所了解的话，也对常见错误有一个感知，则大概率是可以快速避坑的，项目也可以运行得更加平稳顺畅。<\/p><h2>重点回顾<\/h2><p>今天我们粗略地了解了Spring事件处理的基本流程。其实，抛开Spring框架，我们去设计一个通用的事件处理框架，常常也会犯这三种错误：<\/p><ol>\n<li>误读事件本身含义；<\/li>\n<li>监听错了事件的传播系统；<\/li>\n<li>事件处理之间互相影响，导致部分事件处理无法完成。<\/li>\n<\/ol><p>这三种错误正好对应了我们这节课讲解的三个案例。<\/p><p>此外，在Spring事件处理过程中，我们也学习到了监听器加载的特殊方式，即使用SPI的方式直接从配置文件META-INF\/spring.factories中加载。这种方式或者说思想非常值得你去学习，因为它在许多Java应用框架中都有所使用，例如Dubbo，就是使用增强版的SPI来配置编解码器的。<\/p><h2>思考题<\/h2><p>在案例3中，我们提到默认的事件执行是在同一个线程中执行的，即事件发布者使用的线程。参考如下日志佐证这个结论：<\/p><blockquote>\n<p>2021-03-09 09:10:33.052 INFO 18104 --- [nio-8080-exec-1] c.s.p.listener.HelloWorldController : start to publish event<br>\n2021-03-09 09:10:33.055 INFO 18104 --- [nio-8080-exec-1] c.s.p.l.example3.MyFirstEventListener : com.spring.puzzle.class7.example3.MyFirstEventListener@18faf0 received: com.spring.puzzle.class7.example3.MyEvent[source=df42b08f-8ee2-44df-a957-d8464ff50c88]<\/p>\n<\/blockquote><p>通过日志可以看出，事件的发布和执行使用的都是nio-8080-exec-1线程，但是在事件比较多时，我们往往希望事件执行得更快些，或者希望事件的执行可以异步化不影响主线程。此时应该怎么做呢？<\/p><p>期待在留言区看到你的回复，我们下节课见！<\/p>","footer_cover_data":{"img_url":"","mp_url":"","link_url":""},"article_cover_hidden":false,"column_is_experience":false,"is_required":true,"rate":{},"product_id":100077001,"like_count":12,"had_liked":false,"article_subtitle":"无","audio_download_url":"https:\/\/static001.geekbang.org\/resource\/audio\/29\/83\/298ec04b83a2e5d9d0306a7a0c224483.mp3","id":370741,"had_viewed":false,"article_title":"07｜Spring事件常见错误","column_bgcolor":"#F6F7FB","share":{"content":"Spring 开发老兵 10 年避坑心法","title":"傅健 · Spring编程常见错误50例","poster":"https:\/\/static001.geekbang.org\/resource\/image\/81\/cf\/81d9cef44e90ff4890d04b735fd135cf.jpg","cover":"https:\/\/static001.geekbang.org\/resource\/image\/82\/a2\/829d02f2fc0e10860d7b5401f2160ba2.jpg"},"is_video_preview":false,"article_summary":"解析 Spring 事件处理的基本流程。","article_poster_wxlite":"https:\/\/static001.geekbang.org\/render\/screen\/4f\/0e\/4f2ee2c4c7b15e94fed18fb5e196b20e.jpeg","column_sale_type":2,"article_features":0,"article_could_preview":false,"column_cover":"https:\/\/static001.geekbang.org\/resource\/image\/82\/a2\/829d02f2fc0e10860d7b5401f2160ba2.jpg","column_id":408,"audio_time_arr":{"m":"17","s":"15","h":"00"},"video_time":"","audio_title":"傅健-07","audio_md5":"298ec04b83a2e5d9d0306a7a0c224483","video_size":0,"text_read_percent":0,"comment_count":10,"cid":408,"article_sharetitle":"Spring事件常见错误","column_is_onboard":true,"article_cshort":"<p>你好，我是傅健，这节课我们聊聊Spring事件上的常见错误。<\/p><p>前面的几讲中，我们介绍了Spring依赖注入、AOP等核心功能点上的常见错误。而作为Spring 的关键功能支撑，Spring事件是一个相对独立的点。或许你从没有在自己的项目中使用过Spring事件，但是你一定见过它的相关日志。而且在未来的编程实践中，你会发现，一旦你用上了Spring事件，往往完成的都是一些有趣的、强大的功能，例如动态配置。那么接下来我就来讲讲Spring事件上都有哪些常见的错误。<\/p><h2>案例1：试图处理并不会抛出的事件<\/h2><p>Spring事件的设计比较简单。说白了，就是监听器设计模式在Spring中的一种实现，参考下图：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/34\/c6\/349f79e396276ab3744c04b0a29eccc6.jpg?wh=3634*2283\" alt=\"\"><\/p><p>从图中我们可以看出，Spring事件包含以下三大组件。<\/p><ol>\n<li>事件（Event）：用来区分和定义不同的事件，在Spring中，常见的如ApplicationEvent和AutoConfigurationImportEvent，它们都继承于java.util.EventObject。<\/li>\n<li>事件广播器（Multicaster）：负责发布上述定义的事件。例如，负责发布ApplicationEvent 的ApplicationEventMulticaster就是Spring中一种常见的广播器。<\/li>\n<li>事件监听器（Listener）：负责监听和处理广播器发出的事件，例如ApplicationListener就是用来处理ApplicationEventMulticaster发布的ApplicationEvent，它继承于JDK的 EventListener，我们可以看下它的定义来验证这个结论：<\/li>\n<\/ol>","video_width":0,"column_could_sub":true,"article_ctime":1620144000,"score":"21620144000","video_media_map":{},"video_preview":{},"video":0,"video_time_arr":{"m":"","s":"","h":""},"video_total_seconds":0},"extra":{},"error":{}}