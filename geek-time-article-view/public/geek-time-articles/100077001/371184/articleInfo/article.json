{"code":0,"data":{"video_id":"","sku":"100077001","video_cover":"","author_name":"傅健","text_read_version":0,"audio_size":1613974,"article_cover":"https:\/\/static001.geekbang.org\/resource\/image\/9d\/8f\/9d72ac30bcfe71504946160fdfaeec8f.jpg","subtitles":{},"product_type":"c1","audio_url":"https:\/\/res001.geekbang.org\/media\/audio\/f2\/15\/f285d5312613a58052cf4993bd7a7615\/ld\/ld.m3u8","chapter_id":"0","column_had_sub":true,"audio_dubber":"傅健","is_finished":false,"inline_video_subtitles":{},"like":{"had_done":false,"count":1},"neighbors":{"left":{"id":370741,"article_title":"07｜Spring事件常见错误"},"right":{"id":372003,"article_title":"导读｜5分钟轻松了解一个HTTP请求的处理过程"}},"audio_time":"00:01:41","video_height":0,"rate_percent":0,"article_content":"<p>你好，我是傅健。<\/p><p>如果你看到这篇文章，那么我真的非常开心，这说明第一章节的内容你都跟下来了，并且对于课后的思考题也有研究，在这我要手动给你点个赞。繁忙的工作中，还能为自己持续充电，保持终身学习的心态，我想我们一定是同路人。<\/p><p>那么到今天为止，我们已经学习了 17 个案例，解决的问题也不算少了，不知道你的感受如何？收获如何呢？<\/p><p>我还记得<a href=\"https:\/\/time.geekbang.org\/column\/article\/364661\">开篇词<\/a>的留言区中有位很有趣的同学，他说：“作为一线 bug 制造者，希望能少写点 bug。” 感同身受，和 Spring 斗智斗勇的这些年，我也经常为一些问题而抓狂过，因不能及时解决而焦虑过，但最终还是觉得蛮有趣的，这个专栏也算是沉淀之作，希望能给你带来一些实际的帮助。<\/p><p>最初，我其实是想每节课都和你交流下上节课的思考题，但又担心大家的学习进度不一样，所以就有了这次的集中答疑，我把我的答案给到大家，你也可以对照着去看一看，也许有更好的方法，欢迎你来贡献“选项”，我们一起交流。希望大家都能在问题的解决中获得一些正向反馈，完成学习闭环。<\/p><h2><strong><a href=\"https:\/\/time.geekbang.org\/column\/article\/364761\">第1课<\/a><\/strong><\/h2><p>在案例 2 中，显示定义构造器，这会发生根据构造器参数寻找对应 Bean 的行为。这里请你思考一个问题，假设寻找不到对应的 Bean，一定会如案例 2 那样直接报错么？<\/p><!-- [[[read_end]]] --><p>实际上，答案是否定的。这里我们不妨修改下案例 2 的代码，修改后如下：<\/p><pre><code>@Service\npublic class ServiceImpl {\n    private List&lt;String&gt; serviceNames;\n    public ServiceImpl(List&lt;String&gt; serviceNames){\n        this.serviceNames = serviceNames;\n        System.out.println(this.serviceNames);\n    }\n}\n<\/code><\/pre><p>参考上述代码，我们的构造器参数由普通的String改成了一个List<string>，最终运行程序会发现这并不会报错，而是输出 []。<\/string><\/p><p>要了解这个现象，我们可以直接定位构建构造器调用参数的代码所在地（即 ConstructorResolver#resolveAutowiredArgument）：<\/p><pre><code>@Nullable\nprotected Object resolveAutowiredArgument(MethodParameter param, String beanName,\n      @Nullable Set&lt;String&gt; autowiredBeanNames, TypeConverter typeConverter, boolean fallback) {\n\n   \/\/省略非关键代码\n   try {\n      \/\/根据构造器参数寻找 bean\n      return this.beanFactory.resolveDependency(\n            new DependencyDescriptor(param, true), beanName, autowiredBeanNames, typeConverter);\n   }\n   catch (NoUniqueBeanDefinitionException ex) {\n      throw ex;\n   }\n   catch (NoSuchBeanDefinitionException ex) {\n      \/\/找不到 “bean” 进行fallback\n      if (fallback) {\n         \/\/ Single constructor or factory method -&gt; let's return an empty array\/collection\n         \/\/ for e.g. a vararg or a non-null List\/Set\/Map parameter.\n         if (paramType.isArray()) {\n            return Array.newInstance(paramType.getComponentType(), 0);\n         }\n         else if (CollectionFactory.isApproximableCollectionType(paramType)) {\n            return CollectionFactory.createCollection(paramType, 0);\n         }\n         else if (CollectionFactory.isApproximableMapType(paramType)) {\n            return CollectionFactory.createMap(paramType, 0);\n         }\n      }\n      throw ex;\n   }\n}\n<\/code><\/pre><p>当构建集合类型的参数实例寻找不到合适的 Bean 时，并不是不管不顾地直接报错，而是会尝试进行fallback。对于本案例而言，会使用下面的语句来创建一个空的集合作为构造器参数传递进去：<\/p><blockquote>\n<p>CollectionFactory.createCollection(paramType, 0);<\/p>\n<\/blockquote><p>上述代码最终调用代码如下：<\/p><blockquote>\n<p>return new ArrayList&lt;&gt;(capacity);<\/p>\n<\/blockquote><p>所以很明显，最终修改后的案例并不会报错，而是把 serviceNames 设置为一个空的 List。从这一点也可知，<strong>自动装配远比想象的要复杂<\/strong>。<\/p><h2><strong><a href=\"https:\/\/time.geekbang.org\/column\/article\/366170\">第2课<\/a><\/strong><\/h2><p>我们知道了通过@Qualifier可以引用想匹配的Bean，也可以直接命名属性的名称为Bean的名称来引用，这两种方式如下：<\/p><pre><code>\/\/方式1：属性命名为要装配的bean名称\n@Autowired\nDataService oracleDataService;\n\n\/\/方式2：使用@Qualifier直接引用\n@Autowired\n@Qualifier(&quot;oracleDataService&quot;)\nDataService dataService;\n<\/code><\/pre><p>那么对于案例3的内部类引用，你觉得可以使用第1种方式做到么？例如使用如下代码：<\/p><blockquote>\n<p>@Autowired<br>\nDataService studentController.InnerClassDataService;<\/p>\n<\/blockquote><p>实际上，如果你动动手或者我们稍微敏锐点就会发现，代码本身就不能编译，因为中间含有“.”。那么还有办法能通过这种方式引用到内部类么？<\/p><p>查看决策谁优先的源码，最终使用属性名来匹配的执行情况可参考DefaultListableBeanFactory#matchesBeanName方法的调试视图：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/86\/37\/8658173a310332b1ca532997c4cd5337.png?wh=1532*281\" alt=\"\"><\/p><p>我们可以看到实现的关键其实是下面这行语句：<\/p><blockquote>\n<p>candidateName.equals(beanName) || ObjectUtils.containsElement(getAliases(beanName), candidateName))<\/p>\n<\/blockquote><p>很明显，我们的Bean没有被赋予别名，而鉴于属性名不可能含有“.”，所以它不可能匹配上带“.”的Bean名（即studentController.InnerClassDataService）。<\/p><p>综上，如果一个内部类，没有显式指定名称或者别名，试图使用属性名和Bean名称一致来引用到对应的Bean是行不通的。<\/p><h2><strong><a href=\"https:\/\/time.geekbang.org\/column\/article\/366930\">第3课<\/a><\/strong><\/h2><p>在案例2中，我们初次运行程序获取的结果如下：<\/p><blockquote>\n<p>[Student(id=1, name=xie), Student(id=2, name=fang)]<\/p>\n<\/blockquote><p>那么如何做到让学生2优先输出呢？<\/p><p>实际上，在案例2中，我们收集的目标类型是List，而List是可排序的，那么到底是如何排序的？在案例2的解析中，我们给出了DefaultListableBeanFactory#resolveMultipleBeans方法的代码，不过省略了一些非关键的代码，这其中就包括了排序工作，代码如下：<\/p><pre><code>if (result instanceof List) {\n   Comparator&lt;Object&gt; comparator = adaptDependencyComparator(matchingBeans);\n   if (comparator != null) {\n      ((List&lt;?&gt;) result).sort(comparator);\n   }\n}\n<\/code><\/pre><p>而针对本案例最终排序执行的是OrderComparator#doCompare方法，关键代码如下：<\/p><pre><code>private int doCompare(@Nullable Object o1, @Nullable Object o2, @Nullable OrderSourceProvider sourceProvider) {\n   boolean p1 = (o1 instanceof PriorityOrdered);\n   boolean p2 = (o2 instanceof PriorityOrdered);\n   if (p1 &amp;&amp; !p2) {\n      return -1;\n   }\n   else if (p2 &amp;&amp; !p1) {\n      return 1;\n   }\n\n   int i1 = getOrder(o1, sourceProvider);\n   int i2 = getOrder(o2, sourceProvider);\n   return Integer.compare(i1, i2);\n}\n<\/code><\/pre><p>其中getOrder的执行，获取到的order值（相当于优先级）是通过AnnotationAwareOrderComparator#findOrder来获取的：<\/p><pre><code>protected Integer findOrder(Object obj) {\n   Integer order = super.findOrder(obj);\n   if (order != null) {\n      return order;\n   }\n   return findOrderFromAnnotation(obj);\n}\n<\/code><\/pre><p>不难看出，获取order值包含了2种方式：<\/p><ol>\n<li>从@Order获取值，参考AnnotationAwareOrderComparator#findOrderFromAnnotation：<\/li>\n<\/ol><pre><code>@Nullable\nprivate Integer findOrderFromAnnotation(Object obj) {\n   AnnotatedElement element = (obj instanceof AnnotatedElement ? (AnnotatedElement) obj : obj.getClass());\n   MergedAnnotations annotations = MergedAnnotations.from(element, SearchStrategy.TYPE_HIERARCHY);\n   Integer order = OrderUtils.getOrderFromAnnotations(element, annotations);\n   if (order == null &amp;&amp; obj instanceof DecoratingProxy) {\n      return findOrderFromAnnotation(((DecoratingProxy) obj).getDecoratedClass());\n   }\n   return order;\n}\n<\/code><\/pre><ol start=\"2\">\n<li>从Ordered 接口实现方法获取值，参考OrderComparator#findOrder：<\/li>\n<\/ol><pre><code>protected Integer findOrder(Object obj) {\n   return (obj instanceof Ordered ? ((Ordered) obj).getOrder() : null);\n}\n<\/code><\/pre><p>通过上面的分析，如果我们不能改变类继承关系（例如让Student实现Ordered接口），则可以通过使用@Order来调整顺序，具体修改代码如下：<\/p><pre><code>@Bean\n@Order(2)\npublic Student student1(){\n    return createStudent(1, &quot;xie&quot;);\n}\n\n@Bean\n@Order(1)\npublic Student student2(){\n    return createStudent(2, &quot;fang&quot;);\n}\n<\/code><\/pre><p>现在，我们就可以把原先的Bean输出顺序颠倒过来了，示例如下：<\/p><blockquote>\n<p>Student(id=2, name=fang)],[Student(id=1, name=xie)<\/p>\n<\/blockquote><h2><strong><a href=\"https:\/\/time.geekbang.org\/column\/article\/367876\">第4课<\/a><\/strong><\/h2><p>案例 2 中的类 LightService，当我们不在 Configuration 注解类中使用 Bean 方法将其注入 Spring 容器，而是坚持使用 @Service 将其自动注入到容器，同时实现 Closeable 接口，代码如下：<\/p><pre><code>import org.springframework.stereotype.Component;\nimport java.io.Closeable;\n@Service\npublic class LightService implements Closeable {\n    public void close() {\n        System.out.println(&quot;turn off all lights);\n    }\n    \/\/省略非关键代码\n}\n<\/code><\/pre><p>接口方法 close() 也会在 Spring 容器被销毁的时候自动执行么？<\/p><p>答案是肯定的，通过案例 2 的分析，你可以知道，当 LightService 是一个实现了 Closable 接口的单例 Bean 时，会有一个 DisposableBeanAdapter 被添加进去。<\/p><p>而具体到执行哪一种方法？shutdown()？close()? 在代码中你能够找到答案，在 DisposableBeanAdapter 类的 inferDestroyMethodIfNecessary 中，我们可以看到有两种情况会获取到当前 Bean 类中的 close()。<\/p><p>第一种情况，就是我们这节课提到的当使用@Bean且使用默认的 destroyMethod 属性（INFER_METHOD）；第二种情况，是判断当前类是否实现了 AutoCloseable 接口，如果实现了，那么一定会获取此类的 close()。<\/p><pre><code>private String inferDestroyMethodIfNecessary(Object bean, RootBeanDefinition beanDefinition) {\n   String destroyMethodName = beanDefinition.getDestroyMethodName();\n   if (AbstractBeanDefinition.INFER_METHOD.equals(destroyMethodName) ||(destroyMethodName == null &amp;&amp; bean instanceof AutoCloseable)) {\n      if (!(bean instanceof DisposableBean)) {\n         try {\n            return bean.getClass().getMethod(CLOSE_METHOD_NAME).getName();\n         }\n         catch (NoSuchMethodException ex) {\n            try {\n               return bean.getClass().getMethod(SHUTDOWN_METHOD_NAME).getName();\n            }\n            catch (NoSuchMethodException ex2) {\n               \/\/ no candidate destroy method found\n            }\n         }\n      }\n      return null;\n   }\n   return (StringUtils.hasLength(destroyMethodName) ? destroyMethodName : null);\n}\n<\/code><\/pre><p>到这，相信你应该可以结合 Closable 接口和@Service（或其他@Component）让关闭方法得到执行了。<\/p><h2><strong><a href=\"https:\/\/time.geekbang.org\/column\/article\/369251\">第5课<\/a><\/strong><\/h2><p>案例2中，我们提到了通过反射来实例化类的三种方式：<\/p><ul>\n<li>java.lang.Class.newInsance()<\/li>\n<li>java.lang.reflect.Constructor.newInstance()<\/li>\n<li>sun.reflect.ReflectionFactory.newConstructorForSerialization().newInstance()<\/li>\n<\/ul><p>其中第三种方式不会初始化类属性，你能够写一个例子来证明这一点吗？<\/p><p>能证明的例子，代码示例如下：<\/p><pre><code>import sun.reflect.ReflectionFactory;\nimport java.lang.reflect.Constructor;\n\npublic class TestNewInstanceStyle {\n\n    public static class TestObject{\n        public String name = &quot;fujian&quot;;\n    }\n\n    public static void main(String[] args) throws Exception {\n        \/\/ReflectionFactory.newConstructorForSerialization()方式\n        ReflectionFactory reflectionFactory = ReflectionFactory.getReflectionFactory();\n        Constructor constructor = reflectionFactory.newConstructorForSerialization(TestObject.class, Object.class.getDeclaredConstructor());\n        constructor.setAccessible(true);\n        TestObject testObject1 = (TestObject) constructor.newInstance();\n        System.out.println(testObject1.name);\n        \/\/普通方式\n        TestObject testObject2 = new TestObject();\n        System.out.println(testObject2.name);\n    }\n\n}\n<\/code><\/pre><p>运行结果如下：<\/p><blockquote>\n<p>null<br>\nfujian<\/p>\n<\/blockquote><h2><strong><a href=\"https:\/\/time.geekbang.org\/column\/article\/369989\">第6课<\/a><\/strong><\/h2><p>实际上，审阅这节课两个案例的修正方案，你会发现它们虽然改动很小，但是都还不够优美。那么有没有稍微优美点的替代方案呢？如果有，你知道背后的原理及关键源码吗？顺便你也可以想想，我为什么没有用更优美的方案呢？<\/p><p>我们可以将“未达到执行顺序预期”的增强方法移动到一个独立的切面类，而不同的切面类可以使用 @Order 进行修饰。@Order 的 value 值越低，则执行优先级越高。以案例 2 为例，可以修改如下：<\/p><pre><code>@Aspect\n@Service\n@Order(1)\npublic class AopConfig1 {\n    @Before(&quot;execution(* com.spring.puzzle.class6.example2.ElectricService.charge()) &quot;)\n    public void validateAuthority(JoinPoint pjp) throws Throwable {\n        throw new RuntimeException(&quot;authority check failed&quot;);\n    }\n}\n\n\n@Aspect\n@Service\n@Order(2)\npublic class AopConfig2 {\n\n    @Before(&quot;execution(* com.spring.puzzle.class6.example2.ElectricService.charge())&quot;)\n    public void logBeforeMethod(JoinPoint pjp) throws Throwable {\n        System.out.println(&quot;step into -&gt;&quot;+pjp.getSignature());\n    }\n\n}\n<\/code><\/pre><p>上述修改的核心就是将原来的 AOP 配置，切成两个类进行，并分别使用@Order标记下优先级。这样修改后，当授权失败了，则不会打印“step into -&gt;”相关日志。<\/p><p>为什么这样是可行的呢？这还得回溯到案例1，当时我们提出这样一个结论：AbstractAdvisorAutoProxyCreator 执行 findEligibleAdvisors（代码如下）寻找匹配的 Advisors 时，最终返回的 Advisors 顺序是由两点来决定的：candidateAdvisors 的顺序和 sortAdvisors 执行的排序。<\/p><pre><code>protected List&lt;Advisor&gt; findEligibleAdvisors(Class&lt;?&gt; beanClass, String beanName) {\n   List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();\n   List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);\n   extendAdvisors(eligibleAdvisors);\n   if (!eligibleAdvisors.isEmpty()) {\n      eligibleAdvisors = sortAdvisors(eligibleAdvisors);\n   }\n   return eligibleAdvisors;\n}\n<\/code><\/pre><p>当时影响我们案例出错的关键点都是在 candidateAdvisors 的顺序上，所以我们重点介绍了它。而对于 sortAdvisors 执行的排序并没有多少涉及，这里我可以再重点介绍下。<\/p><p>在实现上，sortAdvisors 的执行最终调用的是比较器 AnnotationAwareOrderComparator 类的 compare()，它调用了 getOrder() 的返回值作为排序依据：<\/p><pre><code>public int compare(@Nullable Object o1, @Nullable Object o2) {\n   return doCompare(o1, o2, null);\n}\n\nprivate int doCompare(@Nullable Object o1, @Nullable Object o2, @Nullable OrderSourceProvider sourceProvider) {\n   boolean p1 = (o1 instanceof PriorityOrdered);\n   boolean p2 = (o2 instanceof PriorityOrdered);\n   if (p1 &amp;&amp; !p2) {\n      return -1;\n   }\n   else if (p2 &amp;&amp; !p1) {\n      return 1;\n   }\n\n   int i1 = getOrder(o1, sourceProvider);\n   int i2 = getOrder(o2, sourceProvider);\n   return Integer.compare(i1, i2);\n}\n<\/code><\/pre><p>继续跟踪 getOrder() 的执行细节，我们会发现对于我们的案例，这个方法会找出配置切面的 Bean 的 Order值。这里可以参考 BeanFactoryAspectInstanceFactory#getOrder 的调试视图验证这个结论：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/21\/8e\/211b5c15657881e5d0cc3cc86229a28e.png?wh=1178*392\" alt=\"\"><\/p><p>上述截图中，aopConfig2 即是我们配置切面的 Bean 的名称。这里再顺带提供出调用栈的截图，以便你做进一步研究：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/60\/a9\/600ac1d34422c57276d83c8ee03a36a9.png?wh=1342*678\" alt=\"\"><\/p><p>现在我们就知道了，将不同的增强方法放置到不同的切面配置类中，使用不同的 Order 值来修饰是可以影响顺序的。相反，如果都是在一个配置类中，自然不会影响顺序，所以这也是当初我的方案中没有重点介绍 sortAdvisors 方法的原因，毕竟当时我们给出的案例都只有一个 AOP 配置类。<\/p><h2><strong><a href=\"https:\/\/time.geekbang.org\/column\/article\/370741\">第7课<\/a><\/strong><\/h2><p>在案例 3 中，我们提到默认的事件执行是在同一个线程中执行的，即事件发布者使用的线程。参考如下日志佐证这个结论：<\/p><blockquote>\n<p>2021-03-09 09:10:33.052 INFO 18104 --- [nio-8080-exec-1] c.s.p.listener.HelloWorldController : start to publish event<br>\n2021-03-09 09:10:33.055 INFO 18104 --- [nio-8080-exec-1] c.s.p.l.example3.MyFirstEventListener : com.spring.puzzle.class7.example3.MyFirstEventListener@18faf0 received: com.spring.puzzle.class7.example3.MyEvent[source=df42b08f-8ee2-44df-a957-d8464ff50c88]<\/p>\n<\/blockquote><p>通过日志可以看出，事件的发布和执行使用的都是nio-8080-exec-1线程，但是在事件比较多时，我们往往希望事件执行得更快些，或者希望事件的执行可以异步化以不影响主线程。此时应该如何做呢？<\/p><p>针对上述问题中的需求，我们只需要对于事件的执行引入线程池即可。我们先来看下 Spring 对这点的支持。实际上，在案例 3 的解析中，我们已贴出了以下代码片段（位于 SimpleApplicationEventMulticaster#multicastEvent 方法中）：<\/p><pre><code> \/\/省略其他非关键代码\n \/\/获取 executor \n Executor executor = getTaskExecutor();\n   for (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) {\n      \/\/如果存在 executor，则提交到 executor 中去执行\n      if (executor != null) {\n         executor.execute(() -&gt; invokeListener(listener, event));\n      }\n \/\/省略其他非关键代码\n<\/code><\/pre><p>对于事件的处理，可以绑定一个 Executor 去执行，那么如何绑定？其实与这节课讲过的绑定 ErrorHandler 的方法是类似的。绑定代码示例如下：<\/p><pre><code>\/\/注意下面的语句只能执行一次，以避免重复创建线程池\nExecutorService newCachedThreadPool = Executors.newCachedThreadPool();\n\/\/省略非关键代码\nSimpleApplicationEventMulticaster simpleApplicationEventMulticaster = applicationContext.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, SimpleApplicationEventMulticaster.class);\nsimpleApplicationEventMulticaster.setTaskExecutor(newCachedThreadPool );\n<\/code><\/pre><p>取出SimpleApplicationEventMulticaster，然后直接调用相关 set() 设置线程池就可以了。按这种方式修改后的程序，事件处理的日志如下：<\/p><blockquote>\n<p>2021-03-09 09:25:09.917 INFO 16548 --- [nio-8080-exec-1] c.s.p.c.HelloWorldController : start to publish event<br>\n2021-03-09 09:25:09.920 INFO 16548 --- [pool-1-thread-3] c.s.p.l.example3.MyFirstEventListener : com.spring.puzzle.class7.example3.MyFirstEventListener@511056 received: com.spring.puzzle.class7.example3.MyEvent[source=cbb97bcc-b834-485c-980e-2e20de56c7e0]<\/p>\n<\/blockquote><p>可以看出，事件的发布和处理分属不同的线程了，分别为 nio-8080-exec-1 和 pool-1-thread-3，满足了我们的需求。<\/p><p>以上就是这次答疑的全部内容，我们下一章节再见！<\/p>","footer_cover_data":{"img_url":"","mp_url":"","link_url":""},"article_cover_hidden":false,"column_is_experience":false,"is_required":false,"rate":{},"product_id":100077001,"like_count":8,"had_liked":false,"article_subtitle":"无","audio_download_url":"https:\/\/static001.geekbang.org\/resource\/audio\/f2\/15\/f285d5312613a58052cf4993bd7a7615.mp3","id":371184,"had_viewed":false,"article_title":"08｜答疑现场：Spring Core 篇思考题合集","column_bgcolor":"#F6F7FB","share":{"content":"Spring 开发老兵 10 年避坑心法","title":"傅健 · Spring编程常见错误50例","poster":"https:\/\/static001.geekbang.org\/resource\/image\/81\/cf\/81d9cef44e90ff4890d04b735fd135cf.jpg","cover":"https:\/\/static001.geekbang.org\/resource\/image\/82\/a2\/829d02f2fc0e10860d7b5401f2160ba2.jpg"},"is_video_preview":false,"article_summary":"希望你都能在问题的解决中获得一些正向反馈，完成学习闭环。","article_poster_wxlite":"https:\/\/static001.geekbang.org\/render\/screen\/46\/bc\/460e2ee863c00a31426a2e1001462bbc.jpeg","column_sale_type":2,"article_features":0,"article_could_preview":false,"column_cover":"https:\/\/static001.geekbang.org\/resource\/image\/82\/a2\/829d02f2fc0e10860d7b5401f2160ba2.jpg","column_id":408,"audio_time_arr":{"m":"01","s":"41","h":"00"},"video_time":"","audio_title":"傅健-08","audio_md5":"f285d5312613a58052cf4993bd7a7615","video_size":0,"text_read_percent":0,"comment_count":4,"cid":408,"article_sharetitle":"答疑现场：Spring Core 篇思考题合集","column_is_onboard":true,"article_cshort":"<p>你好，我是傅健。<\/p><p>如果你看到这篇文章，那么我真的非常开心，这说明第一章节的内容你都跟下来了，并且对于课后的思考题也有研究，在这我要手动给你点个赞。繁忙的工作中，还能为自己持续充电，保持终身学习的心态，我想我们一定是同路人。<\/p><p>那么到今天为止，我们已经学习了 17 个案例，解决的问题也不算少了，不知道你的感受如何？收获如何呢？<\/p><p>我还记得<a href=\"https:\/\/time.geekbang.org\/column\/article\/364661\">开篇词<\/a>的留言区中有位很有趣的同学，他说：“作为一线 bug 制造者，希望能少写点 bug。” 感同身受，和 Spring 斗智斗勇的这些年，我也经常为一些问题而抓狂过，因不能及时解决而焦虑过，但最终还是觉得蛮有趣的，这个专栏也算是沉淀之作，希望能给你带来一些实际的帮助。<\/p><p>最初，我其实是想每节课都和你交流下上节课的思考题，但又担心大家的学习进度不一样，所以就有了这次的集中答疑，我把我的答案给到大家，你也可以对照着去看一看，也许有更好的方法，欢迎你来贡献“选项”，我们一起交流。希望大家都能在问题的解决中获得一些正向反馈，完成学习闭环。<\/p><h2><strong><a href=\"https:\/\/time.geekbang.org\/column\/article\/364761\">第1课<\/a><\/strong><\/h2><p>在案例 2 中，显示定义构造器，这会发生根据构造器参数寻找对应 Bean 的行为。这里请你思考一个问题，假设寻找不到对应的 Bean，一定会如案例 2 那样直接报错么？<\/p>","video_width":0,"column_could_sub":true,"article_ctime":1620316800,"score":"21620316800","video_media_map":{},"video_preview":{},"video":0,"video_time_arr":{"m":"","s":"","h":""},"video_total_seconds":0},"extra":{},"error":{}}