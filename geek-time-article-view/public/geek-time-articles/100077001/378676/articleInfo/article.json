{"code":0,"data":{"video_id":"","sku":"100077001","video_cover":"","author_name":"傅健","text_read_version":0,"audio_size":13993450,"article_cover":"https:\/\/static001.geekbang.org\/resource\/image\/36\/9d\/36c198c409246d00b59e7af30870889d.jpg","subtitles":{},"product_type":"c1","audio_url":"https:\/\/res001.geekbang.org\/media\/audio\/56\/51\/56f3049c03ba11yyyy6540181b709a51\/ld\/ld.m3u8","chapter_id":"0","column_had_sub":true,"audio_dubber":"傅健","is_finished":false,"inline_video_subtitles":{},"like":{"had_done":false,"count":8},"neighbors":{"left":{"id":378170,"article_title":"15 | Spring Security 常见错误"},"right":{"id":378689,"article_title":"17｜答疑现场：Spring Web 篇思考题合集"}},"audio_time":"00:14:36","video_height":0,"rate_percent":0,"article_content":"<p>你好，我是傅健。<\/p><p>今天，我们来学习 Spring 的异常处理机制。Spring 提供了一套健全的异常处理框架，以便我们在开发应用的时候对异常进行处理。但是，我们也会在使用的时候遇到一些麻烦，接下来我将通过两个典型的错误案例，带着你结合源码进行深入了解。<\/p><h2>案例 1：小心过滤器异常<\/h2><p>为了方便讲解，我们还是沿用之前在事务处理中用到的学生注册的案例，来讨论异常处理的问题：<\/p><pre><code>@Controller\n@Slf4j\npublic class StudentController {\n    public StudentController(){\n        System.out.println(&quot;construct&quot;);\n    }\n\n\n    @PostMapping(&quot;\/regStudent\/{name}&quot;)\n    @ResponseBody\n    public String saveUser(String name) throws Exception {\n        System.out.println(&quot;......用户注册成功&quot;);\n        return &quot;success&quot;;\n    }\n}\n<\/code><\/pre><p>​为了保证安全，这里需要给请求加一个保护，通过验证 Token 的方式来验证请求的合法性。这个 Token 需要在每次发送请求的时候带在请求的 header 中，header 的 key 是 Token。<\/p><p>为了校验这个 Token，我们引入了一个 Filter 来处理这个校验工作，这里我使用了一个最简单的 Token：111111。<\/p><p>当 Token 校验失败时，就会抛出一个自定义的 NotAllowException，交由 Spring 处理：<\/p><pre><code>@WebFilter\n@Component\npublic class PermissionFilter implements Filter {\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        HttpServletRequest httpServletRequest = (HttpServletRequest) request;\n        String token = httpServletRequest.getHeader(&quot;token&quot;);\n\n\n        if (!&quot;111111&quot;.equals(token)) {\n            System.out.println(&quot;throw NotAllowException&quot;);\n            throw new NotAllowException();\n        }\n        chain.doFilter(request, response);\n    }\n\n\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n    }\n\n\n    @Override\n    public void destroy() {\n    }\n<\/code><\/pre><p>NotAllowException 就是一个简单的 RuntimeException 的子类：<\/p><pre><code>public class NotAllowException extends RuntimeException {\n    public NotAllowException() {\n        super();\n    }\n}\n<\/code><\/pre><p>同时，新增了一个 RestControllerAdvice 来处理这个异常，处理方式也很简单，就是返回一个 403 的 resultCode：<\/p><!-- [[[read_end]]] --><pre><code>@RestControllerAdvice\npublic class NotAllowExceptionHandler {\n    @ExceptionHandler(NotAllowException.class)\n    @ResponseBody\n    public String handle() {\n        System.out.println(&quot;403&quot;);\n        return &quot;{\\&quot;resultCode\\&quot;: 403}&quot;;\n    }\n}\n<\/code><\/pre><p>为了验证一下失败的情况，我们模拟了一个请求，在 HTTP 请求头里加上一个 Token，值为 111，这样就会引发错误了，我们可以看看会不会被 NotAllowExceptionHandler 处理掉。<\/p><p>然而，在控制台上，我们只看到了下面这样的输出，这其实就说明了 NotAllowExceptionHandler 并没有生效。<\/p><pre><code>throw NotAllowException\n<\/code><\/pre><p>想下问题出在哪呢？我们不妨对 Spring 的异常处理过程先做一个了解。<\/p><h3>案例解析<\/h3><p>我们先来回顾一下<a href=\"https:\/\/time.geekbang.org\/column\/article\/376115\">第13课<\/a>讲过的过滤器执行流程图，这里我细化了一下：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/3f\/fe\/3f1fa1106a733b137ee965850c9276fe.png?wh=1668*904\" alt=\"\"><\/p><p>从这张图中可以看出，当所有的过滤器被执行完毕以后，Spring 才会进入 Servlet 相关的处理，而 DispatcherServlet 才是整个 Servlet 处理的核心，它是前端控制器设计模式的实现，提供 Spring Web MVC 的集中访问点并负责职责的分派。正是在这里，Spring 处理了请求和处理器之间的对应关系，以及这个案例我们所关注的问题——统一异常处理。<\/p><p>其实说到这里，我们已经了解到过滤器内异常无法被统一处理的大致原因，就是因为异常处理发生在上图的红色区域，即DispatcherServlet中的doDispatch()，而此时，过滤器已经全部执行完毕了。<\/p><p>下面我们将深入分析 Spring Web 对异常统一处理的逻辑，深刻理解其内部原理。<\/p><p><strong>首先我们来了解下ControllerAdvice是如何被Spring加载并对外暴露的。<\/strong>在Spring Web 的核心配置类 WebMvcConfigurationSupport 中，被 @Bean 修饰的 handlerExceptionResolver()，会调用addDefaultHandlerExceptionResolvers() 来添加默认的异常解析器。<\/p><pre><code>@Bean\npublic HandlerExceptionResolver handlerExceptionResolver(\n      @Qualifier(&quot;mvcContentNegotiationManager&quot;) ContentNegotiationManager contentNegotiationManager) {\n   List&lt;HandlerExceptionResolver&gt; exceptionResolvers = new ArrayList&lt;&gt;();\n   configureHandlerExceptionResolvers(exceptionResolvers);\n   if (exceptionResolvers.isEmpty()) {\n      addDefaultHandlerExceptionResolvers(exceptionResolvers, contentNegotiationManager);\n   }\n   extendHandlerExceptionResolvers(exceptionResolvers);\n   HandlerExceptionResolverComposite composite = new HandlerExceptionResolverComposite();\n   composite.setOrder(0);\n   composite.setExceptionResolvers(exceptionResolvers);\n   return composite;\n}\n<\/code><\/pre><p>最终按照下图的调用栈，Spring 实例化了ExceptionHandlerExceptionResolver类。<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/73\/c1\/73278f8a4366654e5b94783395d0eac1.png?wh=1298*220\" alt=\"\"><\/p><p>从源码中我们可以看出，ExceptionHandlerExceptionResolver 类实现了InitializingBean接口，并覆写了afterPropertiesSet()。<\/p><pre><code>public void afterPropertiesSet() {\n   \/\/ Do this first, it may add ResponseBodyAdvice beans\n   initExceptionHandlerAdviceCache();\n    \/\/省略非关键代码\n}\n<\/code><\/pre><p>并在 initExceptionHandlerAdviceCache() 中完成了所有 ControllerAdvice 中的ExceptionHandler 的初始化。其具体操作，就是查找所有 @ControllerAdvice 注解的 Bean，把它们放到成员变量 exceptionHandlerAdviceCache 中。<\/p><p>在我们这个案例里，就是指 NotAllowExceptionHandler 这个异常处理器。<\/p><pre><code>private void initExceptionHandlerAdviceCache() {\n   \/\/省略非关键代码\n   List&lt;ControllerAdviceBean&gt; adviceBeans = ControllerAdviceBean.findAnnotatedBeans(getApplicationContext());\n   for (ControllerAdviceBean adviceBean : adviceBeans) {\n      Class&lt;?&gt; beanType = adviceBean.getBeanType();\n      if (beanType == null) {\n         throw new IllegalStateException(&quot;Unresolvable type for ControllerAdviceBean: &quot; + adviceBean);\n      }\n      ExceptionHandlerMethodResolver resolver = new ExceptionHandlerMethodResolver(beanType);\n      if (resolver.hasExceptionMappings()) {\n         this.exceptionHandlerAdviceCache.put(adviceBean, resolver);\n      }\n \/\/省略非关键代码\n}\n<\/code><\/pre><p>到这，我们可以总结一下，WebMvcConfigurationSupport 中的handlerExceptionResolver() 实例化并注册了一个ExceptionHandlerExceptionResolver 的实例，而所有被 @ControllerAdvice 注解修饰的异常处理器，都会在 ExceptionHandlerExceptionResolver 实例化的时候自动扫描并装载在其类成员变量 exceptionHandlerAdviceCache 中。<\/p><p>当第一次请求发生时，DispatcherServlet 中的 initHandlerExceptionResolvers() 将获取所有注册到 Spring 的 HandlerExceptionResolver 类型的实例，而ExceptionHandlerExceptionResolver 恰好实现了 HandlerExceptionResolver 接口，这些 HandlerExceptionResolver 类型的实例则会被写入到类成员变量handlerExceptionResolvers中。<\/p><pre><code>private void initHandlerExceptionResolvers(ApplicationContext context) {\n   this.handlerExceptionResolvers = null;\n\n   if (this.detectAllHandlerExceptionResolvers) {\n      \/\/ Find all HandlerExceptionResolvers in the ApplicationContext, including ancestor contexts.\n      Map&lt;String, HandlerExceptionResolver&gt; matchingBeans = BeanFactoryUtils\n            .beansOfTypeIncludingAncestors(context, HandlerExceptionResolver.class, true, false);\n      if (!matchingBeans.isEmpty()) {\n         this.handlerExceptionResolvers = new ArrayList&lt;&gt;(matchingBeans.values());\n         \/\/ We keep HandlerExceptionResolvers in sorted order.\n         AnnotationAwareOrderComparator.sort(this.handlerExceptionResolvers);\n      }\n      \/\/省略非关键代码\n}\n\n<\/code><\/pre><p><strong>接着我们再来了解下ControllerAdvice是如何被Spring消费并处理异常的。<\/strong>下文贴出的是核心类 DispatcherServlet 中的核心方法 doDispatch() 的部分代码：<\/p><pre><code>protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n   \/\/省略非关键代码\n\n   try {\n      ModelAndView mv = null;\n      Exception dispatchException = null;\n      try {\n         \/\/省略非关键代码\n         \/\/查找当前请求对应的 handler，并执行\n         \/\/省略非关键代码\n      }\n      catch (Exception ex) {\n         dispatchException = ex;\n      }\n      catch (Throwable err) {\n         dispatchException = new NestedServletException(&quot;Handler dispatch failed&quot;, err);\n      }\n      processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);\n   }\n   \/\/省略非关键代码\n<\/code><\/pre><p>Spring 在执行用户请求时，当在“查找”和“执行”请求对应的 handler 过程中发生异常，就会把异常赋值给 dispatchException，再交给 processDispatchResult() 进行处理。<\/p><pre><code>private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,\n      @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,\n      @Nullable Exception exception) throws Exception {\n   boolean errorView = false;\n   if (exception != null) {\n      if (exception instanceof ModelAndViewDefiningException) {\n         mv = ((ModelAndViewDefiningException) exception).getModelAndView();\n      }\n      else {\n         Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);\n         mv = processHandlerException(request, response, handler, exception);\n         errorView = (mv != null);\n      }\n   }\n   \/\/省略非关键代码\n<\/code><\/pre><p>进一步处理后，即当 Exception 不为 null 时，继续交给 processHandlerException处理。<\/p><pre><code>protected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response,\n      @Nullable Object handler, Exception ex) throws Exception {\n   \/\/省略非关键代码\n   ModelAndView exMv = null;\n   if (this.handlerExceptionResolvers != null) {\n      for (HandlerExceptionResolver resolver : this.handlerExceptionResolvers) {\n         exMv = resolver.resolveException(request, response, handler, ex);\n         if (exMv != null) {\n            break;\n         }\n      }\n   }\n   \/\/省略非关键代码\n}\n<\/code><\/pre><p>然后，processHandlerException 会从类成员变量 handlerExceptionResolvers 中获取有效的异常解析器，对异常进行解析。<\/p><p>显然，这里的 handlerExceptionResolvers 一定包含我们声明的NotAllowExceptionHandler#NotAllowException 的异常处理器的 ExceptionHandlerExceptionResolver 包装类。<\/p><h3>问题修正<\/h3><p>为了利用 Spring MVC 的异常处理机制，我们需要对 Filter 做一些改造。手动捕获异常，并将异常 HandlerExceptionResolver 进行解析处理。<\/p><p>我们可以这样修改 PermissionFilter，注入 HandlerExceptionResolver：<\/p><pre><code>@Autowired\n@Qualifier(&quot;handlerExceptionResolver&quot;)\nprivate HandlerExceptionResolver resolver;\n<\/code><\/pre><p>然后，在 doFilter 里捕获异常并交给 HandlerExceptionResolver 处理：<\/p><pre><code>    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        HttpServletRequest httpServletRequest = (HttpServletRequest) request;\n        HttpServletResponse httpServletResponse = (HttpServletResponse) response;\n        String token = httpServletRequest.getHeader(&quot;token&quot;);\n        if (!&quot;111111&quot;.equals(token)) {\n            System.out.println(&quot;throw NotAllowException&quot;);\n            resolver.resolveException(httpServletRequest, httpServletResponse, null, new NotAllowException());\n            return;\n        }\n        chain.doFilter(request, response);\n    }\n<\/code><\/pre><p>当我们尝试用错误的 Token 请求，控制台得到了以下信息：<\/p><pre><code>throw NotAllowException\n403\n<\/code><\/pre><p>返回的 JSON 是：<\/p><pre><code>{&quot;resultCode&quot;: 403}\n<\/code><\/pre><p>再换成正确的 Token 请求，这些错误信息就都没有了，到这，问题解决了。<\/p><h2>案例 2：特殊的 404 异常<\/h2><p>继续沿用学生注册的案例，为了防止一些异常的访问，我们需要记录所有 404 状态的访问记录，并返回一个我们的自定义结果。<\/p><p>一般使用 RESTful 接口时我们会统一返回 JSON 数据，返回值格式如下：<\/p><pre><code>{&quot;resultCode&quot;: 404}\n<\/code><\/pre><p>但是 Spring 对 404 异常是进行了默认资源映射的，并不会返回我们想要的结果，也不会对这种错误做记录。<\/p><p>于是我们添加了一个 ExceptionHandlerController，它被声明成@RestControllerAdvice来全局捕获 Spring MVC 中抛出的异常。<\/p><p>ExceptionHandler 的作用正是用来捕获指定的异常：<\/p><pre><code>@RestControllerAdvice\npublic class MyExceptionHandler {\n    @ResponseStatus(HttpStatus.NOT_FOUND)\n    @ExceptionHandler(Exception.class)\n    @ResponseBody\n    public String handle404() {\n        System.out.println(&quot;404&quot;);\n        return &quot;{\\&quot;resultCode\\&quot;: 404}&quot;;\n    }\n}\n<\/code><\/pre><p>我们尝试发送一个错误的 URL 请求到之前实现过的 \/regStudent 接口，并把请求地址换成 \/regStudent1，得到了以下结果：<\/p><pre><code>{&quot;timestamp&quot;:&quot;2021-05-19T22:24:01.559+0000&quot;,&quot;status&quot;:404,&quot;error&quot;:&quot;Not Found&quot;,&quot;message&quot;:&quot;No message available&quot;,&quot;path&quot;:&quot;\/regStudent1&quot;}\n<\/code><\/pre><p>很显然，这个结果不是我们想要的，看起来应该是 Spring 默认的返回结果。那是什么原因导致 Spring 没有使用我们定义的异常处理器呢？<\/p><h3>案例解析<\/h3><p>我们可以从异常处理的核心处理代码开始分析，DispatcherServlet 中的 doDispatch() 核心代码如下：<\/p><pre><code>protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        \/\/省略非关键代码\n         mappedHandler = getHandler(processedRequest);\n         if (mappedHandler == null) {\n            noHandlerFound(processedRequest, response);\n            return;\n         }\n         \/\/省略非关键代码\n}\n<\/code><\/pre><p>首先调用 getHandler() 获取当前请求的处理器，如果获取不到，则调用noHandlerFound()：<\/p><pre><code>protected void noHandlerFound(HttpServletRequest request, HttpServletResponse response) throws Exception {\n   if (this.throwExceptionIfNoHandlerFound) {\n      throw new NoHandlerFoundException(request.getMethod(), getRequestUri(request),\n            new ServletServerHttpRequest(request).getHeaders());\n   }\n   else {\n      response.sendError(HttpServletResponse.SC_NOT_FOUND);\n   }\n}\n<\/code><\/pre><p>noHandlerFound() 的逻辑非常简单，如果 throwExceptionIfNoHandlerFound 属性为 true，则直接抛出 NoHandlerFoundException 异常，反之则会进一步获取到对应的请求处理器执行，并将执行结果返回给客户端。<\/p><p>到这，真相离我们非常近了，我们只需要将 throwExceptionIfNoHandlerFound 默认设置为 true 即可，这样就会抛出 NoHandlerFoundException 异常，从而被 doDispatch()内的 catch 俘获。进而就像案例1介绍的一样，最终能够执行我们自定义的异常处理器MyExceptionHandler。<\/p><p>于是，我们开始尝试，因为 throwExceptionIfNoHandlerFound 对应的 Spring 配置项为 throw-exception-if-no-handler-found，我们将其加入到 application.properties 配置文件中，设置其值为 true。<\/p><p>设置完毕后，重启服务并再次尝试，你会发现结果没有任何变化，这个问题也没有被解决。<\/p><p>实际上这里还存在另一个坑，在 Spring Web 的 WebMvcAutoConfiguration 类中，其默认添加的两个 ResourceHandler，一个是用来处理请求路径\/webjars\/*<em>*<\/em>，而另一个是\/**。<\/p><p>即便当前请求没有定义任何对应的请求处理器，getHandler() 也一定会获取到一个 Handler 来处理当前请求，因为第二个匹配 \/** 路径的 ResourceHandler 决定了任何请求路径都会被其处理。mappedHandler == null 判断条件永远不会成立，显然就不可能走到 noHandlerFound()，那么就不会抛出 NoHandlerFoundException 异常，也无法被后续的异常处理器进一步处理。<\/p><p>下面让我们通过源码进一步了解下这个默认被添加的 ResourceHandler 的详细逻辑 。<\/p><p><strong>首先我们来了解下ControllerAdvice是如何被Spring加载并对外暴露的。<\/strong><\/p><p>同样是在 WebMvcConfigurationSupport 类中，被 @Bean 修饰的 resourceHandlerMapping()，它新建了 ResourceHandlerRegistry 类实例，并通过 addResourceHandlers() 将 ResourceHandler 注册到 ResourceHandlerRegistry 类实例中：<\/p><pre><code>@Bean\n@Nullable\npublic HandlerMapping resourceHandlerMapping(\n      @Qualifier(&quot;mvcUrlPathHelper&quot;) UrlPathHelper urlPathHelper,\n      @Qualifier(&quot;mvcPathMatcher&quot;) PathMatcher pathMatcher,\n      @Qualifier(&quot;mvcContentNegotiationManager&quot;) ContentNegotiationManager contentNegotiationManager,\n      @Qualifier(&quot;mvcConversionService&quot;) FormattingConversionService conversionService,\n      @Qualifier(&quot;mvcResourceUrlProvider&quot;) ResourceUrlProvider resourceUrlProvider) {\n\n   Assert.state(this.applicationContext != null, &quot;No ApplicationContext set&quot;);\n   Assert.state(this.servletContext != null, &quot;No ServletContext set&quot;);\n\n   ResourceHandlerRegistry registry = new ResourceHandlerRegistry(this.applicationContext,\n         this.servletContext, contentNegotiationManager, urlPathHelper);\n   addResourceHandlers(registry);\n\n   AbstractHandlerMapping handlerMapping = registry.getHandlerMapping();\n   if (handlerMapping == null) {\n      return null;\n   }\n   handlerMapping.setPathMatcher(pathMatcher);\n   handlerMapping.setUrlPathHelper(urlPathHelper);\n   handlerMapping.setInterceptors(getInterceptors(conversionService, resourceUrlProvider));\n   handlerMapping.setCorsConfigurations(getCorsConfigurations());\n   return handlerMapping;\n}\n<\/code><\/pre><p>最终通过 ResourceHandlerRegistry 类实例中的 getHandlerMapping() 返回了 SimpleUrlHandlerMapping 实例，它装载了所有 ResourceHandler 的集合并注册到了 Spring 容器中：<\/p><pre><code>protected AbstractHandlerMapping getHandlerMapping() {\n   \/\/省略非关键代码\n   Map&lt;String, HttpRequestHandler&gt; urlMap = new LinkedHashMap&lt;&gt;();\n   for (ResourceHandlerRegistration registration : this.registrations) {\n      for (String pathPattern : registration.getPathPatterns()) {\n         ResourceHttpRequestHandler handler = registration.getRequestHandler();\n         \/\/省略非关键代码\n         urlMap.put(pathPattern, handler);\n      }\n   }\n   return new SimpleUrlHandlerMapping(urlMap, this.order);\n}\n<\/code><\/pre><p>我们查看以下调用栈截图：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/a2\/97\/a220a653ddb4394caeee6f2721b35697.png?wh=1086*176\" alt=\"\"><\/p><p>可以了解到，当前方法中的 addResourceHandlers() 最终执行到了 WebMvcAutoConfiguration 类中的 addResourceHandlers()，通过这个方法，我们可以知道当前有哪些 ResourceHandler 的集合被注册到了Spring容器中：<\/p><pre><code>public void addResourceHandlers(ResourceHandlerRegistry registry) {\n   if (!this.resourceProperties.isAddMappings()) {\n      logger.debug(&quot;Default resource handling disabled&quot;);\n      return;\n   }\n   Duration cachePeriod = this.resourceProperties.getCache().getPeriod();\n   CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();\n   if (!registry.hasMappingForPattern(&quot;\/webjars\/**&quot;)) {\n      customizeResourceHandlerRegistration(registry.addResourceHandler(&quot;\/webjars\/**&quot;)\n            .addResourceLocations(&quot;classpath:\/META-INF\/resources\/webjars\/&quot;)\n            .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));\n   }\n   String staticPathPattern = this.mvcProperties.getStaticPathPattern();\n   if (!registry.hasMappingForPattern(staticPathPattern)) {\n      customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)\n            .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations()))\n            .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));\n   }\n}\n<\/code><\/pre><p>从而验证我们一开始得出的结论，此处添加了两个 ResourceHandler，一个是用来处理请求路径\/webjars\/*<em>*<\/em>， 而另一个是\/**。<\/p><p>这里你可以注意一下方法最开始的判断语句，如果 this.resourceProperties.isAddMappings() 为 false，那么会直接返回，后续的两个 ResourceHandler 也不会被添加。<\/p><pre><code>   if (!this.resourceProperties.isAddMappings()) {\n      logger.debug(&quot;Default resource handling disabled&quot;);\n      return;\n   }\n<\/code><\/pre><p>​至此，有两个 ResourceHandler 被实例化且注册到了 Spirng 容器中，一个处理路径为\/webjars\/*<em>*<\/em> 的请求，另一个处理路径为 \/**的请求 。<\/p><p>同样，当第一次请求发生时，DispatcherServlet 中的 initHandlerMappings() 将会获取所有注册到 Spring 的 HandlerMapping 类型的实例，而 SimpleUrlHandlerMapping 恰好实现了 HandlerMapping 接口，这些 SimpleUrlHandlerMapping 类型的实例则会被写入到类成员变量 handlerMappings 中。<\/p><pre><code>private void initHandlerMappings(ApplicationContext context) {\n   this.handlerMappings = null;\n\/\/省略非关键代码\n   if (this.detectAllHandlerMappings) {\n      \/\/ Find all HandlerMappings in the ApplicationContext, including ancestor contexts.\n      Map&lt;String, HandlerMapping&gt; matchingBeans =\n            BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false);\n      if (!matchingBeans.isEmpty()) {\n         this.handlerMappings = new ArrayList&lt;&gt;(matchingBeans.values());\n         \/\/ We keep HandlerMappings in sorted order.\n         AnnotationAwareOrderComparator.sort(this.handlerMappings);\n      }\n   }\n   \/\/省略非关键代码\n}\n<\/code><\/pre><p>接着我们再来了解下被包装为 handlerMappings 的 ResourceHandler 是如何被 Spring 消费并处理的。<\/p><p>我们来回顾一下 DispatcherServlet 中的 doDispatch() 核心代码：<\/p><pre><code>protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        \/\/省略非关键代码\n         mappedHandler = getHandler(processedRequest);\n         if (mappedHandler == null) {\n            noHandlerFound(processedRequest, response);\n            return;\n         }\n         \/\/省略非关键代码\n}\n<\/code><\/pre><p>这里的 getHandler() 将会遍历成员变量 handlerMappings：<\/p><pre><code>protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {\n   if (this.handlerMappings != null) {\n      for (HandlerMapping mapping : this.handlerMappings) {\n         HandlerExecutionChain handler = mapping.getHandler(request);\n         if (handler != null) {\n            return handler;\n         }\n      }\n   }\n   return null;\n}\n<\/code><\/pre><p>因为此处有一个 SimpleUrlHandlerMapping，它会拦截所有路径的请求：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/4a\/4e\/4a4b314b45744ec2e194743e19d1204e.png?wh=615*119\" alt=\"\"><\/p><p>所以最终在 doDispatch() 的 getHandler() 将会获取到此 handler，从而 mappedHandler==null 条件不能得到满足，因而无法走到 noHandlerFound()，不会抛出 NoHandlerFoundException 异常，进而无法被后续的异常处理器进一步处理。<\/p><h3>问题修正<\/h3><p>那如何解决这个问题呢？还记得 WebMvcAutoConfiguration 类中 addResourceHandlers() 的前两行代码吗？如果 this.resourceProperties.isAddMappings() 为 false，那么此处直接返回，后续的两个 ResourceHandler 也不会被添加。<\/p><pre><code>public void addResourceHandlers(ResourceHandlerRegistry registry) {\n   if (!this.resourceProperties.isAddMappings()) {\n      logger.debug(&quot;Default resource handling disabled&quot;);\n      return;\n   }\n   \/\/省略非关键代码\n}\n<\/code><\/pre><p>其调用 ResourceProperties 中的 isAddMappings() 的代码如下：<\/p><pre><code>public boolean isAddMappings() {\n   return this.addMappings;\n}\n<\/code><\/pre><p>到这，答案也就呼之欲出了，增加两个配置文件如下：<\/p><pre><code>spring.resources.add-mappings=false\nspring.mvc.throwExceptionIfNoHandlerFound=true\n<\/code><\/pre><p>修改 MyExceptionHandler 的 @ExceptionHandler 为 NoHandlerFoundException 即可：<\/p><pre><code>@ExceptionHandler(NoHandlerFoundException.class)\n<\/code><\/pre><p>这个案例在真实的产线环境遇到的概率还是比较大的，知道如何解决是第一步，了解其内部原理则更为重要。而且当你进一步去研读代码后，你会发现这里的解决方案并不会只有这一种，而剩下的就留给你去探索了。<\/p><h2>重点回顾<\/h2><p>通过以上两个案例的介绍，相信你对 Spring MVC 的异常处理机制，已经有了进一步的了解，这里我们再次回顾下重点：<\/p><ul>\n<li>DispatcherServlet 类中的 doDispatch() 是整个 Servlet 处理的核心，它不仅实现了请求的分发，也提供了异常统一处理等等一系列功能；<\/li>\n<li>WebMvcConfigurationSupport 是 Spring Web 中非常核心的一个配置类，无论是异常处理器的包装注册（HandlerExceptionResolver），还是资源处理器的包装注册（SimpleUrlHandlerMapping），都是依靠这个类来完成的。<\/li>\n<\/ul><h2>思考题<\/h2><p>这节课的两个案例，在第一次发送请求的时候，会遍历对应的资源处理器和异常处理器，并注册到 DispatcherServlet 对应的类成员变量中，你知道它是如何被触发的吗？<\/p><p>期待你的思考，我们留言区见！<\/p>","footer_cover_data":{"img_url":"","mp_url":"","link_url":""},"article_cover_hidden":false,"column_is_experience":false,"is_required":true,"rate":{},"product_id":100077001,"like_count":15,"had_liked":false,"article_subtitle":"无","audio_download_url":"https:\/\/static001.geekbang.org\/resource\/audio\/56\/51\/56f3049c03ba11yyyy6540181b709a51.mp3","id":378676,"had_viewed":false,"article_title":"16｜Spring Exception 常见错误","column_bgcolor":"#F6F7FB","share":{"content":"Spring 开发老兵 10 年避坑心法","title":"傅健 · Spring编程常见错误50例","poster":"https:\/\/static001.geekbang.org\/resource\/image\/81\/cf\/81d9cef44e90ff4890d04b735fd135cf.jpg","cover":"https:\/\/static001.geekbang.org\/resource\/image\/82\/a2\/829d02f2fc0e10860d7b5401f2160ba2.jpg"},"is_video_preview":false,"article_summary":"解析 Spring MVC 的异常处理机制。","article_poster_wxlite":"https:\/\/static001.geekbang.org\/render\/screen\/78\/40\/785aab27204a6837b5747f6e70ddbf40.jpeg","column_sale_type":2,"article_features":0,"article_could_preview":false,"column_cover":"https:\/\/static001.geekbang.org\/resource\/image\/82\/a2\/829d02f2fc0e10860d7b5401f2160ba2.jpg","column_id":408,"audio_time_arr":{"m":"14","s":"36","h":"00"},"video_time":"","audio_title":"傅健-16修改","audio_md5":"56f3049c03ba11yyyy6540181b709a51","video_size":0,"text_read_percent":0,"comment_count":4,"cid":408,"article_sharetitle":"Spring Exception 常见错误","column_is_onboard":true,"article_cshort":"<p>你好，我是傅健。<\/p><p>今天，我们来学习 Spring 的异常处理机制。Spring 提供了一套健全的异常处理框架，以便我们在开发应用的时候对异常进行处理。但是，我们也会在使用的时候遇到一些麻烦，接下来我将通过两个典型的错误案例，带着你结合源码进行深入了解。<\/p><h2>案例 1：小心过滤器异常<\/h2><p>为了方便讲解，我们还是沿用之前在事务处理中用到的学生注册的案例，来讨论异常处理的问题：<\/p><pre><code>@Controller\n@Slf4j\npublic class StudentController {\n    public StudentController(){\n        System.out.println(&quot;construct&quot;);\n    }\n\n\n    @PostMapping(&quot;\/regStudent\/{name}&quot;)\n    @ResponseBody\n    public String saveUser(String name) throws Exception {\n        System.out.println(&quot;......用户注册成功&quot;);\n        return &quot;success&quot;;\n    }\n}\n<\/code><\/pre><p>​为了保证安全，这里需要给请求加一个保护，通过验证 Token 的方式来验证请求的合法性。这个 Token 需要在每次发送请求的时候带在请求的 header 中，header 的 key 是 Token。<\/p><p>为了校验这个 Token，我们引入了一个 Filter 来处理这个校验工作，这里我使用了一个最简单的 Token：111111。<\/p><p>当 Token 校验失败时，就会抛出一个自定义的 NotAllowException，交由 Spring 处理：<\/p><pre><code>@WebFilter\n@Component\npublic class PermissionFilter implements Filter {\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        HttpServletRequest httpServletRequest = (HttpServletRequest) request;\n        String token = httpServletRequest.getHeader(&quot;token&quot;);\n\n\n        if (!&quot;111111&quot;.equals(token)) {\n            System.out.println(&quot;throw NotAllowException&quot;);\n            throw new NotAllowException();\n        }\n        chain.doFilter(request, response);\n    }\n\n\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n    }\n\n\n    @Override\n    public void destroy() {\n    }\n<\/code><\/pre><p>NotAllowException 就是一个简单的 RuntimeException 的子类：<\/p><pre><code>public class NotAllowException extends RuntimeException {\n    public NotAllowException() {\n        super();\n    }\n}\n<\/code><\/pre><p>同时，新增了一个 RestControllerAdvice 来处理这个异常，处理方式也很简单，就是返回一个 403 的 resultCode：<\/p>","video_width":0,"column_could_sub":true,"article_ctime":1622131200,"score":"31622131200","video_media_map":{},"video_preview":{},"video":0,"video_time_arr":{"m":"","s":"","h":""},"video_total_seconds":0},"extra":{},"error":{}}