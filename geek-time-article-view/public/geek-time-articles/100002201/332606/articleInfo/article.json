{"code":0,"data":{"video_id":"","sku":"100002201","video_cover":"","author_name":"陈皓","text_read_version":0,"audio_size":6833167,"article_cover":"https:\/\/static001.geekbang.org\/resource\/image\/a9\/c3\/a919b5d1fa2e0e6yy0767623614447c3.jpg","subtitles":{},"product_type":"c1","audio_url":"https:\/\/res001.geekbang.org\/media\/audio\/7d\/30\/7da2e4fb3cb8ef31a4f491c8ab3f2830\/ld\/ld.m3u8","chapter_id":"0","column_had_sub":true,"audio_dubber":"杨超","is_finished":false,"inline_video_subtitles":{},"like":{"had_done":false,"count":8},"neighbors":{"left":{"id":332605,"article_title":"110 | Go编程模式：委托和反转控制"},"right":{"id":332607,"article_title":"112 | Go 编程模式：Go Generation"}},"audio_time":"00:07:08","video_height":0,"rate_percent":0,"article_content":"<p>你好，我是陈皓，网名左耳朵耗子。<\/p><p>这节课，我们来学习一下函数式编程中非常重要的Map、Reduce、Filter这三种操作。这三种操作可以让我们轻松灵活地进行一些数据处理，毕竟，我们的程序大多数情况下都在倒腾数据。尤其是对于一些需要统计的业务场景来说，Map、Reduce、Filter是非常通用的玩法。<\/p><p>话不多说，我们先来看几个例子。<\/p><h2>基本示例<\/h2><h3>Map示例<\/h3><p>在下面的程序代码中，我写了两个Map函数，这两个函数需要两个参数：<\/p><ul>\n<li>一个是字符串数组 <code>[]<\/code> <code>string<\/code>，说明需要处理的数据是一个字符串；<\/li>\n<li>另一个是一个函数func(s string) string 或 func(s string) int。<\/li>\n<\/ul><pre><code>func MapStrToStr(arr []string, fn func(s string) string) []string {\n    var newArray = []string{}\n    for _, it := range arr {\n        newArray = append(newArray, fn(it))\n    }\n    return newArray\n}\n\nfunc MapStrToInt(arr []string, fn func(s string) int) []int {\n    var newArray = []int{}\n    for _, it := range arr {\n        newArray = append(newArray, fn(it))\n    }\n    return newArray\n}\n<\/code><\/pre><p>整个Map函数的运行逻辑都很相似，函数体都是在遍历第一个参数的数组，然后，调用第二个参数的函数，把它的值组合成另一个数组返回。<\/p><p>因此，我们就可以这样使用这两个函数：<\/p><pre><code>var list = []string{&quot;Hao&quot;, &quot;Chen&quot;, &quot;MegaEase&quot;}\n\nx := MapStrToStr(list, func(s string) string {\n    return strings.ToUpper(s)\n})\nfmt.Printf(&quot;%v\\n&quot;, x)\n\/\/[&quot;HAO&quot;, &quot;CHEN&quot;, &quot;MEGAEASE&quot;]\n\ny := MapStrToInt(list, func(s string) int {\n    return len(s)\n})\nfmt.Printf(&quot;%v\\n&quot;, y)\n\/\/[3, 4, 8]\n<\/code><\/pre><p>可以看到，我们给第一个 <code>MapStrToStr()<\/code>  传了功能为“转大写”的函数，于是出来的数组就成了全大写的，给<code>MapStrToInt()<\/code> 传的是计算长度，所以出来的数组是每个字符串的长度。<\/p><p>我们再来看一下Reduce和Filter的函数是什么样的。<\/p><!-- [[[read_end]]] --><h3>Reduce 示例<\/h3><pre><code>func Reduce(arr []string, fn func(s string) int) int {\n    sum := 0\n    for _, it := range arr {\n        sum += fn(it)\n    }\n    return sum\n}\n\nvar list = []string{&quot;Hao&quot;, &quot;Chen&quot;, &quot;MegaEase&quot;}\n\nx := Reduce(list, func(s string) int {\n    return len(s)\n})\nfmt.Printf(&quot;%v\\n&quot;, x)\n\/\/ 15\n<\/code><\/pre><h3>Filter示例<\/h3><pre><code>func Filter(arr []int, fn func(n int) bool) []int {\n    var newArray = []int{}\n    for _, it := range arr {\n        if fn(it) {\n            newArray = append(newArray, it)\n        }\n    }\n    return newArray\n}\n\nvar intset = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nout := Filter(intset, func(n int) bool {\n   return n%2 == 1\n})\nfmt.Printf(&quot;%v\\n&quot;, out)\n\nout = Filter(intset, func(n int) bool {\n    return n &gt; 5\n})\nfmt.Printf(&quot;%v\\n&quot;, out)\n<\/code><\/pre><p>为了方便你理解呢，我给你展示一张图，它形象地说明了Map-Reduce的业务语义，在数据处理中非常有用。<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/15\/56\/1506b63044071bfa5c214a725a9caf56.png?wh=794*442\" alt=\"\"><\/p><h2>业务示例<\/h2><p>通过刚刚的一些示例，你现在应该有点明白了，Map、Reduce、Filter只是一种控制逻辑，真正的业务逻辑是以传给它们的数据和函数来定义的。<\/p><p>是的，这是一个很经典的“业务逻辑”和“控制逻辑”分离解耦的编程模式。<\/p><p>接下来，我们来看一个有业务意义的代码，来进一步帮助你理解什么叫“控制逻辑”与“业务逻辑”分离。<\/p><h3>员工信息<\/h3><p>首先，我们有一个员工对象和一些数据：<\/p><pre><code>type Employee struct {\n    Name     string\n    Age      int\n    Vacation int\n    Salary   int\n}\n\nvar list = []Employee{\n    {&quot;Hao&quot;, 44, 0, 8000},\n    {&quot;Bob&quot;, 34, 10, 5000},\n    {&quot;Alice&quot;, 23, 5, 9000},\n    {&quot;Jack&quot;, 26, 0, 4000},\n    {&quot;Tom&quot;, 48, 9, 7500},\n    {&quot;Marry&quot;, 29, 0, 6000},\n    {&quot;Mike&quot;, 32, 8, 4000},\n}\n<\/code><\/pre><h3>相关的Reduce、Fitler函数<\/h3><p>然后，我们有下面的几个函数：<\/p><pre><code>func EmployeeCountIf(list []Employee, fn func(e *Employee) bool) int {\n    count := 0\n    for i, _ := range list {\n        if fn(&amp;list[i]) {\n            count += 1\n        }\n    }\n    return count\n}\n\nfunc EmployeeFilterIn(list []Employee, fn func(e *Employee) bool) []Employee {\n    var newList []Employee\n    for i, _ := range list {\n        if fn(&amp;list[i]) {\n            newList = append(newList, list[i])\n        }\n    }\n    return newList\n}\n\nfunc EmployeeSumIf(list []Employee, fn func(e *Employee) int) int {\n    var sum = 0\n    for i, _ := range list {\n        sum += fn(&amp;list[i])\n    }\n    return sum\n}\n<\/code><\/pre><p>简单说明一下：<\/p><ul>\n<li><code>EmployeeConutIf<\/code> 和 <code>EmployeeSumIf<\/code> 分别用于统计满足某个条件的个数或总数。它们都是Filter + Reduce的语义。<\/li>\n<li><code>EmployeeFilterIn<\/code> 就是按某种条件过滤，就是Fitler的语义。<\/li>\n<\/ul><h3>各种自定义的统计示例<\/h3><p>于是，我们就可以有接下来的代码了。<\/p><p><strong>1.统计有多少员工大于40岁<\/strong><\/p><pre><code>old := EmployeeCountIf(list, func(e *Employee) bool {\n    return e.Age &gt; 40\n})\nfmt.Printf(&quot;old people: %d\\n&quot;, old)\n\/\/old people: 2\n<\/code><\/pre><p><strong>2.统计有多少员工的薪水大于6000<\/strong><\/p><pre><code>high_pay := EmployeeCountIf(list, func(e *Employee) bool {\n    return e.Salary &gt; 6000\n})\nfmt.Printf(&quot;High Salary people: %d\\n&quot;, high_pay)\n\/\/High Salary people: 4\n<\/code><\/pre><p><strong>3.列出有没有休假的员工<\/strong><\/p><pre><code>no_vacation := EmployeeFilterIn(list, func(e *Employee) bool {\n    return e.Vacation == 0\n})\nfmt.Printf(&quot;People no vacation: %v\\n&quot;, no_vacation)\n\/\/People no vacation: [{Hao 44 0 8000} {Jack 26 0 4000} {Marry 29 0 6000}]\n<\/code><\/pre><p><strong>4.统计所有员工的薪资总和<\/strong><\/p><pre><code>total_pay := EmployeeSumIf(list, func(e *Employee) int {\n    return e.Salary\n})\n\nfmt.Printf(&quot;Total Salary: %d\\n&quot;, total_pay)\n\/\/Total Salary: 43500\n<\/code><\/pre><p><strong>5.统计30岁以下员工的薪资总和<\/strong><\/p><pre><code>younger_pay := EmployeeSumIf(list, func(e *Employee) int {\n    if e.Age &lt; 30 {\n        return e.Salary\n    } \n    return 0\n})\n<\/code><\/pre><h2>泛型Map-Reduce<\/h2><p>刚刚的Map-Reduce都因为要处理数据的类型不同，而需要写出不同版本的Map-Reduce，虽然它们的代码看上去是很类似的。所以，这里就要提到泛型编程了。<\/p><h3>简单版 Generic Map<\/h3><p>我在写这节课的时候，Go语言还不支持泛型（注：Go开发团队技术负责人Russ Cox在2012年11月21golang-dev上的mail确认了Go泛型将在Go 1.18版本落地，时间是2022年2月）。所以，目前的Go语言的泛型只能用 <code>interface{}<\/code> + <code>reflect<\/code>来完成。<code>interface{}<\/code> 可以理解为C中的 <code>void*<\/code>、Java中的 <code>Object<\/code> ，<code>reflect<\/code>是Go的反射机制包，作用是在运行时检查类型。<\/p><p>下面，我们来看一下，一个非常简单的、不做任何类型检查的泛型的Map函数怎么写。<\/p><pre><code>func Map(data interface{}, fn interface{}) []interface{} {\n    vfn := reflect.ValueOf(fn)\n    vdata := reflect.ValueOf(data)\n    result := make([]interface{}, vdata.Len())\n\n    for i := 0; i &lt; vdata.Len(); i++ {\n        result[i] = vfn.Call([]reflect.Value{vdata.Index(i)})[0].Interface()\n    }\n    return result\n}\n<\/code><\/pre><p>我来简单解释下这段代码。<\/p><ul>\n<li>首先，我们通过 <code>reflect.ValueOf()<\/code> 获得 <code>interface{}<\/code> 的值，其中一个是数据 <code>vdata<\/code>，另一个是函数 <code>vfn<\/code>。<\/li>\n<li>然后，通过 <code>vfn.Call()<\/code> 方法调用函数，通过 <code>[]refelct.Value{vdata.Index(i)}<\/code>获得数据。<\/li>\n<\/ul><p>Go语言中的反射的语法有点令人费解，不过，简单看一下手册，还是能够读懂的。反射不是这节课的重点，我就不讲了。如果你还不太懂这些基础知识，课下可以学习下相关的教程。<\/p><p>于是，我们就可以有下面的代码——不同类型的数据可以使用相同逻辑的<code>Map()<\/code>代码。<\/p><pre><code>square := func(x int) int {\n  return x * x\n}\nnums := []int{1, 2, 3, 4}\n\nsquared_arr := Map(nums,square)\nfmt.Println(squared_arr)\n\/\/[1 4 9 16]\n\n\n\nupcase := func(s string) string {\n  return strings.ToUpper(s)\n}\nstrs := []string{&quot;Hao&quot;, &quot;Chen&quot;, &quot;MegaEase&quot;}\nupstrs := Map(strs, upcase);\nfmt.Println(upstrs)\n\/\/[HAO CHEN MEGAEASE]\n<\/code><\/pre><p>但是，因为反射是运行时的事，所以，如果类型出问题的话，就会有运行时的错误。比如：<\/p><pre><code>x := Map(5, 5)\nfmt.Println(x)\n<\/code><\/pre><p>代码可以很轻松地编译通过，但是在运行时却出问题了，而且还是panic错误……<\/p><pre><code>panic: reflect: call of reflect.Value.Len on int Value\n\ngoroutine 1 [running]:\nreflect.Value.Len(0x10b5240, 0x10eeb58, 0x82, 0x10716bc)\n        \/usr\/local\/Cellar\/go\/1.15.3\/libexec\/src\/reflect\/value.go:1162 +0x185\nmain.Map(0x10b5240, 0x10eeb58, 0x10b5240, 0x10eeb60, 0x1, 0x14, 0x0)\n        \/Users\/chenhao\/...\/map.go:12 +0x16b\nmain.main()\n        \/Users\/chenhao\/...\/map.go:42 +0x465\nexit status 2\n<\/code><\/pre><h3>健壮版的Generic Map<\/h3><p>所以，如果要写一个健壮的程序，对于这种用<code>interface{}<\/code> 的“过度泛型”，就需要我们自己来做类型检查。来看一个有类型检查的Map代码：<\/p><pre><code>func Transform(slice, function interface{}) interface{} {\n  return transform(slice, function, false)\n}\n\nfunc TransformInPlace(slice, function interface{}) interface{} {\n  return transform(slice, function, true)\n}\n\nfunc transform(slice, function interface{}, inPlace bool) interface{} {\n \n  \/\/check the `slice` type is Slice\n  sliceInType := reflect.ValueOf(slice)\n  if sliceInType.Kind() != reflect.Slice {\n    panic(&quot;transform: not slice&quot;)\n  }\n\n  \/\/check the function signature\n  fn := reflect.ValueOf(function)\n  elemType := sliceInType.Type().Elem()\n  if !verifyFuncSignature(fn, elemType, nil) {\n    panic(&quot;trasform: function must be of type func(&quot; + sliceInType.Type().Elem().String() + &quot;) outputElemType&quot;)\n  }\n\n  sliceOutType := sliceInType\n  if !inPlace {\n    sliceOutType = reflect.MakeSlice(reflect.SliceOf(fn.Type().Out(0)), sliceInType.Len(), sliceInType.Len())\n  }\n  for i := 0; i &lt; sliceInType.Len(); i++ {\n    sliceOutType.Index(i).Set(fn.Call([]reflect.Value{sliceInType.Index(i)})[0])\n  }\n  return sliceOutType.Interface()\n\n}\n\nfunc verifyFuncSignature(fn reflect.Value, types ...reflect.Type) bool {\n\n  \/\/Check it is a funciton\n  if fn.Kind() != reflect.Func {\n    return false\n  }\n  \/\/ NumIn() - returns a function type's input parameter count.\n  \/\/ NumOut() - returns a function type's output parameter count.\n  if (fn.Type().NumIn() != len(types)-1) || (fn.Type().NumOut() != 1) {\n    return false\n  }\n  \/\/ In() - returns the type of a function type's i'th input parameter.\n  for i := 0; i &lt; len(types)-1; i++ {\n    if fn.Type().In(i) != types[i] {\n      return false\n    }\n  }\n  \/\/ Out() - returns the type of a function type's i'th output parameter.\n  outType := types[len(types)-1]\n  if outType != nil &amp;&amp; fn.Type().Out(0) != outType {\n    return false\n  }\n  return true\n}\n<\/code><\/pre><p>代码一下子就复杂起来了，可见，复杂的代码都是在处理异常的地方。我不打算Walk through 所有的代码，别看代码多，还是可以读懂的。<\/p><p>我来列一下代码中的几个要点。<\/p><ol>\n<li>代码中没有使用Map函数，因为和数据结构有含义冲突的问题，所以使用<code>Transform<\/code>，这个来源于 C++ STL库中的命名。<\/li>\n<li>有两个版本的函数，一个是返回一个全新的数组  <code>Transform()<\/code>，一个是“就地完成” <code>TransformInPlace()<\/code>。<\/li>\n<li>在主函数中，用 <code>Kind()<\/code> 方法检查了数据类型是不是 Slice，函数类型是不是Func。<\/li>\n<li>检查函数的参数和返回类型是通过 <code>verifyFuncSignature()<\/code> 来完成的：<code>NumIn()<\/code>用来检查函数的“入参”；<code>NumOut()<\/code>  ：用来检查函数的“返回值”。<\/li>\n<li>如果需要新生成一个Slice，会使用 <code>reflect.MakeSlice()<\/code> 来完成。<\/li>\n<\/ol><p>好了，有了这段代码，我们的代码就很可以很开心地使用了：<\/p><p>1.可以用于字符串数组：<\/p><pre><code>list := []string{&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;}\nresult := Transform(list, func(a string) string{\n    return a +a +a\n})\n\/\/{&quot;111&quot;,&quot;222&quot;,&quot;333&quot;,&quot;444&quot;,&quot;555&quot;,&quot;666&quot;}\n<\/code><\/pre><p>2.可以用于整形数组：<\/p><pre><code>list := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\nTransformInPlace(list, func (a int) int {\n  return a*3\n})\n\/\/{3, 6, 9, 12, 15, 18, 21, 24, 27}\n<\/code><\/pre><p>3.可以用于结构体：<\/p><pre><code>var list = []Employee{\n    {&quot;Hao&quot;, 44, 0, 8000},\n    {&quot;Bob&quot;, 34, 10, 5000},\n    {&quot;Alice&quot;, 23, 5, 9000},\n    {&quot;Jack&quot;, 26, 0, 4000},\n    {&quot;Tom&quot;, 48, 9, 7500},\n}\n\nresult := TransformInPlace(list, func(e Employee) Employee {\n    e.Salary += 1000\n    e.Age += 1\n    return e\n})\n<\/code><\/pre><h3>健壮版的 Generic Reduce<\/h3><p>同样，泛型版的 Reduce 代码如下：<\/p><pre><code>func Reduce(slice, pairFunc, zero interface{}) interface{} {\n  sliceInType := reflect.ValueOf(slice)\n  if sliceInType.Kind() != reflect.Slice {\n    panic(&quot;reduce: wrong type, not slice&quot;)\n  }\n\n  len := sliceInType.Len()\n  if len == 0 {\n    return zero\n  } else if len == 1 {\n    return sliceInType.Index(0)\n  }\n\n  elemType := sliceInType.Type().Elem()\n  fn := reflect.ValueOf(pairFunc)\n  if !verifyFuncSignature(fn, elemType, elemType, elemType) {\n    t := elemType.String()\n    panic(&quot;reduce: function must be of type func(&quot; + t + &quot;, &quot; + t + &quot;) &quot; + t)\n  }\n\n  var ins [2]reflect.Value\n  ins[0] = sliceInType.Index(0)\n  ins[1] = sliceInType.Index(1)\n  out := fn.Call(ins[:])[0]\n\n  for i := 2; i &lt; len; i++ {\n    ins[0] = out\n    ins[1] = sliceInType.Index(i)\n    out = fn.Call(ins[:])[0]\n  }\n  return out.Interface()\n}\n<\/code><\/pre><h3>健壮版的 Generic Filter<\/h3><p>同样，泛型版的 Filter 代码如下（同样分是否“就地计算”的两个版本）：<\/p><pre><code>func Filter(slice, function interface{}) interface{} {\n  result, _ := filter(slice, function, false)\n  return result\n}\n\nfunc FilterInPlace(slicePtr, function interface{}) {\n  in := reflect.ValueOf(slicePtr)\n  if in.Kind() != reflect.Ptr {\n    panic(&quot;FilterInPlace: wrong type, &quot; +\n      &quot;not a pointer to slice&quot;)\n  }\n  _, n := filter(in.Elem().Interface(), function, true)\n  in.Elem().SetLen(n)\n}\n\nvar boolType = reflect.ValueOf(true).Type()\n\nfunc filter(slice, function interface{}, inPlace bool) (interface{}, int) {\n\n  sliceInType := reflect.ValueOf(slice)\n  if sliceInType.Kind() != reflect.Slice {\n    panic(&quot;filter: wrong type, not a slice&quot;)\n  }\n\n  fn := reflect.ValueOf(function)\n  elemType := sliceInType.Type().Elem()\n  if !verifyFuncSignature(fn, elemType, boolType) {\n    panic(&quot;filter: function must be of type func(&quot; + elemType.String() + &quot;) bool&quot;)\n  }\n\n  var which []int\n  for i := 0; i &lt; sliceInType.Len(); i++ {\n    if fn.Call([]reflect.Value{sliceInType.Index(i)})[0].Bool() {\n      which = append(which, i)\n    }\n  }\n\n  out := sliceInType\n\n  if !inPlace {\n    out = reflect.MakeSlice(sliceInType.Type(), len(which), len(which))\n  }\n  for i := range which {\n    out.Index(i).Set(sliceInType.Index(which[i]))\n  }\n\n  return out.Interface(), len(which)\n}\n<\/code><\/pre><h2>后记<\/h2><p>最后，还有几个未尽事宜：<\/p><ol>\n<li>使用反射来做这些东西会有一个问题，<strong>那就是代码的性能会很差。所以，上面的代码不能用在需要高性能的地方<\/strong>。怎么解决这个问题，我会在下节课给你介绍下。<\/li>\n<li>这节课中的代码大量地参考了 Rob Pike的版本，你可以点击这个链接查看：  <a href=\"https:\/\/github.com\/robpike\/filter\">https:\/\/github.com\/robpike\/filter<\/a>。<\/li>\n<li>其实，在全世界范围内，有大量的程序员都在问Go语言官方什么时候在标准库中支持 Map、Reduce。Rob Pike说，这种东西难写吗？还要我们官方来帮你们写吗？这种代码我多少年前就写过了，但是，我一次都没有用过，我还是喜欢用“For循环”，我觉得你最好也跟我一起用 “For循环”。<\/li>\n<\/ol><p>我个人觉得，Map、Reduce在数据处理的时候还是很有用的，Rob Pike可能平时也不怎么写“业务逻辑”的代码，所以，他可能也不太了解业务的变化有多么频繁……<\/p><p>当然，好还是不好，由你来判断，但多学一些编程模式，一定是对自己很有帮助的。<\/p><p>好了，这节课就到这里。如果你觉得今天的内容对你有所帮助，欢迎你帮我分享给更多人。<\/p>","footer_cover_data":{"img_url":"","mp_url":"","link_url":""},"article_cover_hidden":false,"column_is_experience":false,"is_required":false,"rate":{},"product_id":100002201,"like_count":22,"had_liked":false,"article_subtitle":"","audio_download_url":"https:\/\/static001.geekbang.org\/resource\/audio\/7d\/30\/7da2e4fb3cb8ef31a4f491c8ab3f2830.mp3","id":332606,"had_viewed":false,"article_title":"111 | Go 编程模式：Map-Reduce","column_bgcolor":"#6091b2","share":{"content":"左耳朵耗子的专栏，20年骨灰级程序员，专栏涵盖程序员练级攻略、全栈程序员的体系化学习路线与进阶底图。专栏已有32000人加入学习，可以说是程序员必备宝典。","title":"陈皓 · 左耳听风","poster":"https:\/\/static001.geekbang.org\/resource\/image\/08\/c1\/084b2e8b8757ccb8401d6e6501ef8bc1.jpg","cover":"https:\/\/static001.geekbang.org\/resource\/image\/21\/da\/216b472de3f9027371576e107601c2da.jpg"},"is_video_preview":false,"article_summary":"函数式编程中非常重要的Map、Reduce、Filter这三种操作可以帮助我们更加轻松灵活地进行一些数据处理。","article_poster_wxlite":"https:\/\/static001.geekbang.org\/render\/screen\/b5\/cf\/b52ccfb3ae2fa5f1a662eb9be53435cf.jpeg","column_sale_type":2,"article_features":0,"article_could_preview":false,"column_cover":"https:\/\/static001.geekbang.org\/resource\/image\/21\/da\/216b472de3f9027371576e107601c2da.jpg","column_id":48,"audio_time_arr":{"m":"07","s":"08","h":"00"},"video_time":"","audio_title":"6.28 杨超 111_01.MP3","audio_md5":"7da2e4fb3cb8ef31a4f491c8ab3f2830","video_size":0,"text_read_percent":0,"comment_count":4,"cid":48,"article_sharetitle":"Go 编程模式：Map-Reduce","column_is_onboard":true,"article_cshort":"<p>你好，我是陈皓，网名左耳朵耗子。<\/p><p>这节课，我们来学习一下函数式编程中非常重要的Map、Reduce、Filter这三种操作。这三种操作可以让我们轻松灵活地进行一些数据处理，毕竟，我们的程序大多数情况下都在倒腾数据。尤其是对于一些需要统计的业务场景来说，Map、Reduce、Filter是非常通用的玩法。<\/p><p>话不多说，我们先来看几个例子。<\/p><h2>基本示例<\/h2><h3>Map示例<\/h3><p>在下面的程序代码中，我写了两个Map函数，这两个函数需要两个参数：<\/p><ul>\n<li>一个是字符串数组 <code>[]<\/code> <code>string<\/code>，说明需要处理的数据是一个字符串；<\/li>\n<li>另一个是一个函数func(s string) string 或 func(s string) int。<\/li>\n<\/ul><pre><code>func MapStrToStr(arr []string, fn func(s string) string) []string {\n    var newArray = []string{}\n    for _, it := range arr {\n        newArray = append(newArray, fn(it))\n    }\n    return newArray\n}\n\nfunc MapStrToInt(arr []string, fn func(s string) int) []int {\n    var newArray = []int{}\n    for _, it := range arr {\n        newArray = append(newArray, fn(it))\n    }\n    return newArray\n}\n<\/code><\/pre><p>整个Map函数的运行逻辑都很相似，函数体都是在遍历第一个参数的数组，然后，调用第二个参数的函数，把它的值组合成另一个数组返回。<\/p><p>因此，我们就可以这样使用这两个函数：<\/p><pre><code>var list = []string{&quot;Hao&quot;, &quot;Chen&quot;, &quot;MegaEase&quot;}\n\nx := MapStrToStr(list, func(s string) string {\n    return strings.ToUpper(s)\n})\nfmt.Printf(&quot;%v\\n&quot;, x)\n\/\/[&quot;HAO&quot;, &quot;CHEN&quot;, &quot;MEGAEASE&quot;]\n\ny := MapStrToInt(list, func(s string) int {\n    return len(s)\n})\nfmt.Printf(&quot;%v\\n&quot;, y)\n\/\/[3, 4, 8]\n<\/code><\/pre><p>可以看到，我们给第一个 <code>MapStrToStr()<\/code>  传了功能为“转大写”的函数，于是出来的数组就成了全大写的，给<code>MapStrToInt()<\/code> 传的是计算长度，所以出来的数组是每个字符串的长度。<\/p><p>我们再来看一下Reduce和Filter的函数是什么样的。<\/p>","video_width":0,"column_could_sub":true,"article_ctime":1610618640,"score":"121610618640","video_media_map":{},"video_preview":{},"video":0,"video_time_arr":{"m":"","s":"","h":""},"video_total_seconds":0},"extra":{},"error":{}}