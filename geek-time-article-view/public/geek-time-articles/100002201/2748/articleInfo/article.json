{"code":0,"data":{"video_id":"","sku":"100002201","video_cover":"","author_name":"陈皓","text_read_version":0,"audio_size":3830350,"article_cover":"https:\/\/static001.geekbang.org\/resource\/image\/fe\/30\/fe6e08065318d0f6faa3284f8d55e130.jpg","subtitles":{},"product_type":"c1","audio_url":"https:\/\/res001.geekbang.org\/media\/audio\/dd\/5f\/dd0dbd23bee79121a6db943yy182b15f\/ld\/ld.m3u8","chapter_id":"0","column_had_sub":true,"audio_dubber":"杨超","is_finished":false,"inline_video_subtitles":{},"like":{"had_done":false,"count":122},"neighbors":{"left":{"id":2741,"article_title":"36 | 编程范式游记（7）- 基于原型的编程范式"},"right":{"id":2751,"article_title":"38 | 编程范式游记（9）- 编程的本质"}},"audio_time":"00:04:00","video_height":0,"rate_percent":0,"article_content":"<p>你好，我是陈皓，网名左耳朵耗子。<\/p>\n<p>我们再来看Go语言这个模式，Go语言的这个模式挺好玩儿的。声明一个struct，跟C很一样，然后直接把这个struct类型放到另一个struct里。<\/p>\n<h1>委托的简单示例<\/h1>\n<p>我们来看几个示例：<\/p>\n<pre><code>type Widget struct {\n    X, Y int\n}\n\ntype Label struct {\n    Widget        \/\/ Embedding (delegation)\n    Text   string \/\/ Aggregation\n    X int         \/\/ Override \n}\n\nfunc (label Label) Paint() {\n\t\/\/ [0xc4200141e0] - Label.Paint(&quot;State&quot;)\n    fmt.Printf(&quot;[%p] - Label.Paint(%q)\\n&quot;, \n    \t&amp;label, label.Text)\n}\n<\/code><\/pre>\n<p>由上面可知：<\/p>\n<ul>\n<li>\n<p>我们声明了一个 <code>Widget<\/code>，其有 <code>X<\/code>和<code>Y<\/code>；<\/p>\n<\/li>\n<li>\n<p>然后用它来声明一个 <code>Label<\/code>，直接把 <code>Widget<\/code> 委托进去；<\/p>\n<\/li>\n<li>\n<p>然后再给 <code>Label<\/code> 声明并实现了一个 <code>Paint()<\/code> 方法。<\/p>\n<\/li>\n<\/ul>\n<p>于是，我们就可以这样编程了：<\/p>\n<pre><code>label := Label{Widget{10, 10}, &quot;State&quot;, 100}\n\n\/\/ X=100, Y=10, Text=State, Widget.X=10\nfmt.Printf(&quot;X=%d, Y=%d, Text=%s Widget.X=%d\\n&quot;, \n\tlabel.X, label.Y, label.Text, \n\tlabel.Widget.X)\nfmt.Println()\n\/\/ {Widget:{X:10 Y:10} Text:State X:100} \n\/\/ {{10 10} State 100}\nfmt.Printf(&quot;%+v\\n%v\\n&quot;, label, label)\n\nlabel.Paint()\n<\/code><\/pre>\n<p>我们可以看到，如果有成员变量重名，则需要手动地解决冲突。<\/p>\n<!-- [[[read_end]]] -->\n<p>我们继续扩展代码。<\/p>\n<p>先来一个 <code>Button<\/code>：<\/p>\n<pre><code>type Button struct {\n    Label \/\/ Embedding (delegation)\n}\n \nfunc NewButton(x, y int, text string) Button {\n    return Button{Label{Widget{x, y}, text, x}}\n}\nfunc (button Button) Paint() { \/\/ Override\n    fmt.Printf(&quot;[%p] - Button.Paint(%q)\\n&quot;, \n    \t&amp;button, button.Text)\n}\nfunc (button Button) Click() {\n    fmt.Printf(&quot;[%p] - Button.Click()\\n&quot;, &amp;button)\n}\n<\/code><\/pre>\n<p>再来一个 <code>ListBox<\/code>：<\/p>\n<pre><code>type ListBox struct {\n    Widget          \/\/ Embedding (delegation)\n    Texts  []string \/\/ Aggregation\n    Index  int      \/\/ Aggregation\n}\nfunc (listBox ListBox) Paint() {\n    fmt.Printf(&quot;[%p] - ListBox.Paint(%q)\\n&quot;, \n    \t&amp;listBox, listBox.Texts)\n}\nfunc (listBox ListBox) Click() {\n    fmt.Printf(&quot;[%p] - ListBox.Click()\\n&quot;, &amp;listBox)\n}\n<\/code><\/pre>\n<p>然后，声明两个接口用于多态：<\/p>\n<pre><code>type Painter interface {\n    Paint()\n}\n\ntype Clicker interface {\n    Click()\n}\n<\/code><\/pre>\n<p>于是我们就可以这样泛型地使用（注意其中的两个for循环）：<\/p>\n<pre><code>button1 := Button{Label{Widget{10, 70}, &quot;OK&quot;, 10}}\nbutton2 := NewButton(50, 70, &quot;Cancel&quot;)\nlistBox := ListBox{Widget{10, 40}, \n    []string{&quot;AL&quot;, &quot;AK&quot;, &quot;AZ&quot;, &quot;AR&quot;}, 0}\n\nfmt.Println()\n\/\/[0xc4200142d0] - Label.Paint(&quot;State&quot;)\n\/\/[0xc420014300] - ListBox.Paint([&quot;AL&quot; &quot;AK&quot; &quot;AZ&quot; &quot;AR&quot;])\n\/\/[0xc420014330] - Button.Paint(&quot;OK&quot;)\n\/\/[0xc420014360] - Button.Paint(&quot;Cancel&quot;)\nfor _, painter := range []Painter{label, listBox, button1, button2} {\n\tpainter.Paint()\n}\n\nfmt.Println()\n\/\/[0xc420014450] - ListBox.Click()\n\/\/[0xc420014480] - Button.Click()\n\/\/[0xc4200144b0] - Button.Click()\nfor _, widget := range []interface{}{label, listBox, button1, button2} {\n    if clicker, ok := widget.(Clicker); ok {\n    \tclicker.Click()\n    }\n}\n<\/code><\/pre>\n<h1>一个 Undo 的委托重构<\/h1>\n<p>上面这个是 Go 语言中的委托和接口多态的编程方式，其实是面向对象和原型编程综合的玩法。这个玩法可不可以玩得更有意思呢？这是可以的。<\/p>\n<p>首先，我们先声明一个数据容器，其中有 <code>Add()<\/code>、 <code>Delete()<\/code> 和 <code>Contains()<\/code> 方法。还有一个转字符串的方法。<\/p>\n<pre><code>type IntSet struct {\n    data map[int]bool\n}\n\nfunc NewIntSet() IntSet {\n    return IntSet{make(map[int]bool)}\n}\n\nfunc (set *IntSet) Add(x int) {\n    set.data[x] = true\n}\n\nfunc (set *IntSet) Delete(x int) {\n    delete(set.data, x)\n}\n\nfunc (set *IntSet) Contains(x int) bool {\n    return set.data[x]\n}\n\nfunc (set *IntSet) String() string { \/\/ Satisfies fmt.Stringer interface\n    if len(set.data) == 0 {\n        return &quot;{}&quot;\n    }\n    ints := make([]int, 0, len(set.data))\n    for i := range set.data {\n        ints = append(ints, i)\n    }\n    sort.Ints(ints)\n    parts := make([]string, 0, len(ints))\n    for _, i := range ints {\n        parts = append(parts, fmt.Sprint(i))\n    }\n    return &quot;{&quot; + strings.Join(parts, &quot;,&quot;) + &quot;}&quot;\n}\n<\/code><\/pre>\n<p>我们如下使用这个数据容器：<\/p>\n<pre><code>ints := NewIntSet()\nfor _, i := range []int{1, 3, 5, 7} {\n    ints.Add(i)\n    fmt.Println(ints)\n}\nfor _, i := range []int{1, 2, 3, 4, 5, 6, 7} {\n    fmt.Print(i, ints.Contains(i), &quot; &quot;)\n    ints.Delete(i)\n    fmt.Println(ints)\n}\n<\/code><\/pre>\n<p>这个数据容器平淡无奇，我们想给它加一个Undo的功能。我们可以这样来做：<\/p>\n<pre><code>type UndoableIntSet struct { \/\/ Poor style\n    IntSet    \/\/ Embedding (delegation)\n    functions []func()\n}\n\nfunc NewUndoableIntSet() UndoableIntSet {\n    return UndoableIntSet{NewIntSet(), nil}\n}\n\nfunc (set *UndoableIntSet) Add(x int) { \/\/ Override\n    if !set.Contains(x) {\n        set.data[x] = true\n        set.functions = append(set.functions, func() { set.Delete(x) })\n    } else {\n        set.functions = append(set.functions, nil)\n    }\n}\n\nfunc (set *UndoableIntSet) Delete(x int) { \/\/ Override\n    if set.Contains(x) {\n        delete(set.data, x)\n        set.functions = append(set.functions, func() { set.Add(x) })\n    } else {\n        set.functions = append(set.functions, nil)\n    }\n}\n\nfunc (set *UndoableIntSet) Undo() error {\n    if len(set.functions) == 0 {\n        return errors.New(&quot;No functions to undo&quot;)\n    }\n    index := len(set.functions) - 1\n    if function := set.functions[index]; function != nil {\n        function()\n        set.functions[index] = nil \/\/ Free closure for garbage collection\n    }\n    set.functions = set.functions[:index]\n    return nil\n}\n<\/code><\/pre>\n<p>于是就可以这样使用了：<\/p>\n<pre><code>ints := NewUndoableIntSet()\nfor _, i := range []int{1, 3, 5, 7} {\n    ints.Add(i)\n    fmt.Println(ints)\n}\nfor _, i := range []int{1, 2, 3, 4, 5, 6, 7} {\n    fmt.Println(i, ints.Contains(i), &quot; &quot;)\n    ints.Delete(i)\n    fmt.Println(ints)\n}\nfmt.Println()\nfor {\n    if err := ints.Undo(); err != nil {\n        break\n    }\n    fmt.Println(ints)\n}\n<\/code><\/pre>\n<p>但是，需要注意的是，我们用了一个新的 <code>UndoableIntSet<\/code> 几乎重写了所有的 <code>IntSet<\/code> 和 “写” 相关的方法，这样就可以把操作记录下来，然后 <strong>Undo<\/strong> 了。<\/p>\n<p>但是，可能别的类也需要Undo的功能，我是不是要重写所有的需要这个功能的类啊？这样的代码类似，就是因为数据容器不一样，我就要去重写它们，这太二了。<\/p>\n<p>我们能不能利用前面学到的泛型编程、函数式编程、IoC等范式来把这个事干得好一些呢？当然是可以的。<\/p>\n<p>如下所示：<\/p>\n<ul>\n<li>\n<p>我们先声明一个 <code>Undo[]<\/code> 的函数数组（其实是一个栈）；<\/p>\n<\/li>\n<li>\n<p>并实现一个通用 <code>Add()<\/code>。其需要一个函数指针，并把这个函数指针存放到 <code>Undo[]<\/code> 函数数组中。<\/p>\n<\/li>\n<li>\n<p>在 <code>Undo()<\/code> 的函数中，我们会遍历<code>Undo[]<\/code>函数数组，并执行之，执行完后就弹栈。<\/p>\n<\/li>\n<\/ul>\n<pre><code>type Undo []func()\n\nfunc (undo *Undo) Add(function func()) {\n    *undo = append(*undo, function)\n}\n\nfunc (undo *Undo) Undo() error {\n    functions := *undo\n    if len(functions) == 0 {\n        return errors.New(&quot;No functions to undo&quot;)\n    }\n    index := len(functions) - 1\n    if function := functions[index]; function != nil {\n        function()\n        functions[index] = nil \/\/ Free closure for garbage collection\n    }\n    *undo = functions[:index]\n    return nil\n}\n\n<\/code><\/pre>\n<p>那么我们的 <code>IntSet<\/code> 就可以改写成如下的形式：<\/p>\n<pre><code>type IntSet struct {\n    data map[int]bool\n    undo Undo\n}\n\nfunc NewIntSet() IntSet {\n    return IntSet{data: make(map[int]bool)}\n}\n\n<\/code><\/pre>\n<p>然后在其中的 <code>Add<\/code> 和 <code>Delete<\/code>中实现 Undo 操作。<\/p>\n<ul>\n<li><code>Add<\/code> 操作时加入 <code>Delete<\/code> 操作的 Undo。<\/li>\n<li><code>Delete<\/code> 操作时加入 <code>Add<\/code> 操作的 Undo。<\/li>\n<\/ul>\n<pre><code>\nfunc (set *IntSet) Add(x int) {\n    if !set.Contains(x) {\n        set.data[x] = true\n        set.undo.Add(func() { set.Delete(x) })\n    } else {\n        set.undo.Add(nil)\n    }\n}\n\nfunc (set *IntSet) Delete(x int) {\n    if set.Contains(x) {\n        delete(set.data, x)\n        set.undo.Add(func() { set.Add(x) })\n    } else {\n        set.undo.Add(nil)\n    }\n}\n\nfunc (set *IntSet) Undo() error {\n    return set.undo.Undo()\n}\n\nfunc (set *IntSet) Contains(x int) bool {\n    return set.data[x]\n}\n\n<\/code><\/pre>\n<p>我们再次看到，Go语言的Undo接口把Undo的流程给抽象出来，而要怎么Undo的事交给了业务代码来维护（通过注册一个Undo的方法）。这样在Undo的时候，就可以回调这个方法来做与业务相关的Undo操作了。<\/p>\n<h1>小结<\/h1>\n<p>这是不是和最一开始的C++的泛型编程很像？也和map、reduce、filter这样的只关心控制流程，不关心业务逻辑的做法很像？而且，一开始用一个UndoableIntSet来包装<code>IntSet<\/code>类，到反过来在<code>IntSet<\/code>里依赖<code>Undo<\/code>类，这就是控制反转IoC。<\/p>\n<p>以下是《编程范式游记》系列文章的目录，方便你了解这一系列内容的全貌。<\/p>\n<ul>\n<li><a href=\"https:\/\/time.geekbang.org\/column\/article\/301\">01 | 编程范式游记：起源<\/a><\/li>\n<li><a href=\"https:\/\/time.geekbang.org\/column\/article\/303\">02 | 编程范式游记：泛型编程<\/a><\/li>\n<li><a href=\"https:\/\/time.geekbang.org\/column\/article\/2017\">03 | 编程范式游记：类型系统和泛型的本质<\/a><\/li>\n<li><a href=\"https:\/\/time.geekbang.org\/column\/article\/2711\">04 | 编程范式游记：函数式编程<\/a><\/li>\n<li><a href=\"https:\/\/time.geekbang.org\/column\/article\/2723\">05 | 编程范式游记：修饰器模式<\/a><\/li>\n<li><a href=\"https:\/\/time.geekbang.org\/column\/article\/2729\">06 | 编程范式游记：面向对象编程<\/a><\/li>\n<li><a href=\"https:\/\/time.geekbang.org\/column\/article\/2741\">07 | 编程范式游记：基于原型的编程范式<\/a><\/li>\n<li><a href=\"https:\/\/time.geekbang.org\/column\/article\/2748\">08 | 编程范式游记：Go 语言的委托模式<\/a><\/li>\n<li><a href=\"https:\/\/time.geekbang.org\/column\/article\/2751\">09 | 编程范式游记：编程的本质<\/a><\/li>\n<li><a href=\"https:\/\/time.geekbang.org\/column\/article\/2752\">10 | 编程范式游记：逻辑编程范式<\/a><\/li>\n<li><a href=\"https:\/\/time.geekbang.org\/column\/article\/2754\">11 | 编程范式游记：程序世界里的编程范式<\/a><\/li>\n<\/ul>\n","footer_cover_data":{"img_url":"","mp_url":"","link_url":""},"article_cover_hidden":false,"column_is_experience":false,"is_required":true,"rate":{},"product_id":100002201,"like_count":141,"had_liked":false,"article_subtitle":"无","audio_download_url":"https:\/\/static001.geekbang.org\/resource\/audio\/dd\/5f\/dd0dbd23bee79121a6db943yy182b15f.mp3","id":2748,"had_viewed":false,"article_title":"37 | 编程范式游记（8）- Go 语言的委托模式","column_bgcolor":"#6091b2","share":{"content":"左耳朵耗子的专栏，20年骨灰级程序员，专栏涵盖程序员练级攻略、全栈程序员的体系化学习路线与进阶底图。专栏已有32000人加入学习，可以说是程序员必备宝典。","title":"陈皓 · 左耳听风","poster":"https:\/\/static001.geekbang.org\/resource\/image\/08\/c1\/084b2e8b8757ccb8401d6e6501ef8bc1.jpg","cover":"https:\/\/static001.geekbang.org\/resource\/image\/21\/da\/216b472de3f9027371576e107601c2da.jpg"},"is_video_preview":false,"article_summary":"Go通过委托扩展原有的功能，不关心里面的数据类型。","article_poster_wxlite":"https:\/\/static001.geekbang.org\/render\/screen\/ce\/84\/cec4a8824264478b2ef59330cc5c7684.jpeg","column_sale_type":2,"article_features":0,"article_could_preview":false,"column_cover":"https:\/\/static001.geekbang.org\/resource\/image\/21\/da\/216b472de3f9027371576e107601c2da.jpg","column_id":48,"audio_time_arr":{"m":"04","s":"00","h":"00"},"video_time":"","audio_title":"2.9 杨超 037_01.MP3","audio_md5":"dd0dbd23bee79121a6db943yy182b15f","video_size":0,"text_read_percent":0,"comment_count":17,"cid":48,"article_sharetitle":"左耳朵耗子的编程范式游记（8）- Go 语言的委托模式","column_is_onboard":true,"article_cshort":"<p>你好，我是陈皓，网名左耳朵耗子。<\/p>\n<p>我们再来看Go语言这个模式，Go语言的这个模式挺好玩儿的。声明一个struct，跟C很一样，然后直接把这个struct类型放到另一个struct里。<\/p>\n<h1>委托的简单示例<\/h1>\n<p>我们来看几个示例：<\/p>\n<pre><code>type Widget struct {\n    X, Y int\n}\n\ntype Label struct {\n    Widget        \/\/ Embedding (delegation)\n    Text   string \/\/ Aggregation\n    X int         \/\/ Override \n}\n\nfunc (label Label) Paint() {\n\t\/\/ [0xc4200141e0] - Label.Paint(&quot;State&quot;)\n    fmt.Printf(&quot;[%p] - Label.Paint(%q)\\n&quot;, \n    \t&amp;label, label.Text)\n}\n<\/code><\/pre>\n<p>由上面可知：<\/p>\n<ul>\n<li>\n<p>我们声明了一个 <code>Widget<\/code>，其有 <code>X<\/code>和<code>Y<\/code>；<\/p>\n<\/li>\n<li>\n<p>然后用它来声明一个 <code>Label<\/code>，直接把 <code>Widget<\/code> 委托进去；<\/p>\n<\/li>\n<li>\n<p>然后再给 <code>Label<\/code> 声明并实现了一个 <code>Paint()<\/code> 方法。<\/p>\n<\/li>\n<\/ul>\n<p>于是，我们就可以这样编程了：<\/p>\n<pre><code>label := Label{Widget{10, 10}, &quot;State&quot;, 100}\n\n\/\/ X=100, Y=10, Text=State, Widget.X=10\nfmt.Printf(&quot;X=%d, Y=%d, Text=%s Widget.X=%d\\n&quot;, \n\tlabel.X, label.Y, label.Text, \n\tlabel.Widget.X)\nfmt.Println()\n\/\/ {Widget:{X:10 Y:10} Text:State X:100} \n\/\/ {{10 10} State 100}\nfmt.Printf(&quot;%+v\\n%v\\n&quot;, label, label)\n\nlabel.Paint()\n<\/code><\/pre>\n<p>我们可以看到，如果有成员变量重名，则需要手动地解决冲突。<\/p>\n","video_width":0,"column_could_sub":true,"article_ctime":1517871600,"score":"31517871600","video_media_map":{},"video_preview":{},"video":0,"video_time_arr":{"m":"","s":"","h":""},"video_total_seconds":0},"extra":{},"error":{}}