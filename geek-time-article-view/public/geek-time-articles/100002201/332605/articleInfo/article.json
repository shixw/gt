{"code":0,"data":{"video_id":"","sku":"100002201","video_cover":"","author_name":"陈皓","text_read_version":0,"audio_size":5163916,"article_cover":"https:\/\/static001.geekbang.org\/resource\/image\/7b\/ed\/7b49e55b5f29cc173c38e16a028bf9ed.jpg","subtitles":{},"product_type":"c1","audio_url":"https:\/\/res001.geekbang.org\/media\/audio\/d6\/67\/d6e92becc3564a72e40fee7a77e1e767\/ld\/ld.m3u8","chapter_id":"0","column_had_sub":true,"audio_dubber":"杨超","is_finished":false,"inline_video_subtitles":{},"like":{"had_done":false,"count":7},"neighbors":{"left":{"id":332603,"article_title":"109 | Go 编程模式：Functional Options"},"right":{"id":332606,"article_title":"111 | Go 编程模式：Map-Reduce"}},"audio_time":"00:05:23","video_height":0,"rate_percent":0,"article_content":"<p>你好，我是陈皓，网名左耳朵耗子。<\/p><p>控制反转（<a href=\"https:\/\/en.wikipedia.org\/wiki\/Inversion_of_control\">Inversion of Control<\/a><a href=\"https:\/\/en.wikipedia.org\/wiki\/Inversion_of_control\">，loC<\/a>  ）是一种软件设计的方法，它的主要思想是把控制逻辑与业务逻辑分开，不要在业务逻辑里写控制逻辑，因为这样会让控制逻辑依赖于业务逻辑，而是反过来，让业务逻辑依赖控制逻辑。<\/p><p>我之前在《<a href=\"https:\/\/coolshell.cn\/articles\/9949.html\">IoC\/DIP其实是一种管理思想<\/a>》这篇文章中，举过一个开关和电灯的例子。其实，这里的开关就是控制逻辑，电器是业务逻辑。我们不要在电器中实现开关，而是要把开关抽象成一种协议，让电器都依赖它。这样的编程方式可以有效降低程序复杂度，并提升代码重用度。<\/p><p>面向对象的设计模式我就不提了，我们来看看Go语言使用Embed结构的一个示例。<\/p><h2>嵌入和委托<\/h2><h3>结构体嵌入<\/h3><p>在Go语言中，我们可以很轻松地把一个结构体嵌到另一个结构体中，如下所示：<\/p><pre><code>type Widget struct {\n    X, Y int\n}\ntype Label struct {\n    Widget        \/\/ Embedding (delegation)\n    Text   string \/\/ Aggregation\n}\n<\/code><\/pre><p>在这个示例中，我们把 <code>Widget<\/code>嵌入到了 <code>Label<\/code> 中，于是，我们可以这样使用：<\/p><pre><code>label := Label{Widget{10, 10}, &quot;State:&quot;}\n\nlabel.X = 11\nlabel.Y = 12\n<\/code><\/pre><p>如果在<code>Label<\/code> 结构体里出现了重名，就需要解决重名问题，例如，如果成员 <code>X<\/code> 重名，我们就要用 <code>label.X<\/code>表明是自己的<code>X<\/code> ，用 <code>label.Wedget.X<\/code> 表明是嵌入过来的。<\/p><p>有了这样的嵌入，我们就可以像UI组件一样，在结构的设计上进行层层分解了。比如，我可以新写出两个结构体 <code>Button<\/code> 和 <code>ListBox<\/code>：<\/p><!-- [[[read_end]]] --><pre><code>type Button struct {\n    Label \/\/ Embedding (delegation)\n}\n\ntype ListBox struct {\n    Widget          \/\/ Embedding (delegation)\n    Texts  []string \/\/ Aggregation\n    Index  int      \/\/ Aggregation\n}\n<\/code><\/pre><h3>方法重写<\/h3><p>然后，我们需要两个接口：用Painter把组件画出来；Clicker 用于表明点击事件。<\/p><pre><code>type Painter interface {\n    Paint()\n}\n \ntype Clicker interface {\n    Click()\n}\n<\/code><\/pre><p>当然，对于 <code>Lable<\/code> 来说，只有 <code>Painter<\/code> ，没有<code>Clicker<\/code>；对于 <code>Button<\/code> 和 <code>ListBox<\/code>来说，<code>Painter<\/code> 和<code>Clicker<\/code>都有。<\/p><p>我们来看一些实现：<\/p><pre><code>func (label Label) Paint() {\n  fmt.Printf(&quot;%p:Label.Paint(%q)\\n&quot;, &amp;label, label.Text)\n}\n\n\/\/因为这个接口可以通过 Label 的嵌入带到新的结构体，\n\/\/所以，可以在 Button 中重载这个接口方法\nfunc (button Button) Paint() { \/\/ Override\n    fmt.Printf(&quot;Button.Paint(%s)\\n&quot;, button.Text)\n}\nfunc (button Button) Click() {\n    fmt.Printf(&quot;Button.Click(%s)\\n&quot;, button.Text)\n}\n\n\nfunc (listBox ListBox) Paint() {\n    fmt.Printf(&quot;ListBox.Paint(%q)\\n&quot;, listBox.Texts)\n}\nfunc (listBox ListBox) Click() {\n    fmt.Printf(&quot;ListBox.Click(%q)\\n&quot;, listBox.Texts)\n}\n<\/code><\/pre><p>说到这儿，我要重点提醒你一下，<code>Button.Paint()<\/code> 接口可以通过 Label 的嵌入带到新的结构体，如果 <code>Button.Paint()<\/code> 不实现的话，会调用 <code>Label.Paint()<\/code> ，所以，在 <code>Button<\/code> 中声明 <code>Paint()<\/code> 方法，相当于Override。<\/p><h3>嵌入结构多态<\/h3><p>从下面的程序中，我们可以看到整个多态是怎么执行的。<\/p><pre><code>button1 := Button{Label{Widget{10, 70}, &quot;OK&quot;}}\nbutton2 := NewButton(50, 70, &quot;Cancel&quot;)\nlistBox := ListBox{Widget{10, 40}, \n    []string{&quot;AL&quot;, &quot;AK&quot;, &quot;AZ&quot;, &quot;AR&quot;}, 0}\n\nfor _, painter := range []Painter{label, listBox, button1, button2} {\n    painter.Paint()\n}\n \nfor _, widget := range []interface{}{label, listBox, button1, button2} {\n  widget.(Painter).Paint()\n  if clicker, ok := widget.(Clicker); ok {\n    clicker.Click()\n  }\n  fmt.Println() \/\/ print a empty line \n}\n<\/code><\/pre><p>我们可以使用接口来多态，也可以使用泛型的 <code>interface{}<\/code> 来多态，但是需要有一个类型转换。<\/p><h2>反转控制<\/h2><p>我们再来看一个示例。<\/p><p>我们有一个存放整数的数据结构，如下所示：<\/p><pre><code>type IntSet struct {\n    data map[int]bool\n}\nfunc NewIntSet() IntSet {\n    return IntSet{make(map[int]bool)}\n}\nfunc (set *IntSet) Add(x int) {\n    set.data[x] = true\n}\nfunc (set *IntSet) Delete(x int) {\n    delete(set.data, x)\n}\nfunc (set *IntSet) Contains(x int) bool {\n    return set.data[x]\n}\n<\/code><\/pre><p>其中实现了 <code>Add()<\/code> 、<code>Delete()<\/code> 和 <code>Contains()<\/code> 三个操作，前两个是写操作，后一个是读操作。<\/p><h3>实现Undo功能<\/h3><p>现在，我们想实现一个 Undo 的功能。我们可以再包装一下  <code>IntSet<\/code>  ，变成 <code>UndoableIntSet<\/code>  ，代码如下所示：<\/p><pre><code>type UndoableIntSet struct { \/\/ Poor style\n    IntSet    \/\/ Embedding (delegation)\n    functions []func()\n}\n \nfunc NewUndoableIntSet() UndoableIntSet {\n    return UndoableIntSet{NewIntSet(), nil}\n}\n \n\nfunc (set *UndoableIntSet) Add(x int) { \/\/ Override\n    if !set.Contains(x) {\n        set.data[x] = true\n        set.functions = append(set.functions, func() { set.Delete(x) })\n    } else {\n        set.functions = append(set.functions, nil)\n    }\n}\n\n\nfunc (set *UndoableIntSet) Delete(x int) { \/\/ Override\n    if set.Contains(x) {\n        delete(set.data, x)\n        set.functions = append(set.functions, func() { set.Add(x) })\n    } else {\n        set.functions = append(set.functions, nil)\n    }\n}\n\nfunc (set *UndoableIntSet) Undo() error {\n    if len(set.functions) == 0 {\n        return errors.New(&quot;No functions to undo&quot;)\n    }\n    index := len(set.functions) - 1\n    if function := set.functions[index]; function != nil {\n        function()\n        set.functions[index] = nil \/\/ For garbage collection\n    }\n    set.functions = set.functions[:index]\n    return nil\n}\n<\/code><\/pre><p>我来解释下这段代码。<\/p><ul>\n<li>我们在 <code>UndoableIntSet<\/code> 中嵌入了<code>IntSet<\/code> ，然后Override了 它的 <code>Add()<\/code>和 <code>Delete()<\/code> 方法；<\/li>\n<li><code>Contains()<\/code> 方法没有Override，所以，就被带到 <code>UndoableInSet<\/code> 中来了。<\/li>\n<li>在Override的 <code>Add()<\/code>中，记录 <code>Delete<\/code> 操作；<\/li>\n<li>在Override的 <code>Delete()<\/code> 中，记录 <code>Add<\/code> 操作；<\/li>\n<li>在新加入的  <code>Undo()<\/code> 中进行Undo操作。<\/li>\n<\/ul><p>用这样的方式为已有的代码扩展新的功能是一个很好的选择。这样，就可以在重用原有代码功能和新的功能中达到一个平衡。但是，这种方式最大的问题是，Undo操作其实是一种控制逻辑，并不是业务逻辑，所以，在复用 Undo这个功能时，是有问题的，因为其中加入了大量跟 <code>IntSet<\/code> 相关的业务逻辑。<\/p><h3>反转依赖<\/h3><p>现在我们来看另一种方法。<\/p><p>我们先声明一种函数接口，表示我们的Undo控制可以接受的函数签名是什么样的：<\/p><pre><code>type Undo []func()\n<\/code><\/pre><p>有了这个协议之后，我们的Undo控制逻辑就可以写成下面这样：<\/p><pre><code>func (undo *Undo) Add(function func()) {\n  *undo = append(*undo, function)\n}\n\nfunc (undo *Undo) Undo() error {\n  functions := *undo\n  if len(functions) == 0 {\n    return errors.New(&quot;No functions to undo&quot;)\n  }\n  index := len(functions) - 1\n  if function := functions[index]; function != nil {\n    function()\n    functions[index] = nil \/\/ For garbage collection\n  }\n  *undo = functions[:index]\n  return nil\n}\n<\/code><\/pre><p>看到这里，你不必觉得奇怪， <code>Undo<\/code> 本来就是一个类型，不必是一个结构体，是一个函数数组也没有什么问题。<\/p><p>然后，我们在IntSet里嵌入 Undo，接着在 <code>Add()<\/code> 和 <code>Delete()<\/code> 里使用刚刚的方法，就可以完成功能了。<\/p><pre><code>type IntSet struct {\n    data map[int]bool\n    undo Undo\n}\n \nfunc NewIntSet() IntSet {\n    return IntSet{data: make(map[int]bool)}\n}\n\nfunc (set *IntSet) Undo() error {\n    return set.undo.Undo()\n}\n \nfunc (set *IntSet) Contains(x int) bool {\n    return set.data[x]\n}\n\nfunc (set *IntSet) Add(x int) {\n    if !set.Contains(x) {\n        set.data[x] = true\n        set.undo.Add(func() { set.Delete(x) })\n    } else {\n        set.undo.Add(nil)\n    }\n}\n \nfunc (set *IntSet) Delete(x int) {\n    if set.Contains(x) {\n        delete(set.data, x)\n        set.undo.Add(func() { set.Add(x) })\n    } else {\n        set.undo.Add(nil)\n    }\n}\n<\/code><\/pre><p>这个就是控制反转，不是由控制逻辑 <code>Undo<\/code>  来依赖业务逻辑 <code>IntSet<\/code>，而是由业务逻辑 <code>IntSet<\/code> 依赖 <code>Undo<\/code> 。这里依赖的是其实是一个协议，<strong>这个协议是一个没有参数的函数数组。<\/strong>可以看到，这样一来，我们 Undo 的代码就可以复用了。<\/p><p>好了，这节课就到这里。如果你觉得今天的内容对你有所帮助，欢迎你帮我分享给更多人。<\/p>","footer_cover_data":{"img_url":"","mp_url":"","link_url":""},"article_cover_hidden":false,"column_is_experience":false,"is_required":false,"rate":{},"product_id":100002201,"like_count":23,"had_liked":false,"article_subtitle":"","audio_download_url":"https:\/\/static001.geekbang.org\/resource\/audio\/d6\/67\/d6e92becc3564a72e40fee7a77e1e767.mp3","id":332605,"had_viewed":false,"article_title":"110 | Go编程模式：委托和反转控制","column_bgcolor":"#6091b2","share":{"content":"左耳朵耗子的专栏，20年骨灰级程序员，专栏涵盖程序员练级攻略、全栈程序员的体系化学习路线与进阶底图。专栏已有32000人加入学习，可以说是程序员必备宝典。","title":"陈皓 · 左耳听风","poster":"https:\/\/static001.geekbang.org\/resource\/image\/08\/c1\/084b2e8b8757ccb8401d6e6501ef8bc1.jpg","cover":"https:\/\/static001.geekbang.org\/resource\/image\/21\/da\/216b472de3f9027371576e107601c2da.jpg"},"is_video_preview":false,"article_summary":"控制反转的主要思想是把控制逻辑与业务逻辑分开，不要在业务逻辑里写控制逻辑，而是反过来让业务逻辑依赖控制逻辑。","article_poster_wxlite":"https:\/\/static001.geekbang.org\/render\/screen\/94\/f1\/943f3b8a0045220b6a03eefba1880ff1.jpeg","column_sale_type":2,"article_features":0,"article_could_preview":false,"column_cover":"https:\/\/static001.geekbang.org\/resource\/image\/21\/da\/216b472de3f9027371576e107601c2da.jpg","column_id":48,"audio_time_arr":{"m":"05","s":"23","h":"00"},"video_time":"","audio_title":"6.20 杨超 110_01.MP3","audio_md5":"d6e92becc3564a72e40fee7a77e1e767","video_size":0,"text_read_percent":0,"comment_count":6,"cid":48,"article_sharetitle":"Go编程模式：委托和反转控制","column_is_onboard":true,"article_cshort":"<p>你好，我是陈皓，网名左耳朵耗子。<\/p><p>控制反转（<a href=\"https:\/\/en.wikipedia.org\/wiki\/Inversion_of_control\">Inversion of Control<\/a><a href=\"https:\/\/en.wikipedia.org\/wiki\/Inversion_of_control\">，loC<\/a>  ）是一种软件设计的方法，它的主要思想是把控制逻辑与业务逻辑分开，不要在业务逻辑里写控制逻辑，因为这样会让控制逻辑依赖于业务逻辑，而是反过来，让业务逻辑依赖控制逻辑。<\/p><p>我之前在《<a href=\"https:\/\/coolshell.cn\/articles\/9949.html\">IoC\/DIP其实是一种管理思想<\/a>》这篇文章中，举过一个开关和电灯的例子。其实，这里的开关就是控制逻辑，电器是业务逻辑。我们不要在电器中实现开关，而是要把开关抽象成一种协议，让电器都依赖它。这样的编程方式可以有效降低程序复杂度，并提升代码重用度。<\/p><p>面向对象的设计模式我就不提了，我们来看看Go语言使用Embed结构的一个示例。<\/p><h2>嵌入和委托<\/h2><h3>结构体嵌入<\/h3><p>在Go语言中，我们可以很轻松地把一个结构体嵌到另一个结构体中，如下所示：<\/p><pre><code>type Widget struct {\n    X, Y int\n}\ntype Label struct {\n    Widget        \/\/ Embedding (delegation)\n    Text   string \/\/ Aggregation\n}\n<\/code><\/pre><p>在这个示例中，我们把 <code>Widget<\/code>嵌入到了 <code>Label<\/code> 中，于是，我们可以这样使用：<\/p><pre><code>label := Label{Widget{10, 10}, &quot;State:&quot;}\n\nlabel.X = 11\nlabel.Y = 12\n<\/code><\/pre><p>如果在<code>Label<\/code> 结构体里出现了重名，就需要解决重名问题，例如，如果成员 <code>X<\/code> 重名，我们就要用 <code>label.X<\/code>表明是自己的<code>X<\/code> ，用 <code>label.Wedget.X<\/code> 表明是嵌入过来的。<\/p><p>有了这样的嵌入，我们就可以像UI组件一样，在结构的设计上进行层层分解了。比如，我可以新写出两个结构体 <code>Button<\/code> 和 <code>ListBox<\/code>：<\/p>","video_width":0,"column_could_sub":true,"article_ctime":1610618580,"score":"121610618580","video_media_map":{},"video_preview":{},"video":0,"video_time_arr":{"m":"","s":"","h":""},"video_total_seconds":0},"extra":{},"error":{}}