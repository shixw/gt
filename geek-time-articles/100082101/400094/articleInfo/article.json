{"code":0,"data":{"video_id":"","sku":"100082101","video_cover":"","author_name":"徐昊","text_read_version":0,"audio_size":10885809,"article_cover":"https:\/\/static001.geekbang.org\/resource\/image\/1e\/b8\/1ed71edf5fa3bd50ec555e1b0e578cb8.jpeg","subtitles":{},"product_type":"c1","audio_url":"https:\/\/res001.geekbang.org\/media\/audio\/5b\/f2\/5baf3b1b7cc950f4fd9e584b640933f2\/ld\/ld.m3u8","chapter_id":"0","column_had_sub":true,"audio_dubber":"徐昊","is_finished":false,"inline_video_subtitles":{},"like":{"had_done":false,"count":1},"neighbors":{"left":{"id":399057,"article_title":"说点题外话03｜银弹可以杀死狼人，但你怎么知道狼人不是你呢？"},"right":{"id":397653,"article_title":"12｜云时代的挑战（上）：弹性边界还是业务边界？"}},"audio_time":"00:04:33","video_height":0,"rate_percent":0,"article_content":"<p>你好，我是徐昊。今天我们再来专门说点题外话。<\/p><p>前面几期题外话都比较偏向于提供一种不同的角度，主要是因为你们也并没有针对课程的内容，提出什么特别的问题需要我来具体回答。那么作为我们在进入新约前的最后一篇题外话，我想聊一聊关于RESTful API的问题。<\/p><p>我记得有位同学在留言区问了这样一个问题：过长的URI是否破坏了迪米特法则（Law of Demeter）。这里我们就要搞清楚，什么是迪米特法则呢？<\/p><p>迪米特法则又叫最小可知法则，指的是<strong>在面向对象设计中，实体应尽可能少地与其他实体发生交互<\/strong>。为了说明什么是“少的交互”，我们还特别归纳了一组可以认为不违反迪米特法则，并且可以直接调用的对象：<\/p><ul>\n<li>当前对象自己（this，self）；<\/li>\n<li>以参数形式传入的对象，比如函数的形参（parameter）；<\/li>\n<li>当前对象内实例变量引用的对象（instance variable）；<\/li>\n<li>如果实例变量是集合，那么集合中的对象也可以访问（collection，aggregration）；<\/li>\n<li>由当前对象创建的对象（variable declaration in function）。<\/li>\n<\/ul><p>那么这些场景适用于RESTful API调用的场景吗？显然并不太适用。因为在RESTful API的场景中，实体只有客户端和API提供者，而API提供者的内在结构都被API层屏蔽了。所以无论怎么调用，都不会出现对于API提供者内部结构的依赖。<\/p><!-- [[[read_end]]] --><p>如果我们把迪米特法则扩展一下，推广到概念层面，暴露了内在的逻辑就算。那么恰恰是RESTful API，能帮助我们继续遵循迪米特法则。<\/p><p>比如通过超媒体明确地表示资源之间的关联，而不是依靠客户端去拼凑URI。如果客户端可以拼凑出URI，则表明客户端对于API提供者的内在逻辑存在依赖。而通过HATEOAS，把所有关联的链接直接提供，就避免了暴露内在的逻辑。<\/p><p>再比如，API的设计要按照HTTP语义约定，而不是客户端与API供应者之间的“私约”（private protocol）。PUT只能修改已经存在的资源，而不能构建新的资源；POST创建资源成功，需要返回201，并在HEAD中给出新构建资源的URI；GET默认都是可以缓存的，无法缓存的查询（而不是通过URI遍历信息），需要用POST访问等等。这些都是希望通过公约，将客户端中对于API供应者的了解降到最低。<\/p><p>所以迪米特法则本身的想法是不错的，但是场景改变了，我们就要重新思考它在新的环境中是如何被应用的。而如果我们真的在乎迪米特法则，那么在RESTful API的场景下，关注点就不会放在URI有多长上，而应放在客户端与服务器间的知识依赖到底有多少上。<\/p><p>另外一个对于RESTful API的质疑在于，通过HATEOAS完全以分布式超媒体的方式构成API，那么客户端看起来越来越像浏览器，而不是针对RESTful API的客户端了。<\/p><p>正如我们在第10讲中讲到的，RESTful架构风格<strong>是对互联网架构的反思<\/strong>。那么互联网架构的核心在于开放性和扩展性，因而<strong>RESTful架构风格的核心也是开放<strong><strong>性<\/strong><\/strong>和扩展性<\/strong>。<\/p><p>因为开放，使得RESTful API的供应者不会对客户端作出任何假设。就好像互联网服务器并不会假设它的客户端只有浏览器一样，wget、telnet等等都是可能的客户端；而因为扩展性，RESTful API只会为客户端提供最基本的功能，大量的计算被分布到了客户端侧进行。<\/p><p>这种架构的假设是不同于企业应用的客户端与服务器架构的，在企业应用架构的语境中，客户端与服务器有更多的耦合。服务端更多地是为客户端提供服务，而不是保持自己开放和稳定。<\/p><p>那么为什么RESTful API最终还是成为“行业主流”了呢（虽然真的会，和真的用的人并不多）？<\/p><p>因为从大趋势上来说，将企业内的能力（而不仅仅是后台）构造成开放API，并围绕着开放API，形成企业内生态是大势。在这个大势之下，RESTful API、MicroService、企业内生态、能力平台、中台形成了一条清晰的企业架构现代化之路。仅仅服务于某些（或者某个）前台的后台服务，终将会淡出历史的舞台。<\/p><p>因而在这种历史转折的节点，我们更应该清晰地理解不同想法之间的差异，哪怕它们要解决的问题与现行方法是相似的，但是对于这是什么问题，我们要怎么想，还是带来了完全不同的角度。<\/p><h2>思考题<\/h2><p>请问其他面向对象原则与最佳实践，在RESTful架构下有何种体现？<\/p><p>欢迎把你的思考和想法分享在留言区，我会和你交流。我们新约部分再见！<\/p>","footer_cover_data":{"img_url":"","mp_url":"","link_url":""},"article_cover_hidden":false,"column_is_experience":false,"is_required":true,"rate":{},"product_id":100082101,"like_count":3,"had_liked":false,"article_subtitle":"","audio_download_url":"https:\/\/static001.geekbang.org\/resource\/audio\/5b\/f2\/5baf3b1b7cc950f4fd9e584b640933f2.mp3","id":400094,"had_viewed":false,"article_title":"说点题外话04｜面向对象的原则适用于RESTful API吗？","column_bgcolor":"#F6F7FB","share":{"content":"Thoughtworks CTO带你重构建模技能","title":"徐昊 · 如何落地业务建模","poster":"https:\/\/static001.geekbang.org\/resource\/image\/aa\/aa\/aa4e4881yy3d69fd73a7a3f7b9feb6aa.jpg","cover":"https:\/\/static001.geekbang.org\/resource\/image\/0b\/db\/0bfe78d076a906dcec25e4bb91f4d9db.jpg"},"is_video_preview":false,"article_summary":"迪米特法则本身的想法是不错的，但是场景改变了，我们就要重新思考它在新的环境中是如何被应用的。","article_poster_wxlite":"https:\/\/static001.geekbang.org\/render\/screen\/27\/f4\/27779056b890c0b78492c11b487ad5f4.jpeg","column_sale_type":2,"article_features":0,"article_could_preview":false,"column_cover":"https:\/\/static001.geekbang.org\/resource\/image\/0b\/db\/0bfe78d076a906dcec25e4bb91f4d9db.jpg","column_id":423,"audio_time_arr":{"m":"04","s":"33","h":"00"},"video_time":"","audio_title":"徐昊.mp3","audio_md5":"5baf3b1b7cc950f4fd9e584b640933f2","video_size":0,"text_read_percent":0,"comment_count":5,"cid":423,"article_sharetitle":"徐八叉：面向对象的原则适用于RESTful API吗？","column_is_onboard":true,"article_cshort":"<p>你好，我是徐昊。今天我们再来专门说点题外话。<\/p><p>前面几期题外话都比较偏向于提供一种不同的角度，主要是因为你们也并没有针对课程的内容，提出什么特别的问题需要我来具体回答。那么作为我们在进入新约前的最后一篇题外话，我想聊一聊关于RESTful API的问题。<\/p><p>我记得有位同学在留言区问了这样一个问题：过长的URI是否破坏了迪米特法则（Law of Demeter）。这里我们就要搞清楚，什么是迪米特法则呢？<\/p><p>迪米特法则又叫最小可知法则，指的是<strong>在面向对象设计中，实体应尽可能少地与其他实体发生交互<\/strong>。为了说明什么是“少的交互”，我们还特别归纳了一组可以认为不违反迪米特法则，并且可以直接调用的对象：<\/p><ul>\n<li>当前对象自己（this，self）；<\/li>\n<li>以参数形式传入的对象，比如函数的形参（parameter）；<\/li>\n<li>当前对象内实例变量引用的对象（instance variable）；<\/li>\n<li>如果实例变量是集合，那么集合中的对象也可以访问（collection，aggregration）；<\/li>\n<li>由当前对象创建的对象（variable declaration in function）。<\/li>\n<\/ul><p>那么这些场景适用于RESTful API调用的场景吗？显然并不太适用。因为在RESTful API的场景中，实体只有客户端和API提供者，而API提供者的内在结构都被API层屏蔽了。所以无论怎么调用，都不会出现对于API提供者内部结构的依赖。<\/p>","video_width":0,"column_could_sub":true,"article_ctime":1627315200,"score":"31627315200","video_media_map":{},"video_preview":{},"video":0,"video_time_arr":{"m":"","s":"","h":""},"video_total_seconds":0},"extra":{},"error":{}}