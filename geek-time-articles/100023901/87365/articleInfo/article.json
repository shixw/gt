{"code":0,"data":{"video_id":"","sku":"100023901","video_cover":"","author_name":"王宝令","text_read_version":0,"audio_size":9770402,"article_cover":"https:\/\/static001.geekbang.org\/resource\/image\/74\/c9\/74c3b96e7526ecef0af465a5aeae47c9.jpg","subtitles":{},"product_type":"c1","audio_url":"https:\/\/res001.geekbang.org\/\/media\/audio\/42\/36\/42b535904316f092b21379de2ab9c936\/ld\/ld.m3u8","chapter_id":"0","column_had_sub":true,"audio_dubber":"王宝令","is_finished":false,"inline_video_subtitles":{},"like":{"had_done":false,"count":120},"neighbors":{"left":{"id":86695,"article_title":"11 | Java线程（下）：为什么局部变量是线程安全的？"},"right":{"id":87749,"article_title":"13 | 理论基础模块热点问题答疑"}},"audio_time":"00:10:12","video_height":0,"rate_percent":0,"article_content":"<p>在工作中，我发现很多同学在设计之初都是直接按照单线程的思路来写程序的，而忽略了本应该重视的并发问题；等上线后的某天，突然发现诡异的Bug，再历经千辛万苦终于定位到问题所在，却发现对于如何解决已经没有了思路。<\/p><p>关于这个问题，我觉得咱们今天很有必要好好聊聊“如何用面向对象思想写好并发程序”这个话题。<\/p><p>面向对象思想与并发编程有关系吗？本来是没关系的，它们分属两个不同的领域，但是在Java语言里，这两个领域被无情地融合在一起了，好在融合的效果还是不错的：<strong>在Java语言里，面向对象思想能够让并发编程变得更简单<\/strong>。<\/p><p>那如何才能用面向对象思想写好并发程序呢？结合我自己的工作经验来看，我觉得你可以从封装共享变量、识别共享变量间的约束条件和制定并发访问策略这三个方面下手。<\/p><h2>一、封装共享变量<\/h2><p>并发程序，我们关注的一个核心问题，不过是解决多线程同时访问共享变量的问题。在<a href=\"https:\/\/time.geekbang.org\/column\/article\/84344\">《03 | 互斥锁（上）：解决原子性问题》<\/a>中，我们类比过球场门票的管理，现实世界里门票管理的一个核心问题是：所有观众只能通过规定的入口进入，否则检票就形同虚设。在编程世界这个问题也很重要，编程领域里面对于共享变量的访问路径就类似于球场的入口，必须严格控制。好在有了面向对象思想，对共享变量的访问路径可以轻松把控。<\/p><!-- [[[read_end]]] --><p>面向对象思想里面有一个很重要的特性是<strong>封装<\/strong>，封装的通俗解释就是<strong>将属性和实现细节封装在对象内部<\/strong>，外界对象<strong>只能通过<\/strong>目标对象提供的<strong>公共方法来间接访问<\/strong>这些内部属性，这和门票管理模型匹配度相当的高，球场里的座位就是对象属性，球场入口就是对象的公共方法。我们把共享变量作为对象的属性，那对于共享变量的访问路径就是对象的公共方法，所有入口都要安排检票程序就相当于我们前面提到的并发访问策略。<\/p><p>利用面向对象思想写并发程序的思路，其实就这么简单：<strong>将共享变量作为对象属性封装在内部，对所有公共方法制定并发访问策略<\/strong>。就拿很多统计程序都要用到计数器来说，下面的计数器程序共享变量只有一个，就是value，我们把它作为Counter类的属性，并且将两个公共方法get()和addOne()声明为同步方法，这样Counter类就成为一个线程安全的类了。<\/p><pre><code>public class Counter {\n  private long value;\n  synchronized long get(){\n    return value;\n  }\n  synchronized long addOne(){\n    return ++value;\n  }\n}\n<\/code><\/pre><p>当然，实际工作中，很多的场景都不会像计数器这么简单，经常要面临的情况往往是有很多的共享变量，例如，信用卡账户有卡号、姓名、身份证、信用额度、已出账单、未出账单等很多共享变量。这么多的共享变量，如果每一个都考虑它的并发安全问题，那我们就累死了。但其实仔细观察，你会发现，很多共享变量的值是不会变的，例如信用卡账户的卡号、姓名、身份证。<strong>对于这些不会发生变化的共享变量，建议你用final关键字来修饰<\/strong>。这样既能避免并发问题，也能很明了地表明你的设计意图，让后面接手你程序的兄弟知道，你已经考虑过这些共享变量的并发安全问题了。<\/p><h2>二、识别共享变量间的约束条件<\/h2><p>识别共享变量间的约束条件非常重要。因为<strong>这些约束条件，决定了并发访问策略<\/strong>。例如，库存管理里面有个合理库存的概念，库存量不能太高，也不能太低，它有一个上限和一个下限。关于这些约束条件，我们可以用下面的程序来模拟一下。在类SafeWM中，声明了两个成员变量upper和lower，分别代表库存上限和库存下限，这两个变量用了AtomicLong这个原子类，原子类是线程安全的，所以这两个成员变量的set方法就不需要同步了。<\/p><pre><code>public class SafeWM {\n  \/\/ 库存上限\n  private final AtomicLong upper =\n        new AtomicLong(0);\n  \/\/ 库存下限\n  private final AtomicLong lower =\n        new AtomicLong(0);\n  \/\/ 设置库存上限\n  void setUpper(long v){\n    upper.set(v);\n  }\n  \/\/ 设置库存下限\n  void setLower(long v){\n    lower.set(v);\n  }\n  \/\/ 省略其他业务代码\n}\n<\/code><\/pre><p>虽说上面的代码是没有问题的，但是忽视了一个约束条件，就是<strong>库存下限要小于库存上限<\/strong>，这个约束条件能够直接加到上面的set方法上吗？我们先直接加一下看看效果（如下面代码所示）。我们在setUpper()和setLower()中增加了参数校验，这乍看上去好像是对的，但其实存在并发问题，问题在于存在竞态条件。这里我顺便插一句，其实当你看到代码里出现if语句的时候，就应该立刻意识到可能存在竞态条件。<\/p><p>我们假设库存的下限和上限分别是(2,10)，线程A调用setUpper(5)将上限设置为5，线程B调用setLower(7)将下限设置为7，如果线程A和线程B完全同时执行，你会发现线程A能够通过参数校验，因为这个时候，下限还没有被线程B设置，还是2，而5&gt;2；线程B也能够通过参数校验，因为这个时候，上限还没有被线程A设置，还是10，而7&lt;10。当线程A和线程B都通过参数校验后，就把库存的下限和上限设置成(7, 5)了，显然此时的结果是不符合<strong>库存下限要小于库存上限<\/strong>这个约束条件的。<\/p><pre><code>public class SafeWM {\n  \/\/ 库存上限\n  private final AtomicLong upper =\n        new AtomicLong(0);\n  \/\/ 库存下限\n  private final AtomicLong lower =\n        new AtomicLong(0);\n  \/\/ 设置库存上限\n  void setUpper(long v){\n    \/\/ 检查参数合法性\n    if (v &lt; lower.get()) {\n      throw new IllegalArgumentException();\n    }\n    upper.set(v);\n  }\n  \/\/ 设置库存下限\n  void setLower(long v){\n    \/\/ 检查参数合法性\n    if (v &gt; upper.get()) {\n      throw new IllegalArgumentException();\n    }\n    lower.set(v);\n  }\n  \/\/ 省略其他业务代码\n}\n<\/code><\/pre><p>在没有识别出<strong>库存下限要小于库存上限<\/strong>这个约束条件之前，我们制定的并发访问策略是利用原子类，但是这个策略，完全不能保证<strong>库存下限要小于库存上限<\/strong>这个约束条件。所以说，在设计阶段，我们<strong>一定要识别出所有共享变量之间的约束条件，如果约束条件识别不足，很可能导致制定的并发访问策略南辕北辙<\/strong>。<\/p><p>共享变量之间的约束条件，反映在代码里，基本上都会有if语句，所以，一定要特别注意竞态条件。<\/p><h2>三、制定并发访问策略<\/h2><p>制定并发访问策略，是一个非常复杂的事情。应该说整个专栏都是在尝试搞定它。不过从方案上来看，无外乎就是以下“三件事”。<\/p><ol>\n<li>避免共享：避免共享的技术主要是利于线程本地存储以及为每个任务分配独立的线程。<\/li>\n<li>不变模式：这个在Java领域应用的很少，但在其他领域却有着广泛的应用，例如Actor模式、CSP模式以及函数式编程的基础都是不变模式。<\/li>\n<li>管程及其他同步工具：Java领域万能的解决方案是管程，但是对于很多特定场景，使用Java并发包提供的读写锁、并发容器等同步工具会更好。<\/li>\n<\/ol><p>接下来在咱们专栏的第二模块我会仔细讲解Java并发工具类以及他们的应用场景，在第三模块我还会讲解并发编程的设计模式，这些都是和制定并发访问策略有关的。<\/p><p>除了这些方案之外，还有一些宏观的原则需要你了解。这些宏观原则，有助于你写出“健壮”的并发程序。这些原则主要有以下三条。<\/p><ol>\n<li>优先使用成熟的工具类：Java SDK并发包里提供了丰富的工具类，基本上能满足你日常的需要，建议你熟悉它们，用好它们，而不是自己再“发明轮子”，毕竟并发工具类不是随随便便就能发明成功的。<\/li>\n<li>迫不得已时才使用低级的同步原语：低级的同步原语主要指的是synchronized、Lock、Semaphore等，这些虽然感觉简单，但实际上并没那么简单，一定要小心使用。<\/li>\n<li>避免过早优化：安全第一，并发程序首先要保证安全，出现性能瓶颈后再优化。在设计期和开发期，很多人经常会情不自禁地预估性能的瓶颈，并对此实施优化，但残酷的现实却是：性能瓶颈不是你想预估就能预估的。<\/li>\n<\/ol><h2>总结<\/h2><p>利用面向对象思想编写并发程序，一个关键点就是利用面向对象里的封装特性，由于篇幅原因，这里我只做了简单介绍，详细的你可以借助相关资料定向学习。而对共享变量进行封装，要避免“逸出”，所谓“逸出”简单讲就是共享变量逃逸到对象的外面，比如在<a href=\"https:\/\/time.geekbang.org\/column\/article\/84017\">《02 | Java内存模型：看Java如何解决可见性和有序性问题》<\/a>那一篇我们已经讲过构造函数里的this“逸出”。这些都是必须要避免的。<\/p><p>这是我们专栏并发理论基础的最后一部分内容，这一部分内容主要是让你对并发编程有一个全面的认识，让你了解并发编程里的各种概念，以及它们之间的关系，当然终极目标是让你知道遇到并发问题该怎么思考。这部分的内容还是有点烧脑的，但专栏后面几个模块的内容都是具体的实践部分，相对来说就容易多了。我们一起坚持吧！<\/p><h2>课后思考<\/h2><p>本期示例代码中，类SafeWM不满足库存下限要小于库存上限这个约束条件，那你来试试修改一下，让它能够在并发条件下满足库存下限要小于库存上限这个约束条件。<\/p><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。<\/p><h2>延伸阅读<\/h2><p>关于这部分的内容，如果你觉得还不“过瘾”，这里我再给你推荐一本书吧——<a href=\"time:\/\/mall?url=https%3A%2F%2Fh5.youzan.com%2Fv2%2Fgoods%2F2758xqdzr6uuw\">《Java并发编程实战》<\/a>，这本书的第三章《对象的共享》、第四章《对象的组合》全面地介绍了如何构建线程安全的对象，你可以拿来深入地学习。<\/p><p><\/p>","footer_cover_data":{"img_url":"","mp_url":"","link_url":""},"article_cover_hidden":false,"column_is_experience":false,"is_required":true,"rate":{},"product_id":100023901,"like_count":132,"had_liked":false,"article_subtitle":"","audio_download_url":"https:\/\/static001.geekbang.org\/resource\/audio\/42\/36\/42b535904316f092b21379de2ab9c936.mp3","id":87365,"had_viewed":false,"article_title":"12 | 如何用面向对象思想写好并发程序？","column_bgcolor":"#cbd0de","share":{"content":"当面试时问到多线程、锁的问题，你还是答不上来怎么办？推荐给你《Java 并发编程实战》专栏，带你搞懂并发里的那些Bug问题，全面提升你的并发编程能力，大厂面试绝对不是问题。","title":"王宝令 · Java并发编程实战","poster":"https:\/\/static001.geekbang.org\/resource\/image\/ce\/50\/cebb5cfded54f4bfcca4d75ffe915350.jpg","cover":"https:\/\/static001.geekbang.org\/resource\/image\/47\/f1\/47296780442c7fd11ebf97c0749103f1.jpg"},"is_video_preview":false,"article_summary":"在Java语言里，面向对象思想能够让并发编程变得更简单。","article_poster_wxlite":"https:\/\/static001.geekbang.org\/render\/screen\/bc\/37\/bcf95e7b76469dc5bb57060548536937.jpeg","column_sale_type":2,"article_features":0,"article_could_preview":false,"column_cover":"https:\/\/static001.geekbang.org\/resource\/image\/47\/f1\/47296780442c7fd11ebf97c0749103f1.jpg","column_id":159,"audio_time_arr":{"m":"10","s":"12","h":"00"},"video_time":"","audio_title":"3.24 宝令 12 (2)_01","audio_md5":"42b535904316f092b21379de2ab9c936","video_size":0,"text_read_percent":0,"comment_count":98,"cid":159,"article_sharetitle":"如何用面向对象思想写好并发程序？","column_is_onboard":true,"article_cshort":"<p>在工作中，我发现很多同学在设计之初都是直接按照单线程的思路来写程序的，而忽略了本应该重视的并发问题；等上线后的某天，突然发现诡异的Bug，再历经千辛万苦终于定位到问题所在，却发现对于如何解决已经没有了思路。<\/p><p>关于这个问题，我觉得咱们今天很有必要好好聊聊“如何用面向对象思想写好并发程序”这个话题。<\/p><p>面向对象思想与并发编程有关系吗？本来是没关系的，它们分属两个不同的领域，但是在Java语言里，这两个领域被无情地融合在一起了，好在融合的效果还是不错的：<strong>在Java语言里，面向对象思想能够让并发编程变得更简单<\/strong>。<\/p><p>那如何才能用面向对象思想写好并发程序呢？结合我自己的工作经验来看，我觉得你可以从封装共享变量、识别共享变量间的约束条件和制定并发访问策略这三个方面下手。<\/p><h2>一、封装共享变量<\/h2><p>并发程序，我们关注的一个核心问题，不过是解决多线程同时访问共享变量的问题。在<a href=\"https:\/\/time.geekbang.org\/column\/article\/84344\">《03 | 互斥锁（上）：解决原子性问题》<\/a>中，我们类比过球场门票的管理，现实世界里门票管理的一个核心问题是：所有观众只能通过规定的入口进入，否则检票就形同虚设。在编程世界这个问题也很重要，编程领域里面对于共享变量的访问路径就类似于球场的入口，必须严格控制。好在有了面向对象思想，对共享变量的访问路径可以轻松把控。<\/p>","video_width":0,"column_could_sub":true,"article_ctime":1553529600,"score":"31553529600","video_media_map":{},"video_preview":{},"video":0,"video_time_arr":{"m":"","s":"","h":""},"video_total_seconds":0},"extra":{},"error":{}}