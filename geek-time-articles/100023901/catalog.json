[{"article_title":"开篇词 | 你为什么需要学习并发编程？","id":"83087"},{"article_title":"学习攻略 | 如何才能学好并发编程？","id":"83267"},{"article_title":"01 | 可见性、原子性和有序性问题：并发编程Bug的源头","id":"83682"},{"article_title":"02 | Java内存模型：看Java如何解决可见性和有序性问题","id":"84017"},{"article_title":"03 | 互斥锁（上）：解决原子性问题","id":"84344"},{"article_title":"04 | 互斥锁（下）：如何用一把锁保护多个资源？","id":"84601"},{"article_title":"05 | 一不小心就死锁了，怎么办？","id":"85001"},{"article_title":"06 | 用“等待-通知”机制优化循环等待","id":"85241"},{"article_title":"07 | 安全性、活跃性以及性能问题","id":"85702"},{"article_title":"08 | 管程：并发编程的万能钥匙","id":"86089"},{"article_title":"09 | Java线程（上）：Java线程的生命周期","id":"86366"},{"article_title":"10 | Java线程（中）：创建多少线程才是合适的？","id":"86666"},{"article_title":"11 | Java线程（下）：为什么局部变量是线程安全的？","id":"86695"},{"article_title":"12 | 如何用面向对象思想写好并发程序？","id":"87365"},{"article_title":"13 | 理论基础模块热点问题答疑","id":"87749"},{"article_title":"14 | Lock和Condition（上）：隐藏在并发包中的管程","id":"87779"},{"article_title":"15 | Lock和Condition（下）：Dubbo如何用管程实现异步转同步？","id":"88487"},{"article_title":"16 | Semaphore：如何快速实现一个限流器？","id":"88499"},{"article_title":"17 | ReadWriteLock：如何快速实现一个完备的缓存？","id":"88909"},{"article_title":"18 | StampedLock：有没有比读写锁更快的锁？","id":"89456"},{"article_title":"19 | CountDownLatch和CyclicBarrier：如何让多线程步调一致？","id":"89461"},{"article_title":"20 | 并发容器：都有哪些“坑”需要我们填？","id":"90201"},{"article_title":"21 | 原子类：无锁工具类的典范","id":"90515"},{"article_title":"22 | Executor与线程池：如何创建正确的线程池？","id":"90771"},{"article_title":"23 | Future：如何用多线程实现最优的“烧水泡茶”程序？","id":"91292"},{"article_title":"24 | CompletableFuture：异步编程没那么难","id":"91569"},{"article_title":"25 | CompletionService：如何批量执行异步任务？","id":"92245"},{"article_title":"26 | Fork/Join：单机版的MapReduce","id":"92524"},{"article_title":"27 | 并发工具类模块热点问题答疑","id":"92849"},{"article_title":"28 | Immutability模式：如何利用不变性解决并发问题？","id":"92856"},{"article_title":"29 | Copy-on-Write模式：不是延时策略的COW","id":"93154"},{"article_title":"30 | 线程本地存储模式：没有共享，就没有伤害","id":"93745"},{"article_title":"31 | Guarded Suspension模式：等待唤醒机制的规范实现","id":"94097"},{"article_title":"32 | Balking模式：再谈线程安全的单例模式","id":"94604"},{"article_title":"33 | Thread-Per-Message模式：最简单实用的分工方法","id":"95098"},{"article_title":"34 | Worker Thread模式：如何避免重复创建线程？","id":"95525"},{"article_title":"35 | 两阶段终止模式：如何优雅地终止线程？","id":"95847"},{"article_title":"36 | 生产者-消费者模式：用流水线思想提高效率","id":"96168"},{"article_title":"37 | 设计模式模块热点问题答疑","id":"96736"},{"article_title":"38 | 案例分析（一）：高性能限流器Guava RateLimiter","id":"97231"},{"article_title":"39 | 案例分析（二）：高性能网络应用框架Netty","id":"97622"},{"article_title":"40 | 案例分析（三）：高性能队列Disruptor","id":"98134"},{"article_title":"41 | 案例分析（四）：高性能数据库连接池HiKariCP","id":"98491"},{"article_title":"42 | Actor模型：面向对象原生的并发模型","id":"98903"},{"article_title":"43 | 软件事务内存：借鉴数据库的并发经验","id":"99251"},{"article_title":"44 | 协程：更轻量级的线程","id":"99787"},{"article_title":"45 | CSP模型：Golang的主力队员","id":"100098"},{"article_title":"结束语 | 十年之后，初心依旧","id":"100627"},{"article_title":"结课测试 | 这些Java并发编程实战的知识你都掌握了吗？","id":"243424"},{"article_title":"用户来信 | 真好，面试考到这些并发编程，我都答对了！","id":"102300"},{"article_title":"3 个用户来信 | 打开一个新的并发世界","id":"105074"}]