{"code":0,"data":{"video_id":"","sku":"100023901","video_cover":"","author_name":"王宝令","text_read_version":0,"audio_size":7279182,"article_cover":"https:\/\/static001.geekbang.org\/resource\/image\/8b\/b2\/8b093f8620e13f4bb6a0eb365ec059b2.jpg","subtitles":{},"product_type":"c1","audio_url":"https:\/\/res001.geekbang.org\/\/media\/audio\/a3\/ce\/a3c1bfcb3946a823b59da193a830aece\/ld\/ld.m3u8","chapter_id":"0","column_had_sub":true,"audio_dubber":"王宝令","is_finished":false,"inline_video_subtitles":{},"like":{"had_done":false,"count":94},"neighbors":{"left":{"id":98903,"article_title":"42 | Actor模型：面向对象原生的并发模型"},"right":{"id":99787,"article_title":"44 | 协程：更轻量级的线程"}},"audio_time":"00:07:36","video_height":0,"rate_percent":0,"article_content":"<p>很多同学反馈说，工作了挺长时间但是没有机会接触并发编程，实际上我们天天都在写并发程序，只不过并发相关的问题都被类似Tomcat这样的Web服务器以及MySQL这样的数据库解决了。尤其是数据库，在解决并发问题方面，可谓成绩斐然，它的<strong>事务机制非常简单易用<\/strong>，能甩Java里面的锁、原子类十条街。技术无边界，很显然要借鉴一下。<\/p><p>其实很多编程语言都有从数据库的事务管理中获得灵感，并且总结出了一个新的并发解决方案：<strong>软件事务内存（Software Transactional Memory，简称STM）<\/strong>。传统的数据库事务，支持4个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability），也就是大家常说的ACID，STM由于不涉及到持久化，所以只支持ACI。<\/p><p>STM的使用很简单，下面我们以经典的转账操作为例，看看用STM该如何实现。<\/p><h2>用STM实现转账<\/h2><p>我们曾经在<a href=\"https:\/\/time.geekbang.org\/column\/article\/85001\">《05 | 一不小心就死锁了，怎么办？》<\/a>这篇文章中，讲到了并发转账的例子，示例代码如下。简单地使用 synchronized 将 transfer() 方法变成同步方法并不能解决并发问题，因为还存在死锁问题。<\/p><!-- [[[read_end]]] --><pre><code>class UnsafeAccount {\n  \/\/余额\n  private long balance;\n  \/\/构造函数\n  public UnsafeAccount(long balance) {\n    this.balance = balance;\n  }\n  \/\/转账\n  void transfer(UnsafeAccount target, long amt){\n    if (this.balance &gt; amt) {\n      this.balance -= amt;\n      target.balance += amt;\n    }\n  }\n}\n<\/code><\/pre><p>该转账操作若使用数据库事务就会非常简单，如下面的示例代码所示。如果所有SQL都正常执行，则通过 commit() 方法提交事务；如果SQL在执行过程中有异常，则通过 rollback() 方法回滚事务。数据库保证在并发情况下不会有死锁，而且还能保证前面我们说的原子性、一致性、隔离性和持久性，也就是ACID。<\/p><pre><code>Connection conn = null;\ntry{\n  \/\/获取数据库连接\n  conn = DriverManager.getConnection();\n  \/\/设置手动提交事务\n  conn.setAutoCommit(false);\n  \/\/执行转账SQL\n  ......\n  \/\/提交事务\n  conn.commit();\n} catch (Exception e) {\n  \/\/出现异常回滚事务\n  conn.rollback();\n}\n<\/code><\/pre><p>那如果用STM又该如何实现呢？Java语言并不支持STM，不过可以借助第三方的类库来支持，<a href=\"https:\/\/github.com\/pveentjer\/Multiverse\">Multiverse<\/a>就是个不错的选择。下面的示例代码就是借助Multiverse实现了线程安全的转账操作，相比较上面线程不安全的UnsafeAccount，其改动并不大，仅仅是将余额的类型从 long 变成了 TxnLong ，将转账的操作放到了 atomic(()-&gt;{}) 中。<\/p><pre><code>class Account{\n  \/\/余额\n  private TxnLong balance;\n  \/\/构造函数\n  public Account(long balance){\n    this.balance = StmUtils.newTxnLong(balance);\n  }\n  \/\/转账\n  public void transfer(Account to, int amt){\n    \/\/原子化操作\n    atomic(()-&gt;{\n      if (this.balance.get() &gt; amt) {\n        this.balance.decrement(amt);\n        to.balance.increment(amt);\n      }\n    });\n  }\n}\n<\/code><\/pre><p>一个关键的atomic()方法就把并发问题解决了，这个方案看上去比传统的方案的确简单了很多，那它是如何实现的呢？数据库事务发展了几十年了，目前被广泛使用的是<strong>MVCC<\/strong>（全称是Multi-Version Concurrency Control），也就是多版本并发控制。<\/p><p>MVCC可以简单地理解为数据库事务在开启的时候，会给数据库打一个快照，以后所有的读写都是基于这个快照的。当提交事务的时候，如果所有读写过的数据在该事务执行期间没有发生过变化，那么就可以提交；如果发生了变化，说明该事务和有其他事务读写的数据冲突了，这个时候是不可以提交的。<\/p><p>为了记录数据是否发生了变化，可以给每条数据增加一个版本号，这样每次成功修改数据都会增加版本号的值。MVCC的工作原理和我们曾经在<a href=\"https:\/\/time.geekbang.org\/column\/article\/89456\">《18 | StampedLock：有没有比读写锁更快的锁？》<\/a>中提到的乐观锁非常相似。有不少STM的实现方案都是基于MVCC的，例如知名的Clojure STM。<\/p><p>下面我们就用最简单的代码基于MVCC实现一个简版的STM，这样你会对STM以及MVCC的工作原理有更深入的认识。<\/p><h2>自己实现STM<\/h2><p>我们首先要做的，就是让Java中的对象有版本号，在下面的示例代码中，VersionedRef这个类的作用就是将对象value包装成带版本号的对象。按照MVCC理论，数据的每一次修改都对应着一个唯一的版本号，所以不存在仅仅改变value或者version的情况，用不变性模式就可以很好地解决这个问题，所以VersionedRef这个类被我们设计成了不可变的。<\/p><p>所有对数据的读写操作，一定是在一个事务里面，TxnRef这个类负责完成事务内的读写操作，读写操作委托给了接口Txn，Txn代表的是读写操作所在的当前事务， 内部持有的curRef代表的是系统中的最新值。<\/p><pre><code>\/\/带版本号的对象引用\npublic final class VersionedRef&lt;T&gt; {\n  final T value;\n  final long version;\n  \/\/构造方法\n  public VersionedRef(T value, long version) {\n    this.value = value;\n    this.version = version;\n  }\n}\n\/\/支持事务的引用\npublic class TxnRef&lt;T&gt; {\n  \/\/当前数据，带版本号\n  volatile VersionedRef curRef;\n  \/\/构造方法\n  public TxnRef(T value) {\n    this.curRef = new VersionedRef(value, 0L);\n  }\n  \/\/获取当前事务中的数据\n  public T getValue(Txn txn) {\n    return txn.get(this);\n  }\n  \/\/在当前事务中设置数据\n  public void setValue(T value, Txn txn) {\n    txn.set(this, value);\n  }\n}\n<\/code><\/pre><p>STMTxn是Txn最关键的一个实现类，事务内对于数据的读写，都是通过它来完成的。STMTxn内部有两个Map：inTxnMap，用于保存当前事务中所有读写的数据的快照；writeMap，用于保存当前事务需要写入的数据。每个事务都有一个唯一的事务ID txnId，这个txnId是全局递增的。<\/p><p>STMTxn有三个核心方法，分别是读数据的get()方法、写数据的set()方法和提交事务的commit()方法。其中，get()方法将要读取数据作为快照放入inTxnMap，同时保证每次读取的数据都是一个版本。set()方法会将要写入的数据放入writeMap，但如果写入的数据没被读取过，也会将其放入 inTxnMap。<\/p><p>至于commit()方法，我们为了简化实现，使用了互斥锁，所以事务的提交是串行的。commit()方法的实现很简单，首先检查inTxnMap中的数据是否发生过变化，如果没有发生变化，那么就将writeMap中的数据写入（这里的写入其实就是TxnRef内部持有的curRef）；如果发生过变化，那么就不能将writeMap中的数据写入了。<\/p><pre><code>\/\/事务接口\npublic interface Txn {\n  &lt;T&gt; T get(TxnRef&lt;T&gt; ref);\n  &lt;T&gt; void set(TxnRef&lt;T&gt; ref, T value);\n}\n\/\/STM事务实现类\npublic final class STMTxn implements Txn {\n  \/\/事务ID生成器\n  private static AtomicLong txnSeq = new AtomicLong(0);\n  \n  \/\/当前事务所有的相关数据\n  private Map&lt;TxnRef, VersionedRef&gt; inTxnMap = new HashMap&lt;&gt;();\n  \/\/当前事务所有需要修改的数据\n  private Map&lt;TxnRef, Object&gt; writeMap = new HashMap&lt;&gt;();\n  \/\/当前事务ID\n  private long txnId;\n  \/\/构造函数，自动生成当前事务ID\n  STMTxn() {\n    txnId = txnSeq.incrementAndGet();\n  }\n\n  \/\/获取当前事务中的数据\n  @Override\n  public &lt;T&gt; T get(TxnRef&lt;T&gt; ref) {\n    \/\/将需要读取的数据，加入inTxnMap\n    if (!inTxnMap.containsKey(ref)) {\n      inTxnMap.put(ref, ref.curRef);\n    }\n    return (T) inTxnMap.get(ref).value;\n  }\n  \/\/在当前事务中修改数据\n  @Override\n  public &lt;T&gt; void set(TxnRef&lt;T&gt; ref, T value) {\n    \/\/将需要修改的数据，加入inTxnMap\n    if (!inTxnMap.containsKey(ref)) {\n      inTxnMap.put(ref, ref.curRef);\n    }\n    writeMap.put(ref, value);\n  }\n  \/\/提交事务\n  boolean commit() {\n    synchronized (STM.commitLock) {\n    \/\/是否校验通过\n    boolean isValid = true;\n    \/\/校验所有读过的数据是否发生过变化\n    for(Map.Entry&lt;TxnRef, VersionedRef&gt; entry : inTxnMap.entrySet()){\n      VersionedRef curRef = entry.getKey().curRef;\n      VersionedRef readRef = entry.getValue();\n      \/\/通过版本号来验证数据是否发生过变化\n      if (curRef.version != readRef.version) {\n        isValid = false;\n        break;\n      }\n    }\n    \/\/如果校验通过，则所有更改生效\n    if (isValid) {\n      writeMap.forEach((k, v) -&gt; {\n        k.curRef = new VersionedRef(v, txnId);\n      });\n    }\n    return isValid;\n  }\n}\n<\/code><\/pre><p>下面我们来模拟实现Multiverse中的原子化操作atomic()。atomic()方法中使用了类似于CAS的操作，如果事务提交失败，那么就重新创建一个新的事务，重新执行。<\/p><pre><code>@FunctionalInterface\npublic interface TxnRunnable {\n  void run(Txn txn);\n}\n\/\/STM\npublic final class STM {\n  \/\/私有化构造方法\n  private STM() {\n  \/\/提交数据需要用到的全局锁  \n  static final Object commitLock = new Object();\n  \/\/原子化提交方法\n  public static void atomic(TxnRunnable action) {\n    boolean committed = false;\n    \/\/如果没有提交成功，则一直重试\n    while (!committed) {\n      \/\/创建新的事务\n      STMTxn txn = new STMTxn();\n      \/\/执行业务逻辑\n      action.run(txn);\n      \/\/提交事务\n      committed = txn.commit();\n    }\n  }\n}}\n<\/code><\/pre><p>就这样，我们自己实现了STM，并完成了线程安全的转账操作，使用方法和Multiverse差不多，这里就不赘述了，具体代码如下面所示。<\/p><pre><code>class Account {\n  \/\/余额\n  private TxnRef&lt;Integer&gt; balance;\n  \/\/构造方法\n  public Account(int balance) {\n    this.balance = new TxnRef&lt;Integer&gt;(balance);\n  }\n  \/\/转账操作\n  public void transfer(Account target, int amt){\n    STM.atomic((txn)-&gt;{\n      Integer from = balance.getValue(txn);\n      balance.setValue(from-amt, txn);\n      Integer to = target.balance.getValue(txn);\n      target.balance.setValue(to+amt, txn);\n    });\n  }\n}\n<\/code><\/pre><h2>总结<\/h2><p>STM借鉴的是数据库的经验，数据库虽然复杂，但仅仅存储数据，而编程语言除了有共享变量之外，还会执行各种I\/O操作，很显然I\/O操作是很难支持回滚的。所以，STM也不是万能的。目前支持STM的编程语言主要是函数式语言，函数式语言里的数据天生具备不可变性，利用这种不可变性实现STM相对来说更简单。<\/p><p>另外，需要说明的是，文中的“自己实现STM”部分我参考了<a href=\"http:\/\/www.codecommit.com\/blog\/scala\/software-transactional-memory-in-scala\">Software Transactional Memory in Scala<\/a>这篇博文以及<a href=\"https:\/\/github.com\/epam-mooc\/stm-java\">一个GitHub项目<\/a>，目前还很粗糙，并不是一个完备的MVCC。如果你对这方面感兴趣，可以参考<a href=\"http:\/\/www.codecommit.com\/blog\/scala\/improving-the-stm-multi-version-concurrency-control\">Improving the STM: Multi-Version Concurrency Control<\/a> 这篇博文，里面讲到了如何优化，你可以尝试学习下。<\/p><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。<\/p><p><\/p>","footer_cover_data":{"img_url":"","mp_url":"","link_url":""},"article_cover_hidden":false,"column_is_experience":false,"is_required":true,"rate":{},"product_id":100023901,"like_count":108,"had_liked":false,"article_subtitle":"","audio_download_url":"https:\/\/static001.geekbang.org\/resource\/audio\/a3\/ce\/a3c1bfcb3946a823b59da193a830aece.mp3","id":99251,"had_viewed":false,"article_title":"43 | 软件事务内存：借鉴数据库的并发经验","column_bgcolor":"#cbd0de","share":{"content":"当面试时问到多线程、锁的问题，你还是答不上来怎么办？推荐给你《Java 并发编程实战》专栏，带你搞懂并发里的那些Bug问题，全面提升你的并发编程能力，大厂面试绝对不是问题。","title":"王宝令 · Java并发编程实战","poster":"https:\/\/static001.geekbang.org\/resource\/image\/ce\/50\/cebb5cfded54f4bfcca4d75ffe915350.jpg","cover":"https:\/\/static001.geekbang.org\/resource\/image\/47\/f1\/47296780442c7fd11ebf97c0749103f1.jpg"},"is_video_preview":false,"article_summary":"很多编程语言都有从数据库的事务管理中获得灵感，并且总结出了一个新的并发解决方案：软件事务内存，简称STM。","article_poster_wxlite":"https:\/\/static001.geekbang.org\/render\/screen\/63\/e0\/63046e079d8f2200cabd6fd65ff458e0.jpeg","column_sale_type":2,"article_features":0,"article_could_preview":false,"column_cover":"https:\/\/static001.geekbang.org\/resource\/image\/47\/f1\/47296780442c7fd11ebf97c0749103f1.jpg","column_id":159,"audio_time_arr":{"m":"07","s":"36","h":"00"},"video_time":"","audio_title":"修改 宝令43_01","audio_md5":"a3c1bfcb3946a823b59da193a830aece","video_size":0,"text_read_percent":0,"comment_count":24,"cid":159,"article_sharetitle":"软件事务内存：借鉴数据库的并发经验","column_is_onboard":true,"article_cshort":"<p>很多同学反馈说，工作了挺长时间但是没有机会接触并发编程，实际上我们天天都在写并发程序，只不过并发相关的问题都被类似Tomcat这样的Web服务器以及MySQL这样的数据库解决了。尤其是数据库，在解决并发问题方面，可谓成绩斐然，它的<strong>事务机制非常简单易用<\/strong>，能甩Java里面的锁、原子类十条街。技术无边界，很显然要借鉴一下。<\/p><p>其实很多编程语言都有从数据库的事务管理中获得灵感，并且总结出了一个新的并发解决方案：<strong>软件事务内存（Software Transactional Memory，简称STM）<\/strong>。传统的数据库事务，支持4个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability），也就是大家常说的ACID，STM由于不涉及到持久化，所以只支持ACI。<\/p><p>STM的使用很简单，下面我们以经典的转账操作为例，看看用STM该如何实现。<\/p><h2>用STM实现转账<\/h2><p>我们曾经在<a href=\"https:\/\/time.geekbang.org\/column\/article\/85001\">《05 | 一不小心就死锁了，怎么办？》<\/a>这篇文章中，讲到了并发转账的例子，示例代码如下。简单地使用 synchronized 将 transfer() 方法变成同步方法并不能解决并发问题，因为还存在死锁问题。<\/p>","video_width":0,"column_could_sub":true,"article_ctime":1559750400,"score":"71559750400","video_media_map":{},"video_preview":{},"video":0,"video_time_arr":{"m":"","s":"","h":""},"video_total_seconds":0},"extra":{},"error":{}}