{"code":0,"data":{"video_id":"","sku":"100028001","video_cover":"","author_name":"刘超","text_read_version":0,"audio_size":8923846,"article_cover":"https:\/\/static001.geekbang.org\/resource\/image\/e6\/7c\/e6594a7439c66baccc62c9f8b788b97c.jpg","subtitles":{},"product_type":"c1","audio_url":"https:\/\/res001.geekbang.org\/\/media\/audio\/46\/cb\/4626e35f79a15ac12587ea4213dfb0cb\/ld\/ld.m3u8","chapter_id":"0","column_had_sub":true,"audio_dubber":"李良","is_finished":false,"inline_video_subtitles":{},"like":{"had_done":false,"count":67},"neighbors":{"left":{"id":110862,"article_title":"29 | 如何使用设计模式优化并发编程？"},"right":{"id":111600,"article_title":"31 | 装饰器模式：如何优化电商系统中复杂的商品价格策略？"}},"audio_time":"00:09:17","video_height":0,"rate_percent":0,"article_content":"<p>你好，我是刘超。<\/p><p>生产者消费者模式，在之前的一些案例中，我们是有使用过的，相信你有一定的了解。这个模式是一个十分经典的多线程并发协作模式，生产者与消费者是通过一个中间容器来解决强耦合关系，并以此来实现不同的生产与消费速度，从而达到缓冲的效果。<\/p><p>使用生产者消费者模式，可以提高系统的性能和吞吐量，今天我们就来看看该模式的几种实现方式，还有其在电商库存中的应用。<\/p><h2>Object的wait\/notify\/notifyAll实现生产者消费者<\/h2><p>在<a href=\"https:\/\/time.geekbang.org\/column\/article\/102974\">第16讲<\/a>中，我就曾介绍过使用Object的wait\/notify\/notifyAll实现生产者消费者模式，这种方式是基于Object的wait\/notify\/notifyAll与对象监视器（Monitor）实现线程间的等待和通知。<\/p><p>还有，在<a href=\"https:\/\/time.geekbang.org\/column\/article\/101244\">第12讲<\/a>中我也详细讲解过Monitor的工作原理，借此我们可以得知，这种方式实现的生产者消费者模式是基于内核来实现的，有可能会导致大量的上下文切换，所以性能并不是最理想的。<\/p><h2>Lock中Condition的await\/signal\/signalAll实现生产者消费者<\/h2><p>相对Object类提供的wait\/notify\/notifyAll方法实现的生产者消费者模式，我更推荐使用java.util.concurrent包提供的Lock &amp;&amp; Condition实现的生产者消费者模式。<\/p><!-- [[[read_end]]] --><p>在接口Condition类中定义了await\/signal\/signalAll 方法，其作用与Object的wait\/notify\/notifyAll方法类似，该接口类与显示锁Lock配合，实现对线程的阻塞和唤醒操作。<\/p><p>我在<a href=\"https:\/\/time.geekbang.org\/column\/article\/101651\">第13讲<\/a>中详细讲到了显示锁，显示锁ReentrantLock或ReentrantReadWriteLock都是基于AQS实现的，而在AQS中有一个内部类ConditionObject实现了Condition接口。<\/p><p>我们知道AQS中存在一个同步队列（CLH队列），当一个线程没有获取到锁时就会进入到同步队列中进行阻塞，如果被唤醒后获取到锁，则移除同步队列。<\/p><p>除此之外，AQS中还存在一个条件队列，通过addWaiter方法，可以将await()方法调用的线程放入到条件队列中，线程进入等待状态。当调用signal以及signalAll 方法后，线程将会被唤醒，并从条件队列中删除，之后进入到同步队列中。条件队列是通过一个单向链表实现的，所以Condition支持多个等待队列。<\/p><p>由上可知，Lock中Condition的await\/signal\/signalAll实现的生产者消费者模式，是基于Java代码层实现的，所以在性能和扩展性方面都更有优势。<\/p><p>下面来看一个案例，我们通过一段代码来实现一个商品库存的生产和消费。<\/p><pre><code>public class LockConditionTest {\n\n\tprivate LinkedList&lt;String&gt; product = new LinkedList&lt;String&gt;();\n\n\tprivate int maxInventory = 10; \/\/ 最大库存\n\n\tprivate Lock lock = new ReentrantLock();\/\/ 资源锁\n\n\tprivate Condition condition = lock.newCondition();\/\/ 库存非满和非空条件\n\n\t\/**\n\t * 新增商品库存\n\t * @param e\n\t *\/\n\tpublic void produce(String e) {\n\t\tlock.lock();\n\t\ttry {\n\t\t\twhile (product.size() == maxInventory) {\n\t\t\t\tcondition.await();\n\t\t\t}\n\n\t\t\tproduct.add(e);\n\t\t\tSystem.out.println(&quot;放入一个商品库存，总库存为：&quot; + product.size());\n\t\t\tcondition.signalAll();\n\n\t\t} catch (Exception ex) {\n\t\t\tex.printStackTrace();\n\t\t} finally {\n\t\t\tlock.unlock();\n\t\t}\n\t}\n\n\t\/**\n\t * 消费商品\n\t * @return\n\t *\/\n\tpublic String consume() {\n\t\tString result = null;\n\t\tlock.lock();\n\t\ttry {\n\t\t\twhile (product.size() == 0) {\n\t\t\t\tcondition.await();\n\t\t\t}\n\n\t\t\tresult = product.removeLast();\n\t\t\tSystem.out.println(&quot;消费一个商品，总库存为：&quot; + product.size());\n\t\t\tcondition.signalAll();\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tlock.unlock();\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t\/**\n\t * 生产者\n\t * @author admin\n\t *\n\t *\/\n\tprivate class Producer implements Runnable {\n\n\t\tpublic void run() {\n\t\t\tfor (int i = 0; i &lt; 20; i++) {\n\t\t\t\tproduce(&quot;商品&quot; + i);\n\t\t\t}\n\t\t}\n\n\t}\n\n\t\/**\n\t * 消费者\n\t * @author admin\n\t *\n\t *\/\n\tprivate class Customer implements Runnable {\n\n\t\tpublic void run() {\n\t\t\tfor (int i = 0; i &lt; 20; i++) {\n\t\t\t\tconsume();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\tLockConditionTest lc = new LockConditionTest();\n\t\tnew Thread(lc.new Producer()).start();\n\t\tnew Thread(lc.new Customer()).start();\n\t\tnew Thread(lc.new Producer()).start();\n\t\tnew Thread(lc.new Customer()).start();\n\n\t}\n}\n<\/code><\/pre><p>看完案例，请你思考下，我们对此还有优化的空间吗？<\/p><p>从代码中应该不难发现，生产者和消费者都在竞争同一把锁，而实际上两者没有同步关系，由于Condition能够支持多个等待队列以及不响应中断， 所以我们可以将生产者和消费者的等待条件和锁资源分离，从而进一步优化系统并发性能，代码如下：<\/p><pre><code>\tprivate LinkedList&lt;String&gt; product = new LinkedList&lt;String&gt;();\n\tprivate AtomicInteger inventory = new AtomicInteger(0);\/\/实时库存\n\n\tprivate int maxInventory = 10; \/\/ 最大库存\n\n\tprivate Lock consumerLock = new ReentrantLock();\/\/ 资源锁\n\tprivate Lock productLock = new ReentrantLock();\/\/ 资源锁\n\n\tprivate Condition notEmptyCondition = consumerLock.newCondition();\/\/ 库存满和空条件\n\tprivate Condition notFullCondition = productLock.newCondition();\/\/ 库存满和空条件\n\n\t\/**\n\t * 新增商品库存\n\t * @param e\n\t *\/\n\tpublic void produce(String e) {\n\t\tproductLock.lock();\n\t\ttry {\n\t\t\twhile (inventory.get() == maxInventory) {\n\t\t\t\tnotFullCondition.await();\n\t\t\t}\n\n\t\t\tproduct.add(e);\n\t\t\t\n\t\t\tSystem.out.println(&quot;放入一个商品库存，总库存为：&quot; + inventory.incrementAndGet());\n\t\t\t\n\t\t\tif(inventory.get()&lt;maxInventory) {\n\t\t\t\tnotFullCondition.signalAll();\n\t\t\t}\n\n\t\t} catch (Exception ex) {\n\t\t\tex.printStackTrace();\n\t\t} finally {\n\t\t\tproductLock.unlock();\n\t\t}\n\t\t\n\t\tif(inventory.get()&gt;0) {\n\t\t\ttry {\n\t\t\t\tconsumerLock.lockInterruptibly();\n\t\t\t\tnotEmptyCondition.signalAll();\n\t\t\t} catch (InterruptedException e1) {\n\t\t\t\t\/\/ TODO Auto-generated catch block\n\t\t\t\te1.printStackTrace();\n\t\t\t}finally {\n\t\t\t\tconsumerLock.unlock();\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\t\/**\n\t * 消费商品\n\t * @return\n\t *\/\n\tpublic String consume() {\n\t\tString result = null;\n\t\tconsumerLock.lock();\n\t\ttry {\n\t\t\twhile (inventory.get() == 0) {\n\t\t\t\tnotEmptyCondition.await();\n\t\t\t}\n\n\t\t\tresult = product.removeLast();\n\t\t\tSystem.out.println(&quot;消费一个商品，总库存为：&quot; + inventory.decrementAndGet());\n\t\t\t\n\t\t\tif(inventory.get()&gt;0) {\n\t\t\t\tnotEmptyCondition.signalAll();\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tconsumerLock.unlock();\n\t\t}\n\t\t\n\t\tif(inventory.get()&lt;maxInventory) {\n\t\t\t\n\t\t\ttry {\n\t\t\t\tproductLock.lockInterruptibly();\n\t\t\t\tnotFullCondition.signalAll();\n\t\t\t} catch (InterruptedException e1) {\n\t\t\t\t\/\/ TODO Auto-generated catch block\n\t\t\t\te1.printStackTrace();\n\t\t\t}finally {\n\t\t\t\tproductLock.unlock();\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\t\/**\n\t * 生产者\n\t * @author admin\n\t *\n\t *\/\n\tprivate class Producer implements Runnable {\n\n\t\tpublic void run() {\n\t\t\tfor (int i = 0; i &lt; 20; i++) {\n\t\t\t\tproduce(&quot;商品&quot; + i);\n\t\t\t}\n\t\t}\n\t}\n\n\t\/**\n\t * 消费者\n\t * @author admin\n\t *\n\t *\/\n\tprivate class Customer implements Runnable {\n\n\t\tpublic void run() {\n\t\t\tfor (int i = 0; i &lt; 20; i++) {\n\t\t\t\tconsume();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\tLockConditionTest2 lc = new LockConditionTest2();\n\t\tnew Thread(lc.new Producer()).start();\n\t\tnew Thread(lc.new Customer()).start();\n\n\t}\n}\n<\/code><\/pre><p>我们分别创建  productLock 以及  consumerLock  两个锁资源，前者控制生产者线程并行操作，后者控制消费者线程并发运行；同时也设置两个条件变量，一个是notEmptyCondition，负责控制消费者线程状态，一个是notFullCondition，负责控制生产者线程状态。这样优化后，可以减少消费者与生产者的竞争，实现两者并发执行。<\/p><p>我们这里是基于LinkedList来存取库存的，虽然LinkedList是非线程安全，但我们新增是操作头部，而消费是操作队列的尾部，理论上来说没有线程安全问题。而库存的实际数量inventory是基于AtomicInteger（CAS锁）线程安全类实现的，既可以保证原子性，也可以保证消费者和生产者之间是可见的。<\/p><h2>BlockingQueue实现生产者消费者<\/h2><p>相对前两种实现方式，BlockingQueue实现是最简单明了的，也是最容易理解的。<\/p><p>因为BlockingQueue是线程安全的，且从队列中获取或者移除元素时，如果队列为空，获取或移除操作则需要等待，直到队列不为空；同时，如果向队列中添加元素，假设此时队列无可用空间，添加操作也需要等待。所以BlockingQueue非常适合用来实现生产者消费者模式。还是以一个案例来看下它的优化，代码如下：<\/p><pre><code>public class BlockingQueueTest {\n\n\tprivate int maxInventory = 10; \/\/ 最大库存\n\n\tprivate BlockingQueue&lt;String&gt; product = new LinkedBlockingQueue&lt;&gt;(maxInventory);\/\/缓存队列\n\n\t\/**\n\t * 新增商品库存\n\t * @param e\n\t *\/\n\tpublic void produce(String e) {\n\t\ttry {\n\t\t\tproduct.put(e);\n\t\t\tSystem.out.println(&quot;放入一个商品库存，总库存为：&quot; + product.size());\n\t\t} catch (InterruptedException e1) {\n\t\t\t\/\/ TODO Auto-generated catch block\n\t\t\te1.printStackTrace();\n\t\t}\n\t}\n\n\t\/**\n\t * 消费商品\n\t * @return\n\t *\/\n\tpublic String consume() {\n\t\tString result = null;\n\t\ttry {\n\t\t\tresult = product.take();\n\t\t\tSystem.out.println(&quot;消费一个商品，总库存为：&quot; + product.size());\n\t\t} catch (InterruptedException e) {\n\t\t\t\/\/ TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t\/**\n\t * 生产者\n\t * @author admin\n\t *\n\t *\/\n\tprivate class Producer implements Runnable {\n\n\t\tpublic void run() {\n\t\t\tfor (int i = 0; i &lt; 20; i++) {\n\t\t\t\tproduce(&quot;商品&quot; + i);\n\t\t\t}\n\t\t}\n\n\t}\n\n\t\/**\n\t * 消费者\n\t * @author admin\n\t *\n\t *\/\n\tprivate class Customer implements Runnable {\n\n\t\tpublic void run() {\n\t\t\tfor (int i = 0; i &lt; 20; i++) {\n\t\t\t\tconsume();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\tBlockingQueueTest lc = new BlockingQueueTest();\n\t\tnew Thread(lc.new Producer()).start();\n\t\tnew Thread(lc.new Customer()).start();\n\t\tnew Thread(lc.new Producer()).start();\n\t\tnew Thread(lc.new Customer()).start();\n\n\t}\n}\n<\/code><\/pre><p>在这个案例中，我们创建了一个LinkedBlockingQueue，并设置队列大小。之后我们创建一个消费方法consume()，方法里面调用LinkedBlockingQueue中的take()方法，消费者通过该方法获取商品，当队列中商品数量为零时，消费者将进入等待状态；我们再创建一个生产方法produce()，方法里面调用LinkedBlockingQueue中的put()方法，生产方通过该方法往队列中放商品，如果队列满了，生产者就将进入等待状态。<\/p><h2>生产者消费者优化电商库存设计<\/h2><p>了解完生产者消费者模式的几种常见实现方式，接下来我们就具体看看该模式是如何优化电商库存设计的。<\/p><p>电商系统中经常会有抢购活动，在这类促销活动中，抢购商品的库存实际是存在库存表中的。为了提高抢购性能，我们通常会将库存存放在缓存中，通过缓存中的库存来实现库存的精确扣减。在提交订单并付款之后，我们还需要再去扣除数据库中的库存。如果遇到瞬时高并发，我们还都去操作数据库的话，那么在单表单库的情况下，数据库就很可能会出现性能瓶颈。<\/p><p>而我们库存表如果要实现分库分表，势必会增加业务的复杂度。试想一个商品的库存分别在不同库的表中，我们在扣除库存时，又该如何判断去哪个库中扣除呢？<\/p><p>如果随意扣除表中库存，那么就会出现有些表已经扣完了，有些表中还有库存的情况，这样的操作显然是不合理的，此时就需要额外增加逻辑判断来解决问题。<\/p><p>在不分库分表的情况下，为了提高订单中扣除库存业务的性能以及吞吐量，我们就可以采用生产者消费者模式来实现系统的性能优化。<\/p><p>创建订单等于生产者，存放订单的队列则是缓冲容器，而从队列中消费订单则是数据库扣除库存操作。其中存放订单的队列可以极大限度地缓冲高并发给数据库带来的压力。<\/p><p>我们还可以基于消息队列来实现生产者消费者模式，如今RabbitMQ、RocketMQ都实现了事务，我们只需要将订单通过事务提交到MQ中，扣除库存的消费方只需要通过消费MQ来逐步操作数据库即可。<\/p><h2>总结<\/h2><p>使用生产者消费者模式来缓冲高并发数据库扣除库存压力，类似这样的例子其实还有很多。<\/p><p>例如，我们平时使用消息队列来做高并发流量削峰，也是基于这个原理。抢购商品时，如果所有的抢购请求都直接进入判断是否有库存和冻结缓存库存等逻辑业务中，由于这些逻辑业务操作会增加资源消耗，就可能会压垮应用服务。此时，为了保证系统资源使用的合理性，我们可以通过一个消息队列来缓冲瞬时的高并发请求。<\/p><p>生产者消费者模式除了可以做缓冲优化系统性能之外，它还可以应用在处理一些执行任务时间比较长的场景中。<\/p><p>例如导出报表业务，用户在导出一种比较大的报表时，通常需要等待很长时间，这样的用户体验是非常差的。通常我们可以固定一些报表内容，比如用户经常需要在今天导出昨天的销量报表，或者在月初导出上个月的报表，我们就可以提前将报表导出到本地或内存中，这样用户就可以在很短的时间内直接下载报表了。<\/p><h2>思考题<\/h2><p>我们可以用生产者消费者模式来实现瞬时高并发的流量削峰，然而这样做虽然缓解了消费方的压力，但生产方则会因为瞬时高并发，而发生大量线程阻塞。面对这样的情况，你知道有什么方式可以优化线程阻塞所带来的性能问题吗？<\/p><p>期待在留言区看到你的见解。也欢迎你点击“请朋友读”，把今天的内容分享给身边的朋友，邀请他一起讨论。<\/p><p><\/p>","footer_cover_data":{"img_url":"","mp_url":"","link_url":""},"article_cover_hidden":false,"column_is_experience":false,"is_required":true,"rate":{},"product_id":100028001,"like_count":86,"had_liked":false,"article_subtitle":"无","audio_download_url":"https:\/\/static001.geekbang.org\/resource\/audio\/46\/cb\/4626e35f79a15ac12587ea4213dfb0cb.mp3","id":111288,"had_viewed":false,"article_title":"30 | 生产者消费者模式：电商库存设计优化","column_bgcolor":"#F6F7FB","share":{"content":"覆盖80%以上Java应用调优场景","title":"刘超 · Java性能调优实战","poster":"https:\/\/static001.geekbang.org\/resource\/image\/ed\/99\/edfa939ff065cb8368ed4227930df399.jpg","cover":"https:\/\/static001.geekbang.org\/resource\/image\/b2\/01\/b2f97b2cbefe40e19af4d28508387e01.jpg"},"is_video_preview":false,"article_summary":"今天介绍生产者消费者模式的几种实现方式，还有其在电商库存中的应用。","article_poster_wxlite":"https:\/\/static001.geekbang.org\/render\/screen\/7a\/14\/7aa2282ffbf4ae09735d4edb24bed114.jpeg","column_sale_type":1,"article_features":0,"article_could_preview":false,"column_cover":"https:\/\/static001.geekbang.org\/resource\/image\/b2\/01\/b2f97b2cbefe40e19af4d28508387e01.jpg","column_id":185,"audio_time_arr":{"m":"09","s":"17","h":"00"},"video_time":"","audio_title":"金山刘超-29-1","audio_md5":"4626e35f79a15ac12587ea4213dfb0cb","video_size":0,"text_read_percent":0,"comment_count":33,"cid":185,"article_sharetitle":"生产者消费者模式：电商库存设计优化","column_is_onboard":true,"article_cshort":"<p>你好，我是刘超。<\/p><p>生产者消费者模式，在之前的一些案例中，我们是有使用过的，相信你有一定的了解。这个模式是一个十分经典的多线程并发协作模式，生产者与消费者是通过一个中间容器来解决强耦合关系，并以此来实现不同的生产与消费速度，从而达到缓冲的效果。<\/p><p>使用生产者消费者模式，可以提高系统的性能和吞吐量，今天我们就来看看该模式的几种实现方式，还有其在电商库存中的应用。<\/p><h2>Object的wait\/notify\/notifyAll实现生产者消费者<\/h2><p>在<a href=\"https:\/\/time.geekbang.org\/column\/article\/102974\">第16讲<\/a>中，我就曾介绍过使用Object的wait\/notify\/notifyAll实现生产者消费者模式，这种方式是基于Object的wait\/notify\/notifyAll与对象监视器（Monitor）实现线程间的等待和通知。<\/p><p>还有，在<a href=\"https:\/\/time.geekbang.org\/column\/article\/101244\">第12讲<\/a>中我也详细讲解过Monitor的工作原理，借此我们可以得知，这种方式实现的生产者消费者模式是基于内核来实现的，有可能会导致大量的上下文切换，所以性能并不是最理想的。<\/p><h2>Lock中Condition的await\/signal\/signalAll实现生产者消费者<\/h2><p>相对Object类提供的wait\/notify\/notifyAll方法实现的生产者消费者模式，我更推荐使用java.util.concurrent包提供的Lock &amp;&amp; Condition实现的生产者消费者模式。<\/p>","video_width":0,"column_could_sub":true,"article_ctime":1564416000,"score":"61564416000","video_media_map":{},"video_preview":{},"video":0,"video_time_arr":{"m":"","s":"","h":""},"video_total_seconds":0},"extra":{},"error":{}}