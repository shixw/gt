{"code":0,"data":{"video_id":"","sku":"100114001","video_cover":"","author_name":"丁威","text_read_version":0,"audio_size":7855476,"article_cover":"https:\/\/static001.geekbang.org\/resource\/image\/0e\/76\/0eb44e087e5ccb3fb10edca32d2c3676.jpg","subtitles":{},"product_type":"c1","audio_url":"https:\/\/res001.geekbang.org\/media\/audio\/de\/cf\/de05ff84094f470173d092947c18c5cf\/ld\/ld.m3u8","chapter_id":"0","column_had_sub":true,"audio_dubber":"丁威","is_finished":false,"inline_video_subtitles":{},"like":{"had_done":false,"count":0},"neighbors":{"left":{"id":535851,"article_title":"10｜设计原理：Dubbo核心设计原理剖析"},"right":{"id":537518,"article_title":"12｜案例：如何实现蓝绿发布？"}},"audio_time":"00:08:12","video_height":0,"rate_percent":0,"article_content":"<p>你好，我是丁威。<\/p><p>这节课我们通过一个真实的业务场景来看看Dubbo网关（开放平台）的设计要领。<\/p><h2>设计背景<\/h2><p>要设计一个网关，我们首先要知道它的设计背景。<\/p><p>2017年，我从传统行业脱身，正式进入物流行业。说来也非常巧，我当时加入的是公司的网关项目组，主要解决泛化调用与协议转换代码的开发问题。刚进公司不久，网关项目组就遇到了技术难题。快递物流行业的业务量可以比肩互联网，从那时候开始，我的传统技术思维开始向互联网技术思维转变。<\/p><p>当时网关项目组的核心任务就是确保能够快速接入各个电商平台。我来简单说明一下具体的场景。<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/yy\/af\/yya8c848bc0c0870d5bb5b6bb41268af.jpg?wh=1920x539\" alt=\"图片\"><\/p><p>解释一下上面这个图。<\/p><p>物流公司内部已经基于Dubbo构建了订单中心微服务域，其中创建订单接口的定义如下：​<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/c4\/61\/c4yy4a46bcb07cbbfb6f0fe750de8861.jpg?wh=1920x936\" alt=\"图片\"><\/p><p>外部电商平台众多，每一家电商平台内部都有自己的标准，并不会遵循统一的标准。例如在淘宝中，当用户购买商品后，淘宝内部会定义一个统一的订单外派接口。它的请求包可能是这样的：<\/p><pre><code class=\"language-plain\">{\n &nbsp;\"seller_id\":189,\n &nbsp;\"buyer\":\"dingwei\",\n &nbsp;\"order\":[\n &nbsp;  {\n &nbsp; &nbsp; &nbsp;\"goods_name\":\"华为笔记本\",\n &nbsp; &nbsp; &nbsp;\"num\":1,\n &nbsp; &nbsp; &nbsp;\"price\":500000\n &nbsp;  },\n &nbsp;  {\n &nbsp; &nbsp; &nbsp;\"goods_name\":\"华为手表\",\n &nbsp; &nbsp; &nbsp;\"num\":1,\n &nbsp; &nbsp; &nbsp;\"price\":200000\n &nbsp;  }\n  ]\n}\n<\/code><\/pre><!-- [[[read_end]]] --><p>但拼多多内部定义的订单外派接口，它的请求包可能是下面这样的：<\/p><pre><code class=\"language-plain\">&lt;order&gt;\n &nbsp;&lt;seller_uid&gt;189&lt;\/seller_uid&gt;\n &nbsp;&lt;buyer_uid&gt;dingwei&lt;\/buyer_uid&gt;\n &nbsp;&lt;order_items&gt;\n &nbsp; &nbsp;&lt;order_item&gt;\n &nbsp; &nbsp; &nbsp;&lt;goods_name&gt;华为笔记本&lt;\/goods_name&gt;\n &nbsp; &nbsp; &nbsp;&lt;num&gt;1&lt;\/num&gt;\n &nbsp; &nbsp; &nbsp;&lt;price&gt;500000&lt;\/price&gt;\n &nbsp; &nbsp;&lt;\/order_item&gt;\n &nbsp; &nbsp;&lt;order_item&gt;\n &nbsp; &nbsp; &nbsp;&lt;goods_name&gt;华为手表&lt;\/goods_name&gt;\n &nbsp; &nbsp; &nbsp;&lt;num&gt;1&lt;\/num&gt;\n &nbsp; &nbsp; &nbsp;&lt;price&gt;200000&lt;\/price&gt;\n &nbsp; &nbsp;&lt;\/order_item&gt;\n &nbsp;&lt;\/order_items&gt;\n&lt;\/order&gt;\n<\/code><\/pre><p>当电商的快递件占据快递公司总业务量的大半时，电商平台的话语权是高于快递公司的。也就是说，电商平台不管下游对接哪家物流公司，都会下发自己公司内部定义的订单派发接口，适配工作需要由物流公司自己来承担。<\/p><p>那站在物流公司的角度，应该怎么做呢？总不能每接入一个电商平台就为它们开发一套下单服务吧？那样的话，随着越来越多的电商平台接入，系统的复杂度会越来越高，可维护性将越来越差。<\/p><h2>设计方案<\/h2><p>正是在这样的背景下，网关平台被立项开发出来了。这个网关平台是怎么设计的呢？在设计的过程中需要解决哪些常见的问题？<\/p><p>我认为，网关的设计至少需要包括三个方面，分别是签名验证、服务配置和限流。<\/p><p>先说签名验证。保证请求的安全是系统设计需要优先考虑的。业界有一种非常经典的通信安全校验机制：<strong>验证签名。<\/strong><\/p><p>这种机制的做法是，客户端与服务端会首先采用HTTPS进行通信，确保传输过程的私密性。<\/p><p>客户端在发送请求时，先将请求参数按参数名称进行排序，然后按顺序拼接成字符串，格式为key1=a &amp; key2=b。接下来，客户端使用一个约定的密钥对拼接出来的参数字符串进行签名，生成签名字符串（我们用sign表示签名字符串）并追加到URL。通常，还会在URL中追加一个发送时间戳（时间戳不参与签名验证）。<\/p><p>服务端在接收到客户端的请求后，先从请求中解析出所有的参数，同样按照参数名对参数进行排序，然后使用同样的密钥对参数进行签名。得到的签名字符串需要与客户端计算的签名字符串进行对比，如果两者不同，则请求无效。与此同时，通常我们还需要将服务端当前的时间戳与客户端时间戳进行对比，如果相差超过一定的时间，同样认为请求无效，这个操作主要是为了避免使用同一个连接对网络进行连续攻击。<\/p><p>这整个过程里有一个非常重要的点，就是密钥自始至终并没有在网络上进行过传播，它的安全性可以得到十足的保证。签名验证的流程大概可以用下面这张图表示：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/cb\/7d\/cb6c980fabc1afd0e76c4fe6627ce87d.jpg?wh=1920x1367\" alt=\"图片\"><\/p><p>如果要对验证签名进行产品化设计，我们通常需要：<\/p><ol>\n<li>为不同的接入端（电商平台）创建不同的密钥，并通过安全的方式告知他们；<\/li>\n<li>为不同的接入端（电商平台）配置签名算法。<\/li>\n<\/ol><p>在确保能够安全通信后，接下来就是网关设计最核心的部分了：<strong>服务接口配置化。<\/strong>它主要包括两个要点：微服务调用协议（Dubbo服务描述）和接口定义与参数映射。<\/p><p>我们先来看一下微服务调用协议的配置，设计的原型界面如下图所示：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/6e\/59\/6eed0bd5cbe4891082bb3e0678cb7b59.jpg?wh=1920x668\" alt=\"图片\"><\/p><p>将所有的微服务（细化到方法级名称）维护到网关系统中，网关应用就可以使用Dubbo提供的编程API，根据这些元信息动态构建一个个消费者（服务调用者），进而通过创建的服务调用客户端发起RPC远程调用，最终实现网关应用的Dubbo服务调用。<\/p><p>基于这些元信息构建消费者对象的关键代码如下：<\/p><pre><code class=\"language-plain\">public static GenericService getInvoker(String serviceInterface, String version, List&lt;String&gt; methods, int retry, String registryAddr ) {\n &nbsp; &nbsp; &nbsp; &nbsp;ReferenceConfig referenceConfig = new ReferenceConfig();\n &nbsp; &nbsp; &nbsp; &nbsp;\/\/ 关于消费者通用参数，可以从配置文件中获取，本示例取消\n &nbsp; &nbsp; &nbsp; &nbsp;ConsumerConfig consumerConfig = new ConsumerConfig();\n &nbsp; &nbsp; &nbsp; &nbsp;consumerConfig.setTimeout(3000);\n &nbsp; &nbsp; &nbsp; &nbsp;consumerConfig.setRetries(2);\n &nbsp; &nbsp; &nbsp; &nbsp;referenceConfig.setConsumer(consumerConfig);\n &nbsp; &nbsp; &nbsp; &nbsp;\/\/应用程序名称\n &nbsp; &nbsp; &nbsp; &nbsp;ApplicationConfig applicationConfig = new ApplicationConfig();\n &nbsp; &nbsp; &nbsp; &nbsp;applicationConfig.setName(\"GateWay\");\n &nbsp; &nbsp; &nbsp; &nbsp;referenceConfig.setApplication(applicationConfig);\n &nbsp; &nbsp; &nbsp; &nbsp;\/\/ 注册中心\n &nbsp; &nbsp; &nbsp; &nbsp;RegistryConfig registry = new RegistryConfig();\n &nbsp; &nbsp; &nbsp; &nbsp;registry.setAddress(registryAddr);\n &nbsp; &nbsp; &nbsp; &nbsp;registry.setProtocol(\"zookeeper\");\n &nbsp; &nbsp; &nbsp; &nbsp;referenceConfig.setRegistry(registry);\n &nbsp; &nbsp; &nbsp; &nbsp;\/\/ 设置服务接口名称\n &nbsp; &nbsp; &nbsp; &nbsp;referenceConfig.setInterface(serviceInterface);\n &nbsp; &nbsp; &nbsp; &nbsp;\/\/ 设置服务版本\n &nbsp; &nbsp; &nbsp; &nbsp;referenceConfig.setVersion(version);\n &nbsp; &nbsp; &nbsp; &nbsp;referenceConfig.setMethods(new ArrayList&lt;MethodConfig&gt;());\n &nbsp; &nbsp; &nbsp; &nbsp;for(String method : methods) {\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;MethodConfig methodConfig = new MethodConfig();\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;methodConfig.setName(method);\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;referenceConfig.getMethods().add(methodConfig);\n &nbsp; &nbsp; &nbsp;  }\n &nbsp; &nbsp; &nbsp; &nbsp;referenceConfig.setGeneric(\"true\");\/\/ 开启dubbo的泛化调用\n &nbsp; &nbsp; &nbsp; &nbsp;return (GenericService) referenceConfig.get();\n &nbsp;  }\n<\/code><\/pre><p>通过getInvoker方法发起调用远程RPC服务，这样，<strong>网关应用就成为了对应服务的消费者<\/strong>。<\/p><p>因为网关应用引入服务规约（API包）不太现实，所以这里使用的是泛化调用，这样方便网关应用不受约束地构建消费者对象。<\/p><p>值得注意的是，ReferenceConfig实例很重，它封装了与注册中心的连接以及所有服务提供者的连接，需要被缓存起来。因此，在真实的生产实践中，我们需要将ReferenceConfig对象存储到缓存中。否则，重复生成的ReferenceConfig可能造成性能问题并伴随着内存和连接泄漏。<\/p><p>除了ReferenceConfig，其实getInvoker生成对象也可以进行缓存，缓存的key通常为接口名称、版本和注册中心。<\/p><p>那如果配置信息动态发生了变化，例如需要添加新的服务，这时候网关应用如何做到动态感知呢？我们通常可以用基于MQ的方式来解决这个问题。具体的解决方案如下：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/01\/0e\/01a98d71ee4b0a1c56a390eb8e338f0e.jpg?wh=1920x619\" alt=\"图片\"><\/p><p>也就是说，用户如果在网关运营平台上修改原有服务协议（Dubbo服务）或者添加新的服务协议，变动后的协议会首先存储到数据库中，然后运营平台发送一条消息到MQ，紧接着Gateway的后台进程以广播模式进行订阅。这样，所有后台网关进程都可以感知。<\/p><p>如果是对已有服务协议进行修改，在具体实践时有一个小细节请你一定注意。我们先看看这段代码：<\/p><pre><code class=\"language-plain\">Map&lt;String \/* 缓存key *\/,GenericService&gt; invokerCache;\nGenericService newInvoker = getInvoker(...);\/\/参数省略\nGenericService oldInvoker = invokerCache.get(key);\ninvokerCache.put(newInvoker);\/\/先缓存新的invoker\n\/\/ 然后再销毁旧的invoker对象\noldInvoker.destory();\n<\/code><\/pre><p>如果已经存在对应的Invoker对象，为了不影响现有调用，应该先用新的Invoker对象去更新缓存，然后再销毁旧的Invoker对象。<\/p><p>上面的方法解决了网关调用公司内部的Dubbo微服务问题，但还有另外一个非常重要的问题，怎么配置服务接口相关参数呢？<\/p><p>联系这节课前面的场景，我们需要在页面上配置公司内部Dubbo服务与外部电商的接口映射。<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/23\/79\/233fc90464a70ab461d91766789df579.png?wh=1920x596\" alt=\"图片\"><\/p><p>为此，我们专门建立了一条参数映射协议：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/51\/af\/51f750f5cb40a27a69e49a186b028faf.jpg?wh=1920x774\" alt=\"图片\"><\/p><p>参数映射设计的说明如下。<\/p><ul>\n<li>请求类型：主要分为请求参数与响应参数；<\/li>\n<li>字段名称：Dubbo服务对应的字段名称；<\/li>\n<li>字段类型：Dubbo服务对应字段的属性；<\/li>\n<li>字段所属类：Dubbo服务对应字段所属类型；<\/li>\n<li>节点名称：外部请求接口对应的字段名称；<\/li>\n<li>显示顺序：排序字段。<\/li>\n<\/ul><p>由于网关采取了泛化调用，在编写转换代码时，主要是遍历传入的参数，根据每一个字段查询对应的转换规则，然后转换为Map，返回值则刚好相反，是将Map转换为XML或者JSON。<\/p><p>在真正请求调用时，根据映射规则构建出请求参数Map后，通过Dubbo的泛化调用执行真正的调用：<\/p><pre><code class=\"language-plain\">GenericService genericService = (GenericService) invokeBean;\nMap invokerPams;\/\/省略转换过程\n\/\/ 参数类型数组\nString[] paramTypes = new String[1];\nparamTypes[0]=\"java.util.Map\";\n\/\/ 参数值数组\nObject[] paramValues = new Object[1];\n​\ninvokerPams.put(\"class\", \"net.codingw.oms.vo.OrderItemVo\");\nparamValues[0] = invokerPams;\n\/\/由于我们已经转化为java.util.Map，并且Map中，需要有一个key为class的，表示服务端需要转化的类型，这个从协议转换器中获取\nObject result = genericService.$invoke(this.getInvokeMethod(), paramTypes, paramValues);\n<\/code><\/pre><p>这样，网关就具备了高扩展性和稳定性，可以非常灵活地支撑业务的扩展，为不同的电商平台配置不同的参数转换，从而在内部只需要开发一套接口就可以非常灵活地支撑业务的扩展，基本做到网关代码零修改。<\/p><h2>总结<\/h2><p>这节课，我通过一个真实的场景，详细介绍了网关设计的需求背景，然后针对网关设计的痛点给出了设计方案。通过对这个方案中关键代码的解读，你应该能够更加深刻地理解Dubbo泛化调用背后的逻辑，真正做到理论与实际相结合。<\/p><p>值得注意的是，我们这节课提到的转换协议也是一绝，它使用中括号来定义多层嵌套结构，使得该协议具有普适性。<\/p><h2>课后题<\/h2><p>检测对知识的掌握程度最好的方式是自己写出来。所以，我建议你将我们这节课所讲的方案落到实处，尝试自己实现一个demo级的网关设计。<\/p><p>如果你想听听我的意见，可以提交一个 <a href=\"https:\/\/github.com\/dingwpmz\/infoq_question\">GitHub<\/a>的push请求或issues，并把对应地址贴到留言里。我们下节课见！<\/p>","footer_cover_data":{"img_url":"","mp_url":"","link_url":""},"article_cover_hidden":false,"column_is_experience":false,"is_required":true,"rate":{},"product_id":100114001,"like_count":2,"had_liked":false,"article_subtitle":"","audio_download_url":"https:\/\/static001.geekbang.org\/resource\/audio\/de\/cf\/de05ff84094f470173d092947c18c5cf.mp3","id":536477,"had_viewed":false,"article_title":"11｜案例：如何基于Dubbo进行网关设计？","column_bgcolor":"#F6F7FB","share":{"content":"吃透中间件，突破系统高并发瓶颈","title":"丁威 · 中间件核心技术与实战","poster":"https:\/\/static001.geekbang.org\/resource\/image\/5d\/2c\/5da39ca9cfdaa40920d01dc0b7667c2c.jpeg","cover":"https:\/\/static001.geekbang.org\/resource\/image\/76\/be\/7691d0fa3c359555fedff3293b0c35be.jpeg"},"is_video_preview":false,"article_summary":"这节课我们通过一个真实的业务场景来看看Dubbo网关（开放平台）的设计要领。","article_poster_wxlite":"https:\/\/static001.geekbang.org\/render\/screen\/c2\/15\/c2064031963d7a532883dfd2a0e36515.jpeg","column_sale_type":2,"article_features":0,"article_could_preview":false,"column_cover":"https:\/\/static001.geekbang.org\/resource\/image\/76\/be\/7691d0fa3c359555fedff3293b0c35be.jpeg","column_id":506,"audio_time_arr":{"m":"08","s":"12","h":"00"},"video_time":"","audio_title":"修改 7.6 丁威-11_01_01.MP3","audio_md5":"de05ff84094f470173d092947c18c5cf","video_size":0,"text_read_percent":0,"comment_count":4,"cid":506,"article_sharetitle":"案例：如何基于Dubbo进行网关设计？","column_is_onboard":true,"article_cshort":"<p>你好，我是丁威。<\/p><p>这节课我们通过一个真实的业务场景来看看Dubbo网关（开放平台）的设计要领。<\/p><h2>设计背景<\/h2><p>要设计一个网关，我们首先要知道它的设计背景。<\/p><p>2017年，我从传统行业脱身，正式进入物流行业。说来也非常巧，我当时加入的是公司的网关项目组，主要解决泛化调用与协议转换代码的开发问题。刚进公司不久，网关项目组就遇到了技术难题。快递物流行业的业务量可以比肩互联网，从那时候开始，我的传统技术思维开始向互联网技术思维转变。<\/p><p>当时网关项目组的核心任务就是确保能够快速接入各个电商平台。我来简单说明一下具体的场景。<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/yy\/af\/yya8c848bc0c0870d5bb5b6bb41268af.jpg?wh=1920x539\" alt=\"图片\"><\/p><p>解释一下上面这个图。<\/p><p>物流公司内部已经基于Dubbo构建了订单中心微服务域，其中创建订单接口的定义如下：​<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/c4\/61\/c4yy4a46bcb07cbbfb6f0fe750de8861.jpg?wh=1920x936\" alt=\"图片\"><\/p><p>外部电商平台众多，每一家电商平台内部都有自己的标准，并不会遵循统一的标准。例如在淘宝中，当用户购买商品后，淘宝内部会定义一个统一的订单外派接口。它的请求包可能是这样的：<\/p><pre><code class=\"language-plain\">{\n &nbsp;\"seller_id\":189,\n &nbsp;\"buyer\":\"dingwei\",\n &nbsp;\"order\":[\n &nbsp;  {\n &nbsp; &nbsp; &nbsp;\"goods_name\":\"华为笔记本\",\n &nbsp; &nbsp; &nbsp;\"num\":1,\n &nbsp; &nbsp; &nbsp;\"price\":500000\n &nbsp;  },\n &nbsp;  {\n &nbsp; &nbsp; &nbsp;\"goods_name\":\"华为手表\",\n &nbsp; &nbsp; &nbsp;\"num\":1,\n &nbsp; &nbsp; &nbsp;\"price\":200000\n &nbsp;  }\n  ]\n}\n<\/code><\/pre>","video_width":0,"column_could_sub":true,"article_ctime":1657209600,"score":"41657209600","video_media_map":{},"video_preview":{},"video":0,"video_time_arr":{"m":"","s":"","h":""},"video_total_seconds":0},"extra":{},"error":{}}