{"code":0,"data":{"video_id":"","sku":"100077001","video_cover":"","author_name":"傅健","text_read_version":0,"audio_size":10171228,"article_cover":"https:\/\/static001.geekbang.org\/resource\/image\/90\/d2\/90f26295576c5061ca8f7c0f7089b7d2.jpg","subtitles":{},"product_type":"c1","audio_url":"https:\/\/res001.geekbang.org\/media\/audio\/66\/f1\/6629d829f65b1fe4dbf3dffd310974f1\/ld\/ld.m3u8","chapter_id":"0","column_had_sub":true,"audio_dubber":"傅健","is_finished":false,"inline_video_subtitles":{},"like":{"had_done":false,"count":0},"neighbors":{"left":{"id":382710,"article_title":"21 | Spring Rest Template 常见错误"},"right":{"id":384537,"article_title":"23｜答疑现场：Spring 补充篇思考题合集"}},"audio_time":"00:10:37","video_height":0,"rate_percent":0,"article_content":"<p>你好，我是傅健。<\/p><p>前面我们介绍了许多 Spring 常用知识点上的常见应用错误。当然或许这些所谓的常用，你仍然没有使用，例如对于 Spring Data 的使用，有的项目确实用不到。那么这一讲，我们聊聊 Spring Test，相信你肯定绕不开对它的使用，除非你不使用 Spring 来开发程序，或者你使用了 Spring 但是你不写测试。但话说回来，后者的情况就算你想如此，你的老板也不会同意吧。<\/p><p>那么在 Spring Test 的应用上，有哪些常见错误呢？这里我给你梳理了两个典型，闲话少叙，我们直接进入这一讲的学习。<\/p><h2>案例 1：资源文件扫描不到<\/h2><p>首先，我们来写一个 HelloWorld 版的 Spring Boot 程序以做测试备用。<\/p><p>先来定义一个 Controller：<\/p><pre><code>@RestController\npublic class HelloController {\n\n    @Autowired\n    HelloWorldService helloWorldService;\n\n    @RequestMapping(path = &quot;hi&quot;, method = RequestMethod.GET)\n    public String hi() throws Exception{\n        return  helloWorldService.toString() ;\n    };\n\n}\n<\/code><\/pre><p>当访问 <a href=\"http:\/\/localhost:8080\/hi\">http:\/\/localhost:8080\/hi<\/a> 时，上述接口会打印自动注入的HelloWorldService类型的 Bean。而对于这个 Bean 的定义，我们这里使用配置文件的方式进行。<\/p><ol>\n<li>定义 HelloWorldService，具体到 HelloWorldService 的实现并非本讲的重点，所以我们可以简单实现如下：<\/li>\n<\/ol><pre><code>public class HelloWorldService {\n}\n<\/code><\/pre><ol start=\"2\">\n<li>定义一个 spring.xml，在这个 XML 中定义 HelloWorldServic 的Bean，并把这个 spring.xml 文件放置在\/src\/main\/resources 中：<\/li>\n<\/ol><!-- [[[read_end]]] --><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http:\/\/www.springframework.org\/schema\/beans&quot;\n       xmlns:xsi=&quot;http:\/\/www.w3.org\/2001\/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;http:\/\/www.springframework.org\/schema\/beans http:\/\/www.springframework.org\/schema\/beans\/spring-beans.xsd&quot;&gt;\n    &lt;bean id=&quot;helloWorldService&quot; class=&quot;com.spring.puzzle.others.test.example1.HelloWorldService&quot;&gt;\n    &lt;\/bean&gt;\n&lt;\/beans&gt;\n<\/code><\/pre><ol start=\"3\">\n<li>定义一个 Configuration 引入上述定义 XML，具体实现方式如下：<\/li>\n<\/ol><pre><code>@Configuration\n@ImportResource(locations = {&quot;spring.xml&quot;})\npublic class Config {\n}\n<\/code><\/pre><p>完成上述步骤后，我们就可以使用 main() 启动起来。测试这个接口，一切符合预期。那么接下来，我们来写一个测试：<\/p><pre><code>@SpringBootTest()\nclass ApplicationTests {\n\n    @Autowired\n    public HelloController helloController;\n\n    @Test\n    public void testController() throws Exception {\n        String response = helloController.hi();\n        Assert.notNull(response, &quot;not null&quot;);\n    }\n\n}\n<\/code><\/pre><p>​当我们运行上述测试的时候，会发现测试失败了，报错如下：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/75\/e3\/75bc072e10604b31bfb6971935f0d0e3.png?wh=1011*117\" alt=\"\"><\/p><p>为什么单独运行应用程序没有问题，但是运行测试就不行了呢？我们需要研究一下 Spring 的源码，来找找答案。<\/p><h3>案例解析<\/h3><p>在了解这个问题的根本原因之前，我们先从调试的角度来对比下启动程序和测试加载spring.xml的不同之处。<\/p><ol>\n<li>启动程序加载spring.xml<\/li>\n<\/ol><p>首先看下调用栈：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/56\/e1\/566ddaef5170e3dbe5481e4c40d341e1.png?wh=702*177\" alt=\"\"><\/p><p>可以看出，它最终以 ClassPathResource 形式来加载，这个资源的情况如下：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/db\/a5\/db7fe332174277d302452d4d47d003a5.png?wh=654*95\" alt=\"\"><\/p><p>而具体到加载实现，它使用的是 ClassPathResource#getInputStream 来加载spring.xml文件：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/6d\/2e\/6d170e626a21f201d22b7fed27840f2e.png?wh=1020*393\" alt=\"\"><\/p><p>从上述调用及代码实现，可以看出最终是可以加载成功的。<\/p><ol start=\"2\">\n<li>测试加载spring.xml<\/li>\n<\/ol><p>首先看下调用栈：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/05\/e6\/05a89da2411a02e48e2da091d666yye6.png?wh=703*175\" alt=\"\"><\/p><p>可以看出它是按 ServletContextResource 来加载的，这个资源的情况如下：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/fc\/8f\/fc6238c6716053fdfa993aa235e4a18f.png?wh=537*220\" alt=\"\"><\/p><p>具体到实现，它最终使用的是 MockServletContext#getResourceAsStream 来加载文件：<\/p><pre><code>@Nullable\npublic InputStream getResourceAsStream(String path) {\n    String resourceLocation = this.getResourceLocation(path);\n    Resource resource = null;\n\n    try {\n        resource = this.resourceLoader.getResource(resourceLocation);\n        return !resource.exists() ? null : resource.getInputStream();\n    } catch (IOException | InvalidPathException var5) {\n        if (this.logger.isWarnEnabled()) {\n            this.logger.warn(&quot;Could not open InputStream for resource &quot; + (resource != null ? resource : resourceLocation), var5);\n        }\n\n        return null;\n    }\n}\n<\/code><\/pre><p>​你可以继续跟踪它的加载位置相关代码，即 getResourceLocation()：<\/p><pre><code>protected String getResourceLocation(String path) {\n    if (!path.startsWith(&quot;\/&quot;)) {\n        path = &quot;\/&quot; + path;\n    }\n    \/\/加上前缀：\/src\/main\/resources\n    String resourceLocation = this.getResourceBasePathLocation(path);\n    if (this.exists(resourceLocation)) {\n        return resourceLocation;\n    } else {\n        \/\/{&quot;classpath:META-INF\/resources&quot;, &quot;classpath:resources&quot;, &quot;classpath:static&quot;, &quot;classpath:public&quot;};\n        String[] var3 = SPRING_BOOT_RESOURCE_LOCATIONS;\n        int var4 = var3.length;\n\n        for(int var5 = 0; var5 &lt; var4; ++var5) {\n            String prefix = var3[var5];\n            resourceLocation = prefix + path;\n            if (this.exists(resourceLocation)) {\n                return resourceLocation;\n            }\n        }\n\n        return super.getResourceLocation(path);\n    }\n}\n<\/code><\/pre><p>你会发现，它尝试从下面的一些位置进行加载：<\/p><pre><code>classpath:META-INF\/resources\nclasspath:resources\nclasspath:static\nclasspath:public\nsrc\/main\/webapp\n<\/code><\/pre><p>如果你仔细看这些目录，你还会发现，这些目录都没有spring.xml。或许你认为源文件src\/main\/resource下面不是有一个 spring.xml 么？那上述位置中的classpath:resources不就能加载了么？<\/p><p>那你肯定是忽略了一点：当程序运行起来后，src\/main\/resource 下的文件最终是不带什么resource的。关于这点，你可以直接查看编译后的目录（本地编译后是 target\\classes 目录），示例如下：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/d6\/ca\/d65bc6eb7f3bef8c110d5a06f69649ca.png?wh=655*143\" alt=\"\"><\/p><p>所以，最终我们在所有的目录中都找不到spring.xml，并且会报错提示加载不了文件。报错的地方位于 ServletContextResource#getInputStream 中：<\/p><pre><code>@Override\npublic InputStream getInputStream() throws IOException {\n   InputStream is = this.servletContext.getResourceAsStream(this.path);\n   if (is == null) {\n      throw new FileNotFoundException(&quot;Could not open &quot; + getDescription());\n   }\n   return is;\n}\n<\/code><\/pre><h3>问题修正<\/h3><p>从上述案例解析中，我们了解到了报错的原因，那么如何修正这个问题？这里我们可以采用两种方式。<\/p><ol>\n<li>在加载目录上放置 spring.xml<\/li>\n<\/ol><p>就本案例而言，加载目录有很多，所以修正方式也不少，我们可以建立一个 src\/main\/webapp，然后把 spring.xml 复制一份进去就可以了。也可以在\/src\/main\/resources 下面再建立一个 resources 目录，然后放置进去也可以。<\/p><ol start=\"2\">\n<li>在 @ImportResource 使用classpath加载方式<\/li>\n<\/ol><pre><code>@Configuration\n\/\/@ImportResource(locations = {&quot;spring.xml&quot;})\n@ImportResource(locations = {&quot;classpath:spring.xml&quot;})\npublic class Config {\n}\n<\/code><\/pre><p>这里，我们可以通过 Spring 的官方文档简单了解下不同加载方式的区别，参考 <a href=\"https:\/\/docs.spring.io\/spring-framework\/docs\/2.5.x\/reference\/resources.html\">https:\/\/docs.spring.io\/spring-framework\/docs\/2.5.x\/reference\/resources.html<\/a>：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/4f\/43\/4f24754d1308a887069cfb7661b5fa43.png?wh=1706*277\" alt=\"\"><\/p><p>很明显，我们一般都不会使用本案例的方式（即locations = {\"spring.xml\"}，无任何“前缀”的方式），毕竟它已经依赖于使用的 ApplicationContext。而 classPath 更为普适些，而一旦你按上述方式修正后，你会发现它加载的资源已经不再是 ServletContextResource，而是和应用程序一样的 ClassPathResource，这样自然可以加载到了。<\/p><p>所以说到底，表面上看，这个问题是关于测试的案例，但是实际上是 ImportResource 的使用问题。不过通过这个案例，你也会明白，很多用法真的只能在某个特定场合才能工作起来，你只是比较幸运而已。<\/p><h2>案例 2：容易出错的Mock<\/h2><p>接下来，我们再来看一个非功能性的错误案例。有时候，我们会发现 Spring Test 运行起来非常缓慢，寻根溯源之后，你会发现主要是因为很多测试都启动了Spring Context，示例如下：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/7c\/4a\/7c789e27d23301bd4ba96f03474cce4a.png?wh=424*500\" alt=\"\"><\/p><p>那么为什么有的测试会多次启动 Spring Context？在具体解析这个问题之前，我们先模拟写一个案例来复现这个问题。<\/p><p>我们先在 Spring Boot 程序中写几个被测试类：<\/p><pre><code>@Service\npublic class ServiceOne {\n}\n@Service\npublic class ServiceTwo {\n}\n\n<\/code><\/pre><p>然后分别写出对应的测试类：<\/p><pre><code>@SpringBootTest()\nclass ServiceOneTests {\n\n    @MockBean\n    ServiceOne serviceOne;\n\n    @Test\n    public void test(){\n        System.out.println(serviceOne);\n    }\n}\n\n@SpringBootTest()\nclass ServiceTwoTests {\n    @MockBean\n    ServiceTwo serviceTwo;\n    @Test\n    public void test(){\n        System.out.println(serviceTwo);\n    }\n}\n<\/code><\/pre><p>​在上述测试类中，我们都使用了@MockBean。写完这些程序，批量运行测试，你会发现Spring Context 果然会被运行多次。那么如何理解这个现象，是错误还是符合预期？接下来我们具体来解析下。<\/p><h3>案例解析<\/h3><p>当我们运行一个测试的时候，正常情况是不会重新创建一个 Spring Context 的。这是因为 Spring Test 使用了 Context 的缓存以避免重复创建 Context。那么这个缓存是怎么维护的呢？我们可以通过DefaultCacheAwareContextLoaderDelegate#loadContext来看下 Context 的获取和缓存逻辑：<\/p><pre><code>public ApplicationContext loadContext(MergedContextConfiguration mergedContextConfiguration) {\n    synchronized(this.contextCache) {\n        ApplicationContext context = this.contextCache.get(mergedContextConfiguration);\n        if (context == null) {\n            try {\n                context = this.loadContextInternal(mergedContextConfiguration);\n                \/\/省略非关键代码\n                this.contextCache.put(mergedContextConfiguration, context);\n            } catch (Exception var6) {\n            \/\/省略非关键代码\n            }\n        } else if (logger.isDebugEnabled()) {\n            \/\/省略非关键代码\n        }\n\n        this.contextCache.logStatistics();\n        return context;\n    }\n}\n<\/code><\/pre><p>从上述代码可以看出，缓存的 Key 是 MergedContextConfiguration。所以一个测试要不要启动一个新的 Context，就取决于根据这个测试 Class 构建的 MergedContextConfiguration 是否相同。而是否相同取决于它的 hashCode() 实现：<\/p><pre><code>public int hashCode() {\n    int result = Arrays.hashCode(this.locations);\n    result = 31 * result + Arrays.hashCode(this.classes);\n    result = 31 * result + this.contextInitializerClasses.hashCode();\n    result = 31 * result + Arrays.hashCode(this.activeProfiles);\n    result = 31 * result + Arrays.hashCode(this.propertySourceLocations);\n    result = 31 * result + Arrays.hashCode(this.propertySourceProperties);\n    result = 31 * result + this.contextCustomizers.hashCode();\n    result = 31 * result + (this.parent != null ? this.parent.hashCode() : 0);\n    result = 31 * result + nullSafeClassName(this.contextLoader).hashCode();\n    return result;\n}\n<\/code><\/pre><p>从上述方法，你可以看出只要上述元素中的任何一个不同都会导致一个 Context 会重新创建出来。关于这个缓存机制和 Key 的关键因素你可以参考 Spring 的官方文档，也有所提及，这里我直接给出了链接，你可以对照着去阅读。<\/p><p>点击获取：<a href=\"https:\/\/docs.spring.io\/spring-framework\/docs\/current\/reference\/html\/testing.html#testcontext-ctx-management-caching\">https:\/\/docs.spring.io\/spring-framework\/docs\/current\/reference\/html\/testing.html#testcontext-ctx-management-caching<\/a><\/p><p>现在回到本案例，为什么会创建一个新的 Context 而不是复用？根源在于两个测试的contextCustomizers这个元素的不同。如果你不信的话，你可以调试并对比下。<\/p><p>ServiceOneTests 的 MergedContextConfiguration 示例如下：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/20\/27\/20c269e533ec2dcea7bc73d3f0a2f027.png?wh=930*433\" alt=\"\"><\/p><p>ServiceTwoTests 的 MergedContextConfiguration 示例如下：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/16\/b1\/16e4abd8e908897a38d21d5057b960b1.png?wh=941*430\" alt=\"\"><\/p><p>很明显，MergedContextConfiguration（即 Context Cache 的 Key）的 ContextCustomizer 是不同的，所以 Context 没有共享起来。而追溯到 ContextCustomizer 的创建，我们可以具体来看下。<\/p><p>当我们运行一个测试（testClass）时，我们会使用 MockitoContextCustomizerFactory#createContextCustomizer 来创建一个 ContextCustomizer，代码示例如下：<\/p><pre><code>class MockitoContextCustomizerFactory implements ContextCustomizerFactory {\n    MockitoContextCustomizerFactory() {\n    }\n\n    public ContextCustomizer createContextCustomizer(Class&lt;?&gt; testClass, List&lt;ContextConfigurationAttributes&gt; configAttributes) {\n        DefinitionsParser parser = new DefinitionsParser();\n        parser.parse(testClass);\n        return new MockitoContextCustomizer(parser.getDefinitions());\n    }\n}\n<\/code><\/pre><p>创建的过程是由 DefinitionsParser 来解析这个测试 Class（例如案例中的 ServiceOneTests），如果这个测试 Class 中包含了 MockBean 或者 SpyBean 标记的情况，则将对应标记的情况转化为 MockDefinition，最终添加到 ContextCustomizer 中。解析的过程参考 DefinitionsParser#parse：<\/p><pre><code>void parse(Class&lt;?&gt; source) {\n    this.parseElement(source);\n    ReflectionUtils.doWithFields(source, this::parseElement);\n}\n\nprivate void parseElement(AnnotatedElement element) {\n    MergedAnnotations annotations = MergedAnnotations.from(element, SearchStrategy.SUPERCLASS);\n\/\/MockBean 处理    annotations.stream(MockBean.class).map(MergedAnnotation::synthesize).forEach((annotation) -&gt; {\n        this.parseMockBeanAnnotation(annotation, element);\n    });\n\/\/SpyBean 处理    annotations.stream(SpyBean.class).map(MergedAnnotation::synthesize).forEach((annotation) -&gt; {\n        this.parseSpyBeanAnnotation(annotation, element);\n    });\n}\n\nprivate void parseMockBeanAnnotation(MockBean annotation, AnnotatedElement element) {\n    Set&lt;ResolvableType&gt; typesToMock = this.getOrDeduceTypes(element, annotation.value());\n    \/\/省略非关键代码\n    Iterator var4 = typesToMock.iterator();\n    while(var4.hasNext()) {\n        ResolvableType typeToMock = (ResolvableType)var4.next();\n        MockDefinition definition = new MockDefinition(annotation.name(), typeToMock, annotation.extraInterfaces(), annotation.answer(), annotation.serializable(), annotation.reset(), QualifierDefinition.forElement(element));\n        \/\/添加到 DefinitionsParser#definitions\n        this.addDefinition(element, definition, &quot;mock&quot;);\n    }\n}\n<\/code><\/pre><p>那说了这么多，Spring Context 重新创建的根本原因还是在于使用了@MockBean 且不同，从而导致构建的 MergedContextConfiguration 不同，而 MergedContextConfiguration 正是作为 Cache 的 Key，Key 不同，Context 不能被复用，所以被重新创建了。这就是为什么在案例介绍部分，你会看到多次 Spring Context 的启动过程。而正因为“重启”，测试速度变缓慢了。<\/p><h3>问题修正<\/h3><p>到这，你会发现其实这种缓慢的根源是使用了@MockBean 带来的一个正常现象。但是假设你非要去提速下，那么你可以尝试使用 Mockito 去手工实现类似的功能。当然你也可以尝试使用下面的方式来解决，即把相关的 MockBean 都定义到一个地方去。例如针对本案例，修正方案如下：<\/p><pre><code>public class ServiceTests {\n    @MockBean\n    ServiceOne serviceOne;\n    @MockBean\n    ServiceTwo serviceTwo;\n\n}\n\n@SpringBootTest()\nclass ServiceOneTests extends ServiceTests{\n\n    @Test\n    public void test(){\n        System.out.println(serviceOne);\n    }\n\n}\n\n@SpringBootTest()\nclass ServiceTwoTests  extends ServiceTests{\n    @Test\n    public void test(){\n        System.out.println(serviceTwo);\n    }\n}\n<\/code><\/pre><p>重新运行测试，你会发现 Context 只会被创建一次，速度也有所提升了。相信，你也明白这么改能工作的原因了，现在每个测试对应的 Context  缓存 Key 已经相同了。<\/p><h2>重点回顾<\/h2><p>通过以上两个案例，相信你对 Spring Test 已经有了进一步的了解，最后总结下重点。<\/p><p>在使用 Spring Test 的时候，一定要注意资源文件的加载方式是否正确。例如，你使用的是绝对路径，形式如下：<\/p><pre><code>@ImportResource(locations = {&quot;spring.xml&quot;})\n<\/code><\/pre><p>那么它可能在不同的场合实现不同，不一定能加载到你想要的文件，所以我并不推荐你在使用 @ImportResource 时，使用绝对路径指定资源。<\/p><p>另外，@MockBean 可能会导致 Spring Context 反复新建，从而让测试变得缓慢，从根源上看，这是属于正常现象。不过你一定要意识到这点，否则，你可能会遇到各种难以理解的现象。<\/p><p>而假设你需要加速，你可以尝试多种方法，例如，你可以把依赖 Mock 的 Bean 声明在一个统一的地方。当然，你要格外注意这样是否还能满足你的测试需求。<\/p><h2>思考题<\/h2><p>在案例 1 中，我们解释了为什么测试程序加载不到 spring.xml 文件，根源在于当使用下面的语句加载文件时，它们是采用不同的 Resource 形式来加载的：<\/p><pre><code>@ImportResource(locations = {&quot;spring.xml&quot;})\n<\/code><\/pre><p>具体而言，应用程序加载使用的是 ClassPathResource，测试加载使用的是 ServletContextResource，那么这是怎么造成的呢？<\/p><p>期待你的思考，我们留言区见！<\/p>","footer_cover_data":{"img_url":"","mp_url":"","link_url":""},"article_cover_hidden":false,"column_is_experience":false,"is_required":true,"rate":{},"product_id":100077001,"like_count":5,"had_liked":false,"article_subtitle":"无","audio_download_url":"https:\/\/static001.geekbang.org\/resource\/audio\/66\/f1\/6629d829f65b1fe4dbf3dffd310974f1.mp3","id":383756,"had_viewed":false,"article_title":"22 | Spring Test 常见错误","column_bgcolor":"#F6F7FB","share":{"content":"Spring 开发老兵 10 年避坑心法","title":"傅健 · Spring编程常见错误50例","poster":"https:\/\/static001.geekbang.org\/resource\/image\/81\/cf\/81d9cef44e90ff4890d04b735fd135cf.jpg","cover":"https:\/\/static001.geekbang.org\/resource\/image\/82\/a2\/829d02f2fc0e10860d7b5401f2160ba2.jpg"},"is_video_preview":false,"article_summary":"Spring 开发中绕不开的一个话题。","article_poster_wxlite":"https:\/\/static001.geekbang.org\/render\/screen\/8e\/e5\/8e786cbccc775bac7c9b4203308ee0e5.jpeg","column_sale_type":2,"article_features":0,"article_could_preview":false,"column_cover":"https:\/\/static001.geekbang.org\/resource\/image\/82\/a2\/829d02f2fc0e10860d7b5401f2160ba2.jpg","column_id":408,"audio_time_arr":{"m":"10","s":"37","h":"00"},"video_time":"","audio_title":"傅健-22","audio_md5":"6629d829f65b1fe4dbf3dffd310974f1","video_size":0,"text_read_percent":0,"comment_count":0,"cid":408,"article_sharetitle":"Spring Test 常见错误","column_is_onboard":true,"article_cshort":"<p>你好，我是傅健。<\/p><p>前面我们介绍了许多 Spring 常用知识点上的常见应用错误。当然或许这些所谓的常用，你仍然没有使用，例如对于 Spring Data 的使用，有的项目确实用不到。那么这一讲，我们聊聊 Spring Test，相信你肯定绕不开对它的使用，除非你不使用 Spring 来开发程序，或者你使用了 Spring 但是你不写测试。但话说回来，后者的情况就算你想如此，你的老板也不会同意吧。<\/p><p>那么在 Spring Test 的应用上，有哪些常见错误呢？这里我给你梳理了两个典型，闲话少叙，我们直接进入这一讲的学习。<\/p><h2>案例 1：资源文件扫描不到<\/h2><p>首先，我们来写一个 HelloWorld 版的 Spring Boot 程序以做测试备用。<\/p><p>先来定义一个 Controller：<\/p><pre><code>@RestController\npublic class HelloController {\n\n    @Autowired\n    HelloWorldService helloWorldService;\n\n    @RequestMapping(path = &quot;hi&quot;, method = RequestMethod.GET)\n    public String hi() throws Exception{\n        return  helloWorldService.toString() ;\n    };\n\n}\n<\/code><\/pre><p>当访问 <a href=\"http:\/\/localhost:8080\/hi\">http:\/\/localhost:8080\/hi<\/a> 时，上述接口会打印自动注入的HelloWorldService类型的 Bean。而对于这个 Bean 的定义，我们这里使用配置文件的方式进行。<\/p><ol>\n<li>定义 HelloWorldService，具体到 HelloWorldService 的实现并非本讲的重点，所以我们可以简单实现如下：<\/li>\n<\/ol><pre><code>public class HelloWorldService {\n}\n<\/code><\/pre><ol start=\"2\">\n<li>定义一个 spring.xml，在这个 XML 中定义 HelloWorldServic 的Bean，并把这个 spring.xml 文件放置在\/src\/main\/resources 中：<\/li>\n<\/ol>","video_width":0,"column_could_sub":true,"article_ctime":1623340800,"score":"41623340800","video_media_map":{},"video_preview":{},"video":0,"video_time_arr":{"m":"","s":"","h":""},"video_total_seconds":0},"extra":{},"error":{}}