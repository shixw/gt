{"code":0,"data":{"video_id":"","sku":"100077001","video_cover":"","author_name":"傅健","text_read_version":0,"audio_size":15459205,"article_cover":"https:\/\/static001.geekbang.org\/resource\/image\/9c\/0b\/9cd890e775e4e33a75be8fc7bf26960b.jpg","subtitles":{},"product_type":"c1","audio_url":"https:\/\/res001.geekbang.org\/media\/audio\/d8\/d7\/d895b3b7fd9bb04343689dc1e3ff3fd7\/ld\/ld.m3u8","chapter_id":"0","column_had_sub":true,"audio_dubber":"傅健","is_finished":false,"inline_video_subtitles":{},"like":{"had_done":false,"count":12},"neighbors":{"left":{"id":364761,"article_title":"01｜Spring Bean 定义常见错误"},"right":{"id":366930,"article_title":"03｜Spring Bean 依赖注入常见错误（下）"}},"audio_time":"00:16:05","video_height":0,"rate_percent":0,"article_content":"<p>你好，我是傅健，这节课我们来聊聊 Spring @Autowired。<\/p><p>提及Spring的优势或特性，我们都会立马想起“<strong>控制反转、依赖注入<\/strong>”这八字真言。而@Autowired正是用来支持依赖注入的核心利器之一。表面上看，它仅仅是一个注解，在使用上不应该出错。但是，在实际使用中，我们仍然会出现各式各样的错误，而且都堪称经典。所以这节课我就带着你学习下这些经典错误及其背后的原因，以防患于未然。<\/p><h2>案例1：过多赠予，无所适从<\/h2><p>在使用@Autowired时，不管你是菜鸟级还是专家级的Spring使用者，都应该制造或者遭遇过类似的错误：<\/p><blockquote>\n<p>required a single bean, but 2 were found<\/p>\n<\/blockquote><p>顾名思义，我们仅需要一个Bean，但实际却提供了2个（这里的“2”在实际错误中可能是其它大于1的任何数字）。<\/p><p>为了重现这个错误，我们可以先写一个案例来模拟下。假设我们在开发一个学籍管理系统案例，需要提供一个API根据学生的学号（ID）来移除学生，学生的信息维护肯定需要一个数据库来支撑，所以大体上可以实现如下：<\/p><pre><code>@RestController\n@Slf4j\n@Validated\npublic class StudentController {\n    @Autowired\n    DataService dataService;\n\n    @RequestMapping(path = &quot;students\/{id}&quot;, method = RequestMethod.DELETE)\n    public void deleteStudent(@PathVariable(&quot;id&quot;) @Range(min = 1,max = 100) int id){\n        dataService.deleteStudent(id);\n    };\n}\n<\/code><\/pre><p>其中DataService是一个接口，其实现依托于Oracle，代码示意如下：<\/p><pre><code>public interface DataService {\n    void deleteStudent(int id);\n}\n\n@Repository\n@Slf4j\npublic class OracleDataService implements DataService{\n    @Override\n    public void deleteStudent(int id) {\n        log.info(&quot;delete student info maintained by oracle&quot;);\n    }\n}\n<\/code><\/pre><!-- [[[read_end]]] --><p>截止目前，运行并测试程序是毫无问题的。但是需求往往是源源不断的，某天我们可能接到节约成本的需求，希望把一些部分非核心的业务从Oracle迁移到社区版Cassandra，所以我们自然会先添加上一个新的DataService实现，代码如下：<\/p><pre><code>@Repository\n@Slf4j\npublic class CassandraDataService implements DataService{\n    @Override\n    public void deleteStudent(int id) {\n        log.info(&quot;delete student info maintained by cassandra&quot;);\n    }\n}\n<\/code><\/pre><p>实际上，当我们完成支持多个数据库的准备工作时，程序就已经无法启动了，报错如下：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/80\/36\/80b14cf13b383e48f64f7052d6747836.png?wh=1745*464\" alt=\"\"><\/p><p>很显然，上述报错信息正是我们这一小节讨论的错误，那么这个错误到底是怎么产生的呢？接下来我们具体分析下。<\/p><h3>案例解析<\/h3><p>要找到这个问题的根源，我们就需要对@Autowired实现的依赖注入的原理有一定的了解。首先，我们先来了解下 @Autowired  发生的位置和核心过程。<\/p><p>当一个Bean被构建时，核心包括两个基本步骤：<\/p><ol>\n<li>执行AbstractAutowireCapableBeanFactory#createBeanInstance方法：通过构造器反射构造出这个Bean，在此案例中相当于构建出StudentController的实例；<\/li>\n<li>执行AbstractAutowireCapableBeanFactory#populate方法：填充（即设置）这个Bean，在本案例中，相当于设置StudentController实例中被@Autowired标记的dataService属性成员。<\/li>\n<\/ol><p>在步骤2中，“填充”过程的关键就是执行各种BeanPostProcessor处理器，关键代码如下：<\/p><pre><code>protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {\n      \/\/省略非关键代码\n      for (BeanPostProcessor bp : getBeanPostProcessors()) {\n         if (bp instanceof InstantiationAwareBeanPostProcessor) {\n            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\n            PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);\n          \/\/省略非关键代码\n         }\n      }\n   }   \n}\n<\/code><\/pre><p>在上述代码执行过程中，因为StudentController含有标记为Autowired的成员属性dataService，所以会使用到AutowiredAnnotationBeanPostProcessor（BeanPostProcessor中的一种）来完成“装配”过程：找出合适的DataService的bean并设置给StudentController#dataService。如果深究这个装配过程，又可以细分为两个步骤：<\/p><ol>\n<li>寻找出所有需要依赖注入的字段和方法，参考AutowiredAnnotationBeanPostProcessor#postProcessProperties中的代码行：<\/li>\n<\/ol><pre><code>InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);\n<\/code><\/pre><ol start=\"2\">\n<li>根据依赖信息寻找出依赖并完成注入，以字段注入为例，参考AutowiredFieldElement#inject方法：<\/li>\n<\/ol><pre><code>@Override\nprotected void inject(Object bean, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable {\n   Field field = (Field) this.member;\n   Object value;\n   \/\/省略非关键代码\n      try {\n          DependencyDescriptor desc = new DependencyDescriptor(field, this.required);\n         \/\/寻找“依赖”，desc为&quot;dataService&quot;的DependencyDescriptor\n         value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);\n      }\n      \n   }\n   \/\/省略非关键代码\n   if (value != null) {\n      ReflectionUtils.makeAccessible(field);\n      \/\/装配“依赖”\n      field.set(bean, value);\n   }\n}\n<\/code><\/pre><p>说到这里，我们基本了解了@Autowired过程发生的位置和过程。而且很明显，我们案例中的错误就发生在上述“寻找依赖”的过程中（上述代码的第9行），那么到底是怎么发生的呢？我们可以继续刨根问底。<\/p><p>为了更清晰地展示错误发生的位置，我们可以采用调试的视角展示其位置（即DefaultListableBeanFactory#doResolveDependency中代码片段），参考下图：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/4c\/f9\/4cb99e17967847995bfe1d7ec0fe75f9.png?wh=1426*358\" alt=\"\"><\/p><p>如上图所示，当我们根据DataService这个类型来找出依赖时，我们会找出2个依赖，分别为CassandraDataService和OracleDataService。在这样的情况下，如果同时满足以下两个条件则会抛出本案例的错误：<\/p><ol>\n<li>调用determineAutowireCandidate方法来选出优先级最高的依赖，但是发现并没有优先级可依据。具体选择过程可参考DefaultListableBeanFactory#determineAutowireCandidate：<\/li>\n<\/ol><pre><code>protected String determineAutowireCandidate(Map&lt;String, Object&gt; candidates, DependencyDescriptor descriptor) {\n   Class&lt;?&gt; requiredType = descriptor.getDependencyType();\n   String primaryCandidate = determinePrimaryCandidate(candidates, requiredType);\n   if (primaryCandidate != null) {\n      return primaryCandidate;\n   }\n   String priorityCandidate = determineHighestPriorityCandidate(candidates, requiredType);\n   if (priorityCandidate != null) {\n      return priorityCandidate;\n   }\n   \/\/ Fallback\n   for (Map.Entry&lt;String, Object&gt; entry : candidates.entrySet()) {\n      String candidateName = entry.getKey();\n      Object beanInstance = entry.getValue();\n      if ((beanInstance != null &amp;&amp; this.resolvableDependencies.containsValue(beanInstance)) ||\n            matchesBeanName(candidateName, descriptor.getDependencyName())) {\n         return candidateName;\n      }\n   }\n   return null;\n}\n<\/code><\/pre><p>如代码所示，优先级的决策是先根据@Primary来决策，其次是@Priority决策，最后是根据Bean名字的严格匹配来决策。如果这些帮助决策优先级的注解都没有被使用，名字也不精确匹配，则返回null，告知无法决策出哪种最合适。<\/p><ol start=\"2\">\n<li>@Autowired要求是必须注入的（即required保持默认值为true），或者注解的属性类型并不是可以接受多个Bean的类型，例如数组、Map、集合。这点可以参考DefaultListableBeanFactory#indicatesMultipleBeans的实现：<\/li>\n<\/ol><pre><code>private boolean indicatesMultipleBeans(Class&lt;?&gt; type) {\n   return (type.isArray() || (type.isInterface() &amp;&amp;\n         (Collection.class.isAssignableFrom(type) || Map.class.isAssignableFrom(type))));\n}\n<\/code><\/pre><p>对比上述两个条件和我们的案例，很明显，案例程序能满足这些条件，所以报错并不奇怪。而如果我们把这些条件想得简单点，或许更容易帮助我们去理解这个设计。就像我们遭遇多个无法比较优劣的选择，却必须选择其一时，与其偷偷地随便选择一种，还不如直接报错，起码可以避免更严重的问题发生。<\/p><h3>问题修正<\/h3><p>针对这个案例，有了源码的剖析，我们可以很快找到解决问题的方法：<strong>打破上述两个条件中的任何一个即可，即让候选项具有优先级或压根可以不去选择。<\/strong>不过需要你注意的是，不是每一种条件的打破都满足实际需求，例如我们可以通过使用标记@Primary的方式来让被标记的候选者有更高优先级，从而避免报错，但是它并不一定符合业务需求，这就好比我们本身需要两种数据库都能使用，而不是顾此失彼。<\/p><pre><code>@Repository\n@Primary\n@Slf4j\npublic class OracleDataService implements DataService{\n    \/\/省略非关键代码\n}\n<\/code><\/pre><p>现在，请你仔细研读上述的两个条件，要同时支持多种DataService，且能在不同业务情景下精确匹配到要选择到的DataService，我们可以使用下面的方式去修改：<\/p><pre><code>@Autowired\nDataService oracleDataService;\n<\/code><\/pre><p>如代码所示，修改方式的精髓在于将属性名和Bean名字精确匹配，这样就可以让注入选择不犯难：需要Oracle时指定属性名为oracleDataService，需要Cassandra时则指定属性名为cassandraDataService。<\/p><h2>案例 2：显式引用Bean时首字母忽略大小写<\/h2><p>针对案例1的问题修正，实际上还存在另外一种常用的解决办法，即采用@Qualifier来显式指定引用的是那种服务，例如采用下面的方式：<\/p><pre><code>@Autowired()\n@Qualifier(&quot;cassandraDataService&quot;)\nDataService dataService;\n<\/code><\/pre><p>这种方式之所以能解决问题，在于它能让寻找出的Bean只有一个（即精确匹配），所以压根不会出现后面的决策过程，可以参考DefaultListableBeanFactory#doResolveDependency：<\/p><pre><code>@Nullable\npublic Object doResolveDependency(DependencyDescriptor descriptor, @Nullable String beanName,\n      @Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {\n      \/\/省略其他非关键代码\n      \/\/寻找bean过程\n      Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);\n      if (matchingBeans.isEmpty()) {\n         if (isRequired(descriptor)) {\n            raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);\n         }\n         return null;\n      }\n      \/\/省略其他非关键代码\n      if (matchingBeans.size() &gt; 1) {\n         \/\/省略多个bean的决策过程，即案例1重点介绍内容\n      } \n     \/\/省略其他非关键代码\n}\n<\/code><\/pre><p>我们会使用@Qualifier指定的名称去匹配，最终只找到了唯一一个。<\/p><p>不过在使用@Qualifier时，我们有时候会犯另一个经典的小错误，就是我们可能会忽略Bean的名称首字母大小写。这里我们把校正后的案例稍稍变形如下：<\/p><pre><code>@Autowired\n@Qualifier(&quot;CassandraDataService&quot;)\nDataService dataService;\n<\/code><\/pre><p>运行程序，我们会报错如下：<\/p><blockquote>\n<p>Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'studentController': Unsatisfied dependency expressed through field 'dataService'; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'com.spring.puzzle.class2.example2.DataService' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true), @org.springframework.beans.factory.annotation.Qualifier(value=CassandraDataService)}<\/p>\n<\/blockquote><p>这里我们很容易得出一个结论：<strong>对于Bean的名字，如果没有显式指明，就应该是类名，不过首字母应该小写。<\/strong>但是这个轻松得出的结论成立么？<\/p><p>不妨再测试下，假设我们需要支持SQLite这种数据库，我们定义了一个命名为SQLiteDataService的实现，然后借鉴之前的经验，我们很容易使用下面的代码来引用这个实现：<\/p><pre><code>@Autowired\n@Qualifier(&quot;sQLiteDataService&quot;)\nDataService dataService;\n<\/code><\/pre><p>满怀信心运行完上面的程序，依然会出现之前的错误，而如果改成SQLiteDataService，则运行通过了。这和之前的结论又矛盾了。所以，显式引用Bean时，首字母到底是大写还是小写呢？<\/p><h3>案例解析<\/h3><p>对于这种错误的报错位置，其实我们正好在本案例的开头就贴出了（即第二段代码清单的第9行）：<\/p><pre><code>raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);\n<\/code><\/pre><p>即当因为名称问题（例如引用Bean首字母搞错了）找不到Bean时，会直接抛出NoSuchBeanDefinitionException。<\/p><p>在这里，我们真正需要关心的问题是：不显式设置名字的Bean，其默认名称首字母到底是大写还是小写呢？<\/p><p>看案例的话，当我们启动基于Spring  Boot的应用程序时，会自动扫描我们的Package，以找出直接或间接标记了@Component的Bean的定义（即BeanDefinition）。例如CassandraDataService、SQLiteDataService都被标记了@Repository，而Repository本身被@Component标记，所以它们都是间接标记了@Component。<\/p><p>一旦找出这些Bean的信息，就可以生成这些Bean的名字，然后组合成一个个BeanDefinitionHolder返回给上层。这个过程关键步骤可以查看下图的代码片段（ClassPathBeanDefinitionScanner#doScan）：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/27\/49\/277f3b2421a0e173a0eee56b7d65f849.png?wh=1270*418\" alt=\"\"><\/p><p>基本匹配我们前面描述的过程，其中方法调用BeanNameGenerator#generateBeanName即用来产生Bean的名字，它有两种实现方式。因为DataService的实现都是使用注解标记的，所以Bean名称的生成逻辑最终调用的其实是AnnotationBeanNameGenerator#generateBeanName这种实现方式，我们可以看下它的具体实现，代码如下：<\/p><pre><code>@Override\npublic String generateBeanName(BeanDefinition definition, BeanDefinitionRegistry registry) {\n   if (definition instanceof AnnotatedBeanDefinition) {\n      String beanName = determineBeanNameFromAnnotation((AnnotatedBeanDefinition) definition);\n      if (StringUtils.hasText(beanName)) {\n         \/\/ Explicit bean name found.\n         return beanName;\n      }\n   }\n   \/\/ Fallback: generate a unique default bean name.\n   return buildDefaultBeanName(definition, registry);\n}\n<\/code><\/pre><p>大体流程只有两步：看Bean有没有显式指明名称，如果有则用显式名称，如果没有则产生一个默认名称。很明显，在我们的案例中，是没有给Bean指定名字的，所以产生的Bean的名称就是生成的默认名称，查看默认名的产生方法buildDefaultBeanName，其实现如下：<\/p><pre><code>protected String buildDefaultBeanName(BeanDefinition definition) {\n   String beanClassName = definition.getBeanClassName();\n   Assert.state(beanClassName != null, &quot;No bean class name set&quot;);\n   String shortClassName = ClassUtils.getShortName(beanClassName);\n   return Introspector.decapitalize(shortClassName);\n}\n<\/code><\/pre><p>首先，获取一个简短的ClassName，然后调用Introspector#decapitalize方法，设置首字母大写或小写，具体参考下面的代码实现：<\/p><pre><code>public static String decapitalize(String name) {\n    if (name == null || name.length() == 0) {\n        return name;\n    }\n    if (name.length() &gt; 1 &amp;&amp; Character.isUpperCase(name.charAt(1)) &amp;&amp;\n                    Character.isUpperCase(name.charAt(0))){\n        return name;\n    }\n    char chars[] = name.toCharArray();\n    chars[0] = Character.toLowerCase(chars[0]);\n    return new String(chars);\n}\n<\/code><\/pre><p>到这，我们很轻松地明白了前面两个问题出现的原因：<strong>如果一个类名是以两个大写字母开头的，则首字母不变，其它情况下默认首字母变成小写。<\/strong>结合我们之前的案例，SQLiteDataService的Bean，其名称应该就是类名本身，而CassandraDataService的Bean名称则变成了首字母小写（cassandraDataService）。<\/p><h3>问题修正<\/h3><p>现在我们已经从源码级别了解了Bean名字产生的规则，就可以很轻松地修正案例中的两个错误了。以引用CassandraDataService类型的Bean的错误修正为例，可以采用下面这两种修改方式：<\/p><ol>\n<li>引用处纠正首字母大小写问题：<\/li>\n<\/ol><pre><code>@Autowired\n@Qualifier(&quot;cassandraDataService&quot;)\nDataService dataService;\n<\/code><\/pre><ol start=\"2\">\n<li>定义处显式指定Bean名字，我们可以保持引用代码不变，而通过显式指明CassandraDataService 的Bean名称为CassandraDataService来纠正这个问题。<\/li>\n<\/ol><pre><code>@Repository(&quot;CassandraDataService&quot;)\n@Slf4j\npublic class CassandraDataService implements DataService {\n  \/\/省略实现\n}\n<\/code><\/pre><p>现在，我们的程序就可以精确匹配到要找的Bean了。比较一下这两种修改方法的话，如果你不太了解源码，不想纠结于首字母到底是大写还是小写，建议你用第二种方法去避免困扰。<\/p><h2>案例 3：引用内部类的Bean遗忘类名<\/h2><p>解决完案例2，是不是就意味着我们能搞定所有Bean的显式引用，不再犯错了呢？天真了。我们可以沿用上面的案例，稍微再添加点别的需求，例如我们需要定义一个内部类来实现一种新的DataService，代码如下：<\/p><pre><code>public class StudentController {\n    @Repository\n    public static class InnerClassDataService implements DataService{\n        @Override\n        public void deleteStudent(int id) {\n          \/\/空实现\n        }\n    }\n    \/\/省略其他非关键代码\n }\n<\/code><\/pre><p>遇到这种情况，我们一般都会很自然地用下面的方式直接去显式引用这个Bean：<\/p><pre><code>@Autowired\n@Qualifier(&quot;innerClassDataService&quot;)\nDataService innerClassDataService;\n<\/code><\/pre><p>很明显，有了案例2的经验，我们上来就直接采用了<strong>首字母小写<\/strong>以避免案例2中的错误，但这样的代码是不是就没问题了呢？实际上，仍然会报错“找不到Bean”，这是为什么？<\/p><h3>案例解析<\/h3><p>实际上，我们遭遇的情况是“如何引用内部类的Bean”。解析案例2的时候，我曾经贴出了如何产生默认Bean名的方法（即AnnotationBeanNameGenerator#buildDefaultBeanName），当时我们只关注了首字母是否小写的代码片段，而在最后变换首字母之前，有一行语句是对class名字的处理，代码如下：<\/p><blockquote>\n<p>String shortClassName = ClassUtils.getShortName(beanClassName);<\/p>\n<\/blockquote><p>我们可以看下它的实现，参考ClassUtils#getShortName方法：<\/p><pre><code>public static String getShortName(String className) {\n   Assert.hasLength(className, &quot;Class name must not be empty&quot;);\n   int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n   int nameEndIndex = className.indexOf(CGLIB_CLASS_SEPARATOR);\n   if (nameEndIndex == -1) {\n      nameEndIndex = className.length();\n   }\n   String shortName = className.substring(lastDotIndex + 1, nameEndIndex);\n   shortName = shortName.replace(INNER_CLASS_SEPARATOR, PACKAGE_SEPARATOR);\n   return shortName;\n}\n<\/code><\/pre><p>很明显，假设我们是一个内部类，例如下面的类名：<\/p><blockquote>\n<p>com.spring.puzzle.class2.example3.StudentController.InnerClassDataService<\/p>\n<\/blockquote><p>在经过这个方法的处理后，我们得到的其实是下面这个名称：<\/p><blockquote>\n<p>StudentController.InnerClassDataService<\/p>\n<\/blockquote><p>最后经过Introspector.decapitalize的首字母变换，最终获取的Bean名称如下：<\/p><blockquote>\n<p>studentController.InnerClassDataService<\/p>\n<\/blockquote><p>所以我们在案例程序中，直接使用  innerClassDataService  自然找不到想要的Bean。<\/p><h3>问题修正<\/h3><p>通过案例解析，我们很快就找到了这个内部类，Bean的引用问题顺手就修正了，如下：<\/p><pre><code>@Autowired\n@Qualifier(&quot;studentController.InnerClassDataService&quot;)\nDataService innerClassDataService;\n<\/code><\/pre><p>这个引用看起来有些许奇怪，但实际上是可以工作的，反而直接使用  innerClassDataService  来引用倒是真的不可行。<\/p><p>通过这个案例我们可以看出，<strong>对源码的学习是否全面决定了我们以后犯错的可能性大小。<\/strong>如果我们在学习案例2时，就对class名称的变化部分的源码进行了学习，那么这种错误是不容易犯的。不过有时候我们确实很难一上来就把学习开展的全面而深入，总是需要时间和错误去锤炼的。<\/p><h2>重点回顾<\/h2><p>看完这三个案例，我们会发现，这些错误的直接结果都是找不到合适的Bean，但是原因却不尽相同。例如案例1是因为提供的Bean过多又无法决策选择谁；案例2和案例3是因为指定的名称不规范导致引用的Bean找不到。<\/p><p>实际上，这些错误在一些“聪明的”IDE会被提示出来，但是它们在其它一些不太智能的主流IDE中并不能被告警出来。不过悲剧的是，即使聪明的IDE也存在误报的情况，所以<strong>完全依赖IDE是不靠谱的<\/strong>，毕竟这些错误都能编译过去。<\/p><p>另外，我们的案例都是一些简化的场景，很容易看出和发现问题，而真实的场景往往复杂得多。例如对于案例1，我们的同种类型的实现，可能不是同时出现在自己的项目代码中，而是有部分实现出现在依赖的Jar库中。所以你一定要对案例背后的源码实现有一个扎实的了解，这样才能在复杂场景中去规避这些问题。<\/p><h2>思考题<\/h2><p>我们知道了通过@Qualifier可以引用想匹配的Bean，也可以直接命名属性的名称为Bean的名称来引用，这两种方式如下：<\/p><pre><code>\/\/方式1：属性命名为要装配的bean名称\n@Autowired\nDataService oracleDataService;\n\n\/\/方式2：使用@Qualifier直接引用\n@Autowired\n@Qualifier(&quot;oracleDataService&quot;)\nDataService dataService;\n<\/code><\/pre><p>那么对于案例3的内部类引用，你觉得可以使用第1种方式做到么？例如使用如下代码：<\/p><blockquote>\n<p>@Autowired<br>\nDataService studentController.InnerClassDataService;<\/p>\n<\/blockquote><p>期待在留言区看到你的答案，我们下节课见！<\/p>","footer_cover_data":{"img_url":"","mp_url":"","link_url":""},"article_cover_hidden":false,"column_is_experience":false,"is_required":true,"rate":{},"product_id":100077001,"like_count":33,"had_liked":false,"article_subtitle":"无","audio_download_url":"https:\/\/static001.geekbang.org\/resource\/audio\/d8\/d7\/d895b3b7fd9bb04343689dc1e3ff3fd7.mp3","id":366170,"had_viewed":false,"article_title":"02｜Spring Bean 依赖注入常见错误（上）","column_bgcolor":"#F6F7FB","share":{"content":"Spring 开发老兵 10 年避坑心法","title":"傅健 · Spring编程常见错误50例","poster":"https:\/\/static001.geekbang.org\/resource\/image\/81\/cf\/81d9cef44e90ff4890d04b735fd135cf.jpg","cover":"https:\/\/static001.geekbang.org\/resource\/image\/82\/a2\/829d02f2fc0e10860d7b5401f2160ba2.jpg"},"is_video_preview":false,"article_summary":"控制反转，依赖注入。","article_poster_wxlite":"https:\/\/static001.geekbang.org\/render\/screen\/f7\/8a\/f7620fdd212f8d1db45347ec62517f8a.jpeg","column_sale_type":1,"article_features":0,"article_could_preview":false,"column_cover":"https:\/\/static001.geekbang.org\/resource\/image\/82\/a2\/829d02f2fc0e10860d7b5401f2160ba2.jpg","column_id":408,"audio_time_arr":{"m":"16","s":"05","h":"00"},"video_time":"","audio_title":"傅健-02新","audio_md5":"d895b3b7fd9bb04343689dc1e3ff3fd7","video_size":0,"text_read_percent":0,"comment_count":20,"cid":408,"article_sharetitle":"Spring Bean 依赖注入常见错误（上）","column_is_onboard":true,"article_cshort":"<p>你好，我是傅健，这节课我们来聊聊 Spring @Autowired。<\/p><p>提及Spring的优势或特性，我们都会立马想起“<strong>控制反转、依赖注入<\/strong>”这八字真言。而@Autowired正是用来支持依赖注入的核心利器之一。表面上看，它仅仅是一个注解，在使用上不应该出错。但是，在实际使用中，我们仍然会出现各式各样的错误，而且都堪称经典。所以这节课我就带着你学习下这些经典错误及其背后的原因，以防患于未然。<\/p><h2>案例1：过多赠予，无所适从<\/h2><p>在使用@Autowired时，不管你是菜鸟级还是专家级的Spring使用者，都应该制造或者遭遇过类似的错误：<\/p><blockquote>\n<p>required a single bean, but 2 were found<\/p>\n<\/blockquote><p>顾名思义，我们仅需要一个Bean，但实际却提供了2个（这里的“2”在实际错误中可能是其它大于1的任何数字）。<\/p><p>为了重现这个错误，我们可以先写一个案例来模拟下。假设我们在开发一个学籍管理系统案例，需要提供一个API根据学生的学号（ID）来移除学生，学生的信息维护肯定需要一个数据库来支撑，所以大体上可以实现如下：<\/p><pre><code>@RestController\n@Slf4j\n@Validated\npublic class StudentController {\n    @Autowired\n    DataService dataService;\n\n    @RequestMapping(path = &quot;students\/{id}&quot;, method = RequestMethod.DELETE)\n    public void deleteStudent(@PathVariable(&quot;id&quot;) @Range(min = 1,max = 100) int id){\n        dataService.deleteStudent(id);\n    };\n}\n<\/code><\/pre><p>其中DataService是一个接口，其实现依托于Oracle，代码示意如下：<\/p><pre><code>public interface DataService {\n    void deleteStudent(int id);\n}\n\n@Repository\n@Slf4j\npublic class OracleDataService implements DataService{\n    @Override\n    public void deleteStudent(int id) {\n        log.info(&quot;delete student info maintained by oracle&quot;);\n    }\n}\n<\/code><\/pre>","video_width":0,"column_could_sub":true,"article_ctime":1619107200,"score":"21619107200","video_media_map":{},"video_preview":{},"video":0,"video_time_arr":{"m":"","s":"","h":""},"video_total_seconds":0},"extra":{},"error":{}}