{"code":0,"data":{"video_id":"","sku":"100077001","video_cover":"","author_name":"傅健","text_read_version":0,"audio_size":7004120,"article_cover":"https:\/\/static001.geekbang.org\/resource\/image\/c6\/yy\/c6e9f8dcf379d358d76d3d93dc42cbyy.jpg","subtitles":{},"product_type":"c1","audio_url":"https:\/\/res001.geekbang.org\/media\/audio\/c9\/fa\/c989d3797f4ff57a89611196c6a6fffa\/ld\/ld.m3u8","chapter_id":"0","column_had_sub":true,"audio_dubber":"傅健","is_finished":false,"inline_video_subtitles":{},"like":{"had_done":false,"count":7},"neighbors":{"left":{"id":371184,"article_title":"08｜答疑现场：Spring Core 篇思考题合集"},"right":{"id":373215,"article_title":"09｜Spring Web URL 解析常见错误"}},"audio_time":"00:07:19","video_height":0,"rate_percent":0,"article_content":"<p>你好，我是傅健。<\/p><p>上一章节我们学习了自动注入、AOP 等 Spring 核心知识运用上的常见错误案例。然而，我们<strong>使用 Spring 大多还是为了开发一个 Web 应用程序<\/strong>，所以从这节课开始，我们将学习Spring Web 的常见错误案例。<\/p><p>在这之前，我想有必要先给你简单介绍一下 Spring Web 最核心的流程，这可以让我们后面的学习进展更加顺利一些。<\/p><p>那什么是 Spring Web 最核心的流程呢？无非就是一个 HTTP 请求的处理过程。这里我以 Spring Boot 的使用为例，以尽量简单的方式带你梳理下。<\/p><p>首先，回顾下我们是怎么添加一个 HTTP 接口的，示例如下：<\/p><pre><code>@RestController\npublic class HelloWorldController {\n    @RequestMapping(path = &quot;hi&quot;, method = RequestMethod.GET)\n    public String hi(){\n         return &quot;helloworld&quot;;\n    };\n}\n<\/code><\/pre><p>这是我们最喜闻乐见的一个程序，但是对于很多程序员而言，其实完全不知道为什么这样就工作起来了。毕竟，不知道原理，它也能工作起来。<\/p><p>但是，假设你是一个严谨且有追求的人，你大概率是有好奇心去了解它的。而且相信我，这个问题面试也可能会问到。我们一起来看看它背后的故事。<\/p><p>其实仔细看这段程序，你会发现一些<strong>关键的“元素”<\/strong>：<\/p><ol>\n<li>请求的 Path: hi<\/li>\n<li>请求的方法：Get<\/li>\n<li>对应方法的执行：hi()<\/li>\n<\/ol><p>那么，假设让你自己去实现 HTTP 的请求处理，你可能会写出这样一段伪代码：<\/p><pre><code>public class HttpRequestHandler{\n    \n    Map&lt;RequestKey, Method&gt; mapper = new HashMap&lt;&gt;();\n    \n    public Object handle(HttpRequest httpRequest){\n         RequestKey requestKey = getRequestKey(httpRequest);         \n         Method method = this.mapper.getValue(requestKey);\n         Object[] args = resolveArgsAccordingToMethod(httpRequest, method);\n         return method.invoke(controllerObject, args);\n    };\n}\n<\/code><\/pre><!-- [[[read_end]]] --><p>那么现在需要哪些组件来完成一个请求的对应和执行呢？<\/p><ol>\n<li>需要有一个地方（例如 Map）去维护从 HTTP path\/method 到具体执行方法的映射；<\/li>\n<li>当一个请求来临时，根据请求的关键信息来获取对应的需要执行的方法；<\/li>\n<li>根据方法定义解析出调用方法的参数值，然后通过反射调用方法，获取返回结果。<\/li>\n<\/ol><p>除此之外，你还需要一个东西，就是利用底层通信层来解析出你的 HTTP 请求。只有解析出请求了，才能知道 path\/method 等信息，才有后续的执行，否则也是“巧妇难为无米之炊”了。<\/p><p>所以综合来看，你大体上需要这些过程才能完成一个请求的解析和处理。那么接下来我们就按照处理顺序分别看下 Spring Boot 是如何实现的，对应的一些关键实现又长什么样。<\/p><p>首先，解析 HTTP 请求。对于 Spring 而言，它本身并不提供通信层的支持，它是依赖于Tomcat、Jetty等容器来完成通信层的支持，例如当我们引入Spring  Boot时，我们就间接依赖了Tomcat。依赖关系图如下：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/bf\/71\/bf28efcd2d8dc920dddbe4dabaeefb71.png?wh=851*218\" alt=\"\"><\/p><p>另外，正是这种自由组合的关系，让我们可以做到直接置换容器而不影响功能。例如我们可以通过下面的配置从默认的Tomcat切换到Jetty：<\/p><pre><code>    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;\/groupId&gt;\n       &lt;artifactId&gt;spring-boot-starter-web&lt;\/artifactId&gt;\n       &lt;exclusions&gt;\n             &lt;exclusion&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;\/groupId&gt;\n                &lt;artifactId&gt;spring-boot-starter-tomcat&lt;\/artifactId&gt;\n             &lt;\/exclusion&gt;\n        &lt;\/exclusions&gt;- \n    &lt;\/dependency&gt;\n    &lt;!-- Use Jetty instead --&gt;\n &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;\/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-jetty&lt;\/artifactId&gt;\n    &lt;\/dependency&gt;\n<\/code><\/pre><p>依赖了Tomcat后，Spring Boot在启动的时候，就会把Tomcat启动起来做好接收连接的准备。<\/p><p>关于Tomcat如何被启动，你可以通过下面的调用栈来大致了解下它的过程：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/45\/44\/456dc47793b0f99c9c2d193027f0ed44.png?wh=1074*405\" alt=\"\"><\/p><p>说白了，就是调用下述代码行就会启动Tomcat：<\/p><pre><code>SpringApplication.run(Application.class, args);\n<\/code><\/pre><p>那为什么使用的是Tomcat？你可以看下面这个类，或许就明白了：<\/p><pre><code>\/\/org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryConfiguration\n\nclass ServletWebServerFactoryConfiguration {\n\n   @Configuration(proxyBeanMethods = false)\n   @ConditionalOnClass({ Servlet.class, Tomcat.class, UpgradeProtocol.class })\n   @ConditionalOnMissingBean(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT)\n   public static class EmbeddedTomcat {\n      @Bean\n      public TomcatServletWebServerFactory tomcatServletWebServerFactory(\n         \/\/省略非关键代码\n         return factory;\n      }\n\n   }\n   \n@Configuration(proxyBeanMethods = false)\n@ConditionalOnClass({ Servlet.class, Server.class, Loader.class, WebAppContext.class })\n@ConditionalOnMissingBean(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT)\npublic static class EmbeddedJetty {\n   @Bean\n   public JettyServletWebServerFactory JettyServletWebServerFactory(\n         ObjectProvider&lt;JettyServerCustomizer&gt; serverCustomizers) {\n       \/\/省略非关键代码\n      return factory;\n   }\n}\n\n\/\/省略其他容器配置\n}\n\n\n<\/code><\/pre><p>前面我们默认依赖了Tomcat内嵌容器的JAR，所以下面的条件会成立，进而就依赖上了Tomcat：<\/p><pre><code>   @ConditionalOnClass({ Servlet.class, Tomcat.class, UpgradeProtocol.class })\n<\/code><\/pre><p>有了Tomcat后，当一个HTTP请求访问时，会触发Tomcat底层提供的NIO通信来完成数据的接收，这点我们可以从下面的代码（org.apache.tomcat.util.net.NioEndpoint.Poller#run）中看出来：<\/p><pre><code>@Override\npublic void run() {\n    while (true) {\n         \/\/省略其他非关键代码\n         \/\/轮询注册的兴趣事件\n         if (wakeupCounter.getAndSet(-1) &gt; 0) {\n               keyCount = selector.selectNow();\n         } else {\n               keyCount = selector.select(selectorTimeout);\n \n        \/\/省略其他非关键代码\n        Iterator&lt;SelectionKey&gt; iterator =\n            keyCount &gt; 0 ? selector.selectedKeys().iterator() : null;\n\n        while (iterator != null &amp;&amp; iterator.hasNext()) {\n            SelectionKey sk = iterator.next();\n            NioSocketWrapper socketWrapper = (NioSocketWrapper)  \n            \/\/处理事件\n            processKey(sk, socketWrapper);\n            \/\/省略其他非关键代码\n           \n        }\n       \/\/省略其他非关键代码\n    }\n \n}\n<\/code><\/pre><p>上述代码会完成请求事件的监听和处理，最终在processKey中把请求事件丢入线程池去处理。请求事件的接收具体调用栈如下：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/f4\/e3\/f4b3febfced888415038f4b7cccb2fe3.png?wh=810*167\" alt=\"\"><\/p><p>线程池对这个请求的处理的调用栈如下：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/99\/e0\/99021847afb18bf522860cf2a42aa3e0.png?wh=852*592\" alt=\"\"><\/p><p>在上述调用中，最终会进入Spring Boot的处理核心，即DispatcherServlet（上述调用栈没有继续截取完整调用，所以未显示）。可以说，DispatcherServlet是用来处理HTTP请求的中央调度入口程序，为每一个 Web 请求映射一个请求的处理执行体（API controller\/method）。<\/p><p>我们可以看下它的核心是什么？它本质上就是一种Servlet，所以它是由下面的Servlet核心方法触发：<\/p><blockquote>\n<p>javax.servlet.http.HttpServlet#service(javax.servlet.ServletRequest, javax.servlet.ServletResponse)<\/p>\n<\/blockquote><p>最终它执行到的是下面的doService()，这个方法完成了请求的分发和处理：<\/p><pre><code>@Override\nprotected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {\n      doDispatch(request, response);\n}\n<\/code><\/pre><p>我们可以看下它是如何分发和执行的：<\/p><pre><code>protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n   \n \/\/ 省略其他非关键代码\n \/\/ 1. 分发：Determine handler for the current request.\n  HandlerExecutionChain mappedHandler = getHandler(processedRequest);\n \n \/\/ 省略其他非关键代码\n \/\/Determine handler adapter for the current request.\n  HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n \n \/\/ 省略其他非关键代码\n \/\/ 2. 执行：Actually invoke the handler.\n  mv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n  \n \/\/ 省略其他非关键代码\n     \n}\n<\/code><\/pre><p>在上述代码中，很明显有两个关键步骤：<\/p><p><strong>1.  分发，即根据请求寻找对应的执行方法<\/strong><\/p><p>寻找方法参考DispatcherServlet#getHandler，具体的查找远比开始给出的Map查找来得复杂，但是无非还是一个根据请求寻找候选执行方法的过程，这里我们可以通过一个调试视图感受下这种对应关系：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/58\/dc\/58f9b4c2ac68e8648f441381f1ff88dc.png?wh=1526*444\" alt=\"\"><\/p><p>这里的关键映射Map，其实就是上述调试视图中的RequestMappingHandlerMapping。<\/p><p><strong>2.  执行，反射执行寻找到的执行方法<\/strong><\/p><p>这点可以参考下面的调试视图来验证这个结论，参考代码org.springframework.web.method.support.InvocableHandlerMethod#doInvoke：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/6d\/94\/6d83528c381441a11bfc111f0f645794.png?wh=1326*419\" alt=\"\"><\/p><p>最终我们是通过反射来调用执行方法的。<\/p><p>通过上面的梳理，你应该基本了解了一个HTTP请求是如何执行的。但是你可能会产生这样一个疑惑：Handler的映射是如何构建出来的呢？<\/p><p>说白了，核心关键就是RequestMappingHandlerMapping这个Bean的构建过程。<\/p><p>它的构建完成后，会调用afterPropertiesSet来做一些额外的事，这里我们可以先看下它的调用栈：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/f1\/16\/f106c25aed5f62fce28d589390891b16.png?wh=1201*290\" alt=\"\"><\/p><p>其中关键的操作是AbstractHandlerMethodMapping#processCandidateBean方法：<\/p><pre><code>protected void processCandidateBean(String beanName) {\n   \/\/省略非关键代码\n   if (beanType != null &amp;&amp; isHandler(beanType)) {\n      detectHandlerMethods(beanName);\n   }\n}\n<\/code><\/pre><p>isHandler(beanType)的实现参考以下关键代码：<\/p><pre><code>@Override\nprotected boolean isHandler(Class&lt;?&gt; beanType) {\n   return (AnnotatedElementUtils.hasAnnotation(beanType, Controller.class) ||\n         AnnotatedElementUtils.hasAnnotation(beanType, RequestMapping.class));\n}\n<\/code><\/pre><p>这里你会发现，判断的关键条件是，是否标记了合适的注解（Controller或者RequestMapping）。只有标记了，才能添加到Map信息。换言之，Spring在构建RequestMappingHandlerMapping时，会处理所有标记Controller和RequestMapping的注解，然后解析它们构建出请求到处理的映射关系。<\/p><p>以上即为Spring Boot处理一个HTTP请求的核心过程，无非就是绑定一个内嵌容器（Tomcat\/Jetty\/其他）来接收请求，然后为请求寻找一个合适的方法，最后反射执行它。当然，这中间还会掺杂无数的细节，不过这不重要，抓住这个核心思想对你接下来理解Spring Web中各种类型的错误案例才是大有裨益的！<\/p>","footer_cover_data":{"img_url":"","mp_url":"","link_url":""},"article_cover_hidden":false,"column_is_experience":false,"is_required":false,"rate":{},"product_id":100077001,"like_count":31,"had_liked":false,"article_subtitle":"无","audio_download_url":"https:\/\/static001.geekbang.org\/resource\/audio\/c9\/fa\/c989d3797f4ff57a89611196c6a6fffa.mp3","id":372003,"had_viewed":false,"article_title":"导读｜5分钟轻松了解一个HTTP请求的处理过程","column_bgcolor":"#F6F7FB","share":{"content":"Spring 开发老兵 10 年避坑心法","title":"傅健 · Spring编程常见错误50例","poster":"https:\/\/static001.geekbang.org\/resource\/image\/81\/cf\/81d9cef44e90ff4890d04b735fd135cf.jpg","cover":"https:\/\/static001.geekbang.org\/resource\/image\/82\/a2\/829d02f2fc0e10860d7b5401f2160ba2.jpg"},"is_video_preview":false,"article_summary":"使用 Spring 大多还是为了开发一个 Web 应用程序。","article_poster_wxlite":"https:\/\/static001.geekbang.org\/render\/screen\/09\/dd\/0996ba2332c5b31dbb09f0e860de8bdd.jpeg","column_sale_type":2,"article_features":0,"article_could_preview":false,"column_cover":"https:\/\/static001.geekbang.org\/resource\/image\/82\/a2\/829d02f2fc0e10860d7b5401f2160ba2.jpg","column_id":408,"audio_time_arr":{"m":"07","s":"19","h":"00"},"video_time":"","audio_title":"傅健-导读2修改","audio_md5":"c989d3797f4ff57a89611196c6a6fffa","video_size":0,"text_read_percent":0,"comment_count":3,"cid":408,"article_sharetitle":"5分钟轻松了解一个HTTP请求的处理过程","column_is_onboard":true,"article_cshort":"<p>你好，我是傅健。<\/p><p>上一章节我们学习了自动注入、AOP 等 Spring 核心知识运用上的常见错误案例。然而，我们<strong>使用 Spring 大多还是为了开发一个 Web 应用程序<\/strong>，所以从这节课开始，我们将学习Spring Web 的常见错误案例。<\/p><p>在这之前，我想有必要先给你简单介绍一下 Spring Web 最核心的流程，这可以让我们后面的学习进展更加顺利一些。<\/p><p>那什么是 Spring Web 最核心的流程呢？无非就是一个 HTTP 请求的处理过程。这里我以 Spring Boot 的使用为例，以尽量简单的方式带你梳理下。<\/p><p>首先，回顾下我们是怎么添加一个 HTTP 接口的，示例如下：<\/p><pre><code>@RestController\npublic class HelloWorldController {\n    @RequestMapping(path = &quot;hi&quot;, method = RequestMethod.GET)\n    public String hi(){\n         return &quot;helloworld&quot;;\n    };\n}\n<\/code><\/pre><p>这是我们最喜闻乐见的一个程序，但是对于很多程序员而言，其实完全不知道为什么这样就工作起来了。毕竟，不知道原理，它也能工作起来。<\/p><p>但是，假设你是一个严谨且有追求的人，你大概率是有好奇心去了解它的。而且相信我，这个问题面试也可能会问到。我们一起来看看它背后的故事。<\/p><p>其实仔细看这段程序，你会发现一些<strong>关键的“元素”<\/strong>：<\/p><ol>\n<li>请求的 Path: hi<\/li>\n<li>请求的方法：Get<\/li>\n<li>对应方法的执行：hi()<\/li>\n<\/ol><p>那么，假设让你自己去实现 HTTP 的请求处理，你可能会写出这样一段伪代码：<\/p><pre><code>public class HttpRequestHandler{\n    \n    Map&lt;RequestKey, Method&gt; mapper = new HashMap&lt;&gt;();\n    \n    public Object handle(HttpRequest httpRequest){\n         RequestKey requestKey = getRequestKey(httpRequest);         \n         Method method = this.mapper.getValue(requestKey);\n         Object[] args = resolveArgsAccordingToMethod(httpRequest, method);\n         return method.invoke(controllerObject, args);\n    };\n}\n<\/code><\/pre>","video_width":0,"column_could_sub":true,"article_ctime":1620576000,"score":"31620576000","video_media_map":{},"video_preview":{},"video":0,"video_time_arr":{"m":"","s":"","h":""},"video_total_seconds":0},"extra":{},"error":{}}