{"code":0,"data":{"video_id":"","sku":"100077001","video_cover":"","author_name":"傅健","text_read_version":0,"audio_size":8891721,"article_cover":"https:\/\/static001.geekbang.org\/resource\/image\/df\/30\/dfdc54b4633f0fd50da80f56yyfbda30.jpg","subtitles":{},"product_type":"c1","audio_url":"https:\/\/res001.geekbang.org\/media\/audio\/e5\/bd\/e5b6ba38yy38a02973e38f9004f146bd\/ld\/ld.m3u8","chapter_id":"0","column_had_sub":true,"audio_dubber":"傅健","is_finished":false,"inline_video_subtitles":{},"like":{"had_done":false,"count":2},"neighbors":{"left":{"id":384537,"article_title":"23｜答疑现场：Spring 补充篇思考题合集"},"right":{"id":385746,"article_title":"结束语｜问题总比解决办法多"}},"audio_time":"00:09:17","video_height":0,"rate_percent":0,"article_content":"<p>你好，我是傅健。<\/p><p>前面，我们介绍了50个各式各样的问题，在正式结束课程之前，我觉得有必要带着你去梳理下或者说复盘下问题出现的原因。错误的表现千万种，但是如果追根溯源的话，其实根源不会太多。<\/p><p>当然可能有的同学会把所有的问题都简单粗暴地归结为“学艺不精”，但是除了这个明显的原因外，我想你还是应该深入思考下，最起码，假设是Spring本身就很容易让人犯的错误，你至少是有意识的。那么接下来，我们就来梳理下关于Spring使用中常见的一些错误根源。<\/p><h2>隐式规则的存在<\/h2><p>要想使用好 Spring，你就一<strong>定要了解它的一些潜规则<\/strong>，例如默认扫描Bean的范围、自动装配构造器等等。如果我们不了解这些规则，大多情况下虽然也能工作，但是稍微变化，则可能完全失效，例如在<a href=\"https:\/\/time.geekbang.org\/column\/article\/364761\">第1课<\/a>的案例1中，我们使用 Spring Boot 来快速构建了一个简易的 Web 版 HelloWorld：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/ca\/a0\/ca8e3fd8b3e39833d29c7041cfa47ea0.png?wh=345x87\" alt=\"\"><\/p><p>其中，负责启动程序的 Application 类定义如下：<\/p><pre><code>package com.spring.puzzle.class1.example1.application\n\/\/省略 import\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n<\/code><\/pre><p>提供接口的 HelloWorldController 代码如下：<\/p><pre><code>package com.spring.puzzle.class1.example1.application\n\/\/省略 import\n@RestController\npublic class HelloWorldController {\n    @RequestMapping(path = &quot;hi&quot;, method = RequestMethod.GET)\n    public String hi(){\n         return &quot;helloworld&quot;;\n    };\n}\n<\/code><\/pre><p>但是，假设有一天，当我们需要添加多个类似的 Controller，同时又希望用更清晰的包层次结构来管理时，我们可能会去单独建立一个独立于 application 包之外的 Controller 包，并调整类的位置。调整后结构示意如下：<\/p><!-- [[[read_end]]] --><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/a5\/d0\/a5d9b1bdfa138ca9460202b7c3fdbfd0.png?wh=335x110\" alt=\"\"><\/p><p>这样就会工作不起来了，追根溯源，你可能忽略了Sping Boot中@SpringBootApplication是有一个默认的扫描包范围的。这就是一个隐私规则。如果你原本不知道，那么犯错概率还是很高的。类似的案例这里不再赘述。<\/p><h2>默认配置不合理<\/h2><p>除了上述原因以外，还有一个很重要的因素在于，Spring默认的配置不见得是合理的。<\/p><p>你可以思考这样一个问题，如果让我们写一个框架，我们最大的追求肯定是让用户“快速上手”，这样才好推广。所以我们肯定不会去写一堆配置，而是采用默认值的方式。但是这里面你提出的默认值一定是用户需要的么？未必。这时候，你可能会妥协地满足80%的用户使用场景。所以在使用时，你一定要考虑自己是不是那多余的20%。<\/p><p>一起复习这样一个的案例，在<a href=\"https:\/\/time.geekbang.org\/column\/article\/380565\">第18课<\/a>的案例2中，当我们什么都不去配置，而是直接使用 Spring Data Cassandra 来操作时，我们实际依赖了 Cassandra driver 内部的配置文件，具体目录如下：<\/p><blockquote>\n<p>.m2\\repository\\com\\datastax\\oss\\java-driver-core\\4.6.1\\java-driver-core-4.6.1.jar!\\reference.conf<\/p>\n<\/blockquote><p>我们可以看下它存在很多默认的配置，其中一项很重要的配置是 Consistency，在 driver 中默认为 LOCAL_ONE，具体如下：<\/p><pre><code>basic.request {\n \n\n  # The consistency level.\n  #\n  # Required: yes\n  # Modifiable at runtime: yes, the new value will be used for requests issued after the change.\n  # Overridable in a profile: yes\n  consistency = LOCAL_ONE\n \n\/\/省略其他非关键配置 \n}\n<\/code><\/pre><p>当你第一次学习和应用 Cassandra 时，你一定会先只装一台机器玩玩。此时，设置为 LOCAL_ONE 其实是最合适的，也正因为只有一台机器，你的读写都只能命中一台。这样的话，读写是完全没有问题的。<\/p><p>但是产线上的 Cassandra 大多都是多数据中心多节点的，备份数大于1。所以读写都用 LOCAL_ONE 就会出现问题。所以这样说，你就理解了我要表达的意思了吧？Spring采用了一堆默认配置有其原因，但不见得适合你的情况。<\/p><h2>追求奇技淫巧<\/h2><p>Spring给我们提供了很多易用的可能，然后有时候，你用着用着会觉得，Spring怎么用都能工作起来，特别是你在网上看到了一些更简洁高效的写法之后，你会觉得惊喜，原来这样也可以。但是Spring真的是无所不能地随意使用么？<\/p><p>这里让我们快速回顾下<a href=\"https:\/\/time.geekbang.org\/column\/article\/373215\">第9课<\/a>的案例2，我们常常使用@RequestParam 和@PathVarible 来获取请求参数（request parameters）以及 path 中的部分。但是在频繁使用这些参数时，不知道你有没有觉得它们的使用方式并不友好，例如我们去获取一个请求参数 name，我们会定义如下：<\/p><blockquote>\n<p>@RequestParam(\"name\") String name<\/p>\n<\/blockquote><p>此时，我们会发现变量名称大概率会被定义成 RequestParam值。所以我们是不是可以用下面这种方式来定义：<\/p><blockquote>\n<p>@RequestParam String name<\/p>\n<\/blockquote><p>这种方式确实是可以的，本地测试也能通过。这里我给出了完整的代码，你可以感受下这两者的区别：<\/p><pre><code>@RequestMapping(path = &quot;\/hi1&quot;, method = RequestMethod.GET)\npublic String hi1(@RequestParam(&quot;name&quot;) String name){\n    return name;\n};\n\n@RequestMapping(path = &quot;\/hi2&quot;, method = RequestMethod.GET)\npublic String hi2(@RequestParam String name){\n    return name;\n};\n<\/code><\/pre><p>很明显，对于喜欢追究极致简洁的同学来说，这个酷炫的功能是一个福音。但当我们换一个项目时，有可能上线后就失效了，然后报错 500，提示匹配不上。<\/p><p>这个案例的原因，我就不复述了，我只是想说，通过这个案例，你要明白Spring虽然强大，看起来怎么都能玩转，但是实际并非一定如此。<\/p><h2>理所当然地使用<\/h2><p>在使用Spring框架时，有时候，我们会不假思索地随意下结论。例如，我们在处理HTTP Header遇到需要处理多个Header时，我们第一反映是使用一个HashMap来接收，但是会满足所有情况么？让我们快速回顾下<a href=\"https:\/\/time.geekbang.org\/column\/article\/373942\">第10课<\/a>的案例1。<\/p><p>在 Spring 中解析 Header 时，我们在多数场合中是直接按需解析的。例如，我们想使用一个名为myHeaderName的 Header，我们会书写代码如下：<\/p><pre><code>@RequestMapping(path = &quot;\/hi&quot;, method = RequestMethod.GET)\npublic String hi(@RequestHeader(&quot;myHeaderName&quot;) String name){\n   \/\/省略 body 处理\n};\n<\/code><\/pre><p>定义一个参数，标记上@RequestHeader，指定要解析的 Header 名即可。但是假设我们需要解析的 Header 很多时，按照上面的方式很明显会使得参数越来越多。在这种情况下，我们一般都会使用 Map 去把所有的 Header 都接收到，然后直接对 Map 进行处理。于是我们可能会写出下面的代码：<\/p><pre><code>@RequestMapping(path = &quot;\/hi1&quot;, method = RequestMethod.GET)\npublic String hi1(@RequestHeader() Map map){\n    return map.toString();\n};\n<\/code><\/pre><p>粗略测试程序，你会发现一切都很好。而且上面的代码也符合针对接口编程的范式，即使用了 Map 这个接口类型。但是上面的接口定义在遇到下面的请求时，就会超出预期。请求如下：<\/p><blockquote>\n<p>GET <a href=\"http:\/\/localhost:8080\/hi1\">http:\/\/localhost:8080\/hi1<\/a><br>\nmyheader: h1<br>\nmyheader: h2<\/p>\n<\/blockquote><p>这里存在一个 Header 名为 myHeader，不过这个 Header 有两个值。此时我们执行请求，会发现返回的结果并不能将这两个值如数返回。结果示例如下：<\/p><pre><code>{myheader=h1, host=localhost:8080, connection=Keep-Alive, user-agent=Apache-HttpClient\/4.5.12 (Java\/11.0.6), accept-encoding=gzip,deflate}\n<\/code><\/pre><p>实际上，<strong>要完整接收到所有的 Header，不能直接使用Map而应该使用MultiValueMap。<\/strong><\/p><p>借着这个案例，可以思考下你为什么会出错？因为你肯定知道要用一个Map来接收，也相信一定可以，但是你可能疏忽了你用的Map是Spring给你返回的Map。所以有时候，一些“理所当然”的结论其实是错误的。一定要大胆假设、小心求证，才能规避很多问题。<\/p><h2>无关的依赖变动<\/h2><p>Spring依赖了大量的其他组件来协同完成功能，但是完成同一个功能的组件却可能存在多种工具，例如Spring完成JSON操作，既可以依赖Gson，也可以依赖Jackson。更可怕的是Spring往往是动态依赖的，即优先看看优选的工具是否存在，存在则用，不存在才看其他依赖的工具类型是否存在。这样的逻辑会导致项目的依赖不同时，依赖的工具也不同，从而引发一些微妙的行为“变化”。<\/p><p>我们可以快速复习下<a href=\"https:\/\/time.geekbang.org\/column\/article\/374654\">第11课<\/a>的案例2，首先看下面这段代码：<\/p><pre><code>@RestController\npublic class HelloController {\n    \n    @PostMapping(&quot;\/hi2&quot;)\n    public Student hi2(@RequestBody Student student) {\n        return student;\n    }\n    \n}\n<\/code><\/pre><p>这段代码接收了一个 Student 对象，然后原样返回。我们使用下面的测试请求进行测试：<\/p><blockquote>\n<p>POST <a href=\"http:\/\/localhost:8080\/springmvc3_war\/app\/hi2\">http:\/\/localhost:8080\/springmvc3_war\/app\/hi2<\/a><br>\nContent-Type: application\/json<br>\n{<br>\n\"name\": \"xiaoming\"<br>\n}<\/p>\n<\/blockquote><p>经过测试，我们会得到以下结果：<\/p><blockquote>\n<p>{<br>\n\"name\": \"xiaoming\"<br>\n}<\/p>\n<\/blockquote><p>但是随着项目的推进，在代码并未改变时，我们可能会返回以下结果：<\/p><blockquote>\n<p>&nbsp;<br>\n{<br>\n\"name\": \"xiaoming\",<br>\n\"age\": null<br>\n}<\/p>\n<\/blockquote><p>即当 age 取不到值，开始并没有序列化它作为响应 Body 的一部分，后来又序列化成 null 作为 Body 返回了。<\/p><p>如果我们发现上述问题，那么很有可能是上述描述的依赖变动造成的。具体而言，在后续的代码开发中，我们直接依赖或者间接依赖了新的 JSON 解析器，例如下面这种方式就依赖了Jackson：<\/p><pre><code>&lt;dependency&gt;\n     &lt;groupId&gt;com.fasterxml.jackson.core&lt;\/groupId&gt;\n     &lt;artifactId&gt;jackson-databind&lt;\/artifactId&gt;\n     &lt;version&gt;2.9.6&lt;\/version&gt;\n &lt;\/dependency&gt;\n<\/code><\/pre><p>诸如此类问题，一般不会出现严重的问题，但是你一定要意识到，当你的代码不变时，你的依赖变了，行为则可能“异常”了。<\/p><h2>通用错误<\/h2><p>实际上，除了上面的一些原因外，还有不少错误是所有类似Spring框架都要面对的问题。例如，处理一个HTTP请求，Path Variable 含有特殊字符\/时，一般都会有问题，大多需要额外的处理。我们可以复习下<a href=\"https:\/\/time.geekbang.org\/column\/article\/373215\">第9课<\/a>的案例1。<\/p><p>在解析一个 URL 时，我们经常会使用到@PathVariable 这个注解。例如我们会经常见到如下风格的代码：<\/p><pre><code>@RestController\n@Slf4j\npublic class HelloWorldController {\n    @RequestMapping(path = &quot;\/hi1\/{name}&quot;, method = RequestMethod.GET)\n    public String hello1(@PathVariable(&quot;name&quot;) String name){\n        return name;\n        \n    };  \n}\n<\/code><\/pre><p>当我们使用 <a href=\"http:\/\/localhost:8080\/hi1\/xiaoming\">http:\/\/localhost:8080\/hi1\/xiaoming<\/a> 访问这个服务时，会返回\"xiaoming\"，即 Spring 会把 name 设置为 URL 中对应的值。<\/p><p>看起来顺风顺水，但是假设这个 name 中含有特殊字符\/时（例如 <a href=\"http:\/\/localhost:8080\/hi1\/xiaoming\">http:\/\/localhost:8080\/hi1\/xiao\/ming<\/a> ），会如何？如果我们不假思索，或许答案是\"xiao\/ming\"？然而稍微敏锐点的程序员都会判定这个访问是会报错的。<\/p><p>这个案例其实你换别的HTTP服务框架也可能需要处理，这种问题就是一些通用的问题，并不是因为你使用Spring才出现的。<\/p><p>通过思考上述错误根源，其实你应该相信了，除了学艺不精之外，还有一部分原因在于我们的“武断”和Spring的好用。也正因为它的好用，让我们很少去思考它的内部运作机制，当我们大刀阔斧地到处使用Spring时，可能不小心就踩坑了。所以当你使用Spring时，不妨大胆假设、小心求证，多看看别人犯的错误，多总结总结最佳实践。这样才能一劳永逸，更加熟练和自信地使用Spring！<\/p>","footer_cover_data":{"img_url":"","mp_url":"","link_url":""},"article_cover_hidden":false,"column_is_experience":false,"is_required":true,"rate":{},"product_id":100077001,"like_count":6,"had_liked":false,"article_subtitle":"无","audio_download_url":"https:\/\/static001.geekbang.org\/resource\/audio\/e5\/bd\/e5b6ba38yy38a02973e38f9004f146bd.mp3","id":384890,"had_viewed":false,"article_title":"知识回顾 | 系统梳理Spring编程错误根源","column_bgcolor":"#F6F7FB","share":{"content":"Spring 开发老兵 10 年避坑心法","title":"傅健 · Spring编程常见错误50例","poster":"https:\/\/static001.geekbang.org\/resource\/image\/81\/cf\/81d9cef44e90ff4890d04b735fd135cf.jpg","cover":"https:\/\/static001.geekbang.org\/resource\/image\/82\/a2\/829d02f2fc0e10860d7b5401f2160ba2.jpg"},"is_video_preview":false,"article_summary":"错误的表现千万种，但是如果追根溯源的话，其实根源不会太多。","article_poster_wxlite":"https:\/\/static001.geekbang.org\/render\/screen\/9f\/30\/9f8de7344cfdfdaca1f13fd3d79c6c30.jpeg","column_sale_type":2,"article_features":0,"article_could_preview":false,"column_cover":"https:\/\/static001.geekbang.org\/resource\/image\/82\/a2\/829d02f2fc0e10860d7b5401f2160ba2.jpg","column_id":408,"audio_time_arr":{"m":"09","s":"17","h":"00"},"video_time":"","audio_title":"傅健-知识回顾","audio_md5":"e5b6ba38yy38a02973e38f9004f146bd","video_size":0,"text_read_percent":0,"comment_count":1,"cid":408,"article_sharetitle":"知识回顾：系统梳理Spring编程错误根源","column_is_onboard":true,"article_cshort":"<p>你好，我是傅健。<\/p><p>前面，我们介绍了50个各式各样的问题，在正式结束课程之前，我觉得有必要带着你去梳理下或者说复盘下问题出现的原因。错误的表现千万种，但是如果追根溯源的话，其实根源不会太多。<\/p><p>当然可能有的同学会把所有的问题都简单粗暴地归结为“学艺不精”，但是除了这个明显的原因外，我想你还是应该深入思考下，最起码，假设是Spring本身就很容易让人犯的错误，你至少是有意识的。那么接下来，我们就来梳理下关于Spring使用中常见的一些错误根源。<\/p><h2>隐式规则的存在<\/h2><p>要想使用好 Spring，你就一<strong>定要了解它的一些潜规则<\/strong>，例如默认扫描Bean的范围、自动装配构造器等等。如果我们不了解这些规则，大多情况下虽然也能工作，但是稍微变化，则可能完全失效，例如在<a href=\"https:\/\/time.geekbang.org\/column\/article\/364761\">第1课<\/a>的案例1中，我们使用 Spring Boot 来快速构建了一个简易的 Web 版 HelloWorld：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/ca\/a0\/ca8e3fd8b3e39833d29c7041cfa47ea0.png?wh=345x87\" alt=\"\"><\/p><p>其中，负责启动程序的 Application 类定义如下：<\/p><pre><code>package com.spring.puzzle.class1.example1.application\n\/\/省略 import\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n<\/code><\/pre><p>提供接口的 HelloWorldController 代码如下：<\/p><pre><code>package com.spring.puzzle.class1.example1.application\n\/\/省略 import\n@RestController\npublic class HelloWorldController {\n    @RequestMapping(path = &quot;hi&quot;, method = RequestMethod.GET)\n    public String hi(){\n         return &quot;helloworld&quot;;\n    };\n}\n<\/code><\/pre><p>但是，假设有一天，当我们需要添加多个类似的 Controller，同时又希望用更清晰的包层次结构来管理时，我们可能会去单独建立一个独立于 application 包之外的 Controller 包，并调整类的位置。调整后结构示意如下：<\/p>","video_width":0,"column_could_sub":true,"article_ctime":1623772800,"score":"41623772800","video_media_map":{},"video_preview":{},"video":0,"video_time_arr":{"m":"","s":"","h":""},"video_total_seconds":0},"extra":{},"error":{}}