{"code":0,"data":{"video_id":"","sku":"100077001","video_cover":"","author_name":"傅健","text_read_version":0,"audio_size":611498,"article_cover":"https:\/\/static001.geekbang.org\/resource\/image\/bb\/af\/bb54244d19bbf1646bb39e84b3e605af.jpg","subtitles":{},"product_type":"c1","audio_url":"https:\/\/res001.geekbang.org\/media\/audio\/cb\/37\/cb0805b9fdc838e1bc1yyd646c5yy437\/ld\/ld.m3u8","chapter_id":"0","column_had_sub":true,"audio_dubber":"傅健","is_finished":false,"inline_video_subtitles":{},"like":{"had_done":false,"count":1},"neighbors":{"left":{"id":383756,"article_title":"22 | Spring Test 常见错误"},"right":{"id":384890,"article_title":"知识回顾 | 系统梳理Spring编程错误根源"}},"audio_time":"00:00:37","video_height":0,"rate_percent":0,"article_content":"<p>你好，我是傅健。<\/p><p>欢迎来到第三次答疑现场，恭喜你，到了这，终点已近在咫尺。到今天为止，我们已经解决了 50 个线上问题，是不是很有成就感了？但要想把学习所得真正为你所用还要努力练习呀，这就像理论与实践之间永远有道鸿沟需要我们去跨越一样。那么接下来，话不多说，我们就开始逐一解答第三章的课后思考题了，有任何想法欢迎到留言区补充。<\/p><h2><strong><a href=\"https:\/\/time.geekbang.org\/column\/article\/380565\">第18课<\/a><\/strong><\/h2><p>在案例 1 中使用 Spring Data Redis 时，我们提到了 StringRedisTemplate 和 RedisTemplate。那么它们是如何被创建起来的呢？<\/p><p>实际上，当我们依赖 spring-boot-starter 时，我们就间接依赖了 spring-boot -autoconfigure。<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/d0\/c1\/d07f1bc8f4aab19a834a347bb189abc1.png?wh=744x199\" alt=\"\"><\/p><p>在这个 JAR 中，存在下面这样的一个类，即 RedisAutoConfiguration。<\/p><pre><code>\n@Configuration(proxyBeanMethods = false)\n@ConditionalOnClass(RedisOperations.class)\n@EnableConfigurationProperties(RedisProperties.class)\n@Import({ LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class })\npublic class RedisAutoConfiguration {\n\n   @Bean\n   @ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)\n   @ConditionalOnSingleCandidate(RedisConnectionFactory.class)\n   public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) {\n      RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();\n      template.setConnectionFactory(redisConnectionFactory);\n      return template;\n   }\n\n   @Bean\n   @ConditionalOnMissingBean\n   @ConditionalOnSingleCandidate(RedisConnectionFactory.class)\n   public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) {\n      StringRedisTemplate template = new StringRedisTemplate();\n      template.setConnectionFactory(redisConnectionFactory);\n      return template;\n   }\n\n}\n<\/code><\/pre><p>从上述代码可以看出，当存在RedisOperations这个类时，就会创建 StringRedisTemplate 和 RedisTemplate 这两个 Bean。顺便说句，这个 RedisOperations 是位于 Spring Data Redis 这个 JAR 中。<\/p><p>再回到开头，RedisAutoConfiguration 是如何被发现的呢？实际上，它被配置在<\/p><!-- [[[read_end]]] --><p>spring-boot-autoconfigure 的 META-INF\/spring.factories 中，示例如下：<\/p><pre><code>org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\norg.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.r2dbc.R2dbcRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\\n<\/code><\/pre><p>那么它是如何被加载进去的呢？我们的应用启动程序标记了@SpringBootApplication，这个注解继承了下面这个注解：<\/p><pre><code>\/\/省略其他非关键代码\n@Import(AutoConfigurationImportSelector.class)\npublic @interface EnableAutoConfiguration {\n   \/\/省略其他非关键代码\n}\n<\/code><\/pre><p>当它使用了 AutoConfigurationImportSelector 这个类，这个类就会导入在META-INF\/spring.factories定义的 RedisAutoConfiguration。那么 import 动作是什么时候执行的呢？实际上是在启动应用程序时触发的，调用堆栈信息如下：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/e0\/7f\/e0b20b79f19ff796973973ac1b1fd07f.png?wh=1431x470\" alt=\"\"><\/p><p>结合上面的堆栈和相关源码，我们不妨可以总结下 RedisTemplate 被创建的过程。<\/p><p>当 Spring 启动时，会通过 ConfigurationClassPostProcessor 尝试处理所有标记@Configuration 的类，具体到每个配置类的处理是通过 ConfigurationClassParser 来完成的。<\/p><p>在这个完成过程中，它会使用 ConfigurationClassParser.DeferredImportSelectorHandler 来完成对 Import 的处理。AutoConfigurationImportSelector 就是其中一种Import，它被 @EnableAutoConfiguration 这个注解间接引用。它会加载\"META-INF\/spring.factories\"中定义的 RedisAutoConfiguration，此时我们就会发现 StringRedisTemplate 和 RedisTemplate 这两个 Bean 了。<\/p><h2><strong><a href=\"https:\/\/time.geekbang.org\/column\/article\/381193\">第19课<\/a><\/strong><\/h2><p>RuntimeException 是 Exception 的子类，如果用 rollbackFor=Exception.class，那对 RuntimeException 也会生效。如果我们需要对 Exception 执行回滚操作，但对于 RuntimeException 不执行回滚操作，应该怎么做呢？<\/p><p>我们可以同时为 @Transactional 指定rollbackFor 和noRollbackFor 属性，具体代码示例如下：<\/p><pre><code>@Transactional(rollbackFor = Exception.class, noRollbackFor = RuntimeException.class)\npublic void doSaveStudent(Student student) throws Exception {\n    studentMapper.saveStudent(student);\n    if (student.getRealname().equals(&quot;小明&quot;)) {\n        throw new RuntimeException(&quot;该用户已存在&quot;);\n    }\n}\n<\/code><\/pre><h2><strong><a href=\"https:\/\/time.geekbang.org\/column\/article\/382150\">第20课<\/a><\/strong><\/h2><p>结合案例2，请你思考这样一个问题：在这个案例中，我们在 CardService类方法上声明了这样的事务传播属性，@Transactional(propagation = Propagation.REQUIRES_NEW)，如果使用 Spring 的默认声明行不行，为什么？<\/p><p>答案是不行。我们前面说过，Spring 默认的事务传播类型是 REQUIRED，在有外部事务的情况下，内部事务则会加入原有的事务。如果我们声明成 REQUIRED，当我们要操作 card 数据的时候，持有的依然还会是原来的 DataSource。<\/p><h2><strong><a href=\"https:\/\/time.geekbang.org\/column\/article\/382710\">第21课<\/a><\/strong><\/h2><p>当我们比较案例 1 和案例 2，你会发现不管使用的是查询（Query）参数还是表单（Form）参数，我们的接口定义并没有什么变化，风格如下：<\/p><pre><code>@RestController\npublic class HelloWorldController {\n    @RequestMapping(path = &quot;hi&quot;, method = RequestMethod.GET)\n    public String hi(@RequestParam(&quot;para1&quot;) String para1){\n        return &quot;helloworld:&quot; + para1;\n    };\n\n}\n<\/code><\/pre><p>那是不是 @RequestParam 本身就能处理这两种数据呢？<\/p><p>不考虑实现原理，如果我们仔细看下 @RequestParam 的 API 文档，你就会发现@RequestParam 不仅能处理表单参数，也能处理查询参数。API 文档如下：<\/p><blockquote>\n<p>In Spring MVC, \"request parameters\" map to query parameters, form data, and parts in multipart requests. This is because the Servlet API combines query parameters and form data into a single map called \"parameters\", and that includes automatic parsing of the request body.<\/p>\n<\/blockquote><p>稍微深入一点的话，我们还可以从源码上看看具体实现。<\/p><p>不管是使用 Query 参数还是用 Form 参数来访问，对于案例程序而言，解析的关键逻辑都是类似的，都是通过下面的调用栈完成参数的解析：<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/bd\/84\/bda0bfac82ae819955004d20372f6884.png?wh=1121x449\" alt=\"\"><\/p><p>这里可以看出，负责解析的都是 RequestParamMethodArgumentResolver，解析最后的调用也都是一样的方法。在 org.apache.catalina.connector.Request#parseParameters 这个方法中，对于 From 的解析是这样的：<\/p><pre><code>if (!(&quot;application\/x-www-form-urlencoded&quot;.equals(contentType))) {\n    success = true;\n    return;\n}\n\n\/\/走到这里，说明是 Form: &quot;application\/x-www-form-urlencoded&quot;\nint len = getContentLength();\n\nif (len &gt; 0) {\n    int maxPostSize = connector.getMaxPostSize();\n    if ((maxPostSize &gt;= 0) &amp;&amp; (len &gt; maxPostSize)) {\n       \/\/省略非关键代码\n    }\n    byte[] formData = null;\n    if (len &lt; CACHED_POST_LEN) {\n        if (postData == null) {\n            postData = new byte[CACHED_POST_LEN];\n        }\n        formData = postData;\n    } else {\n        formData = new byte[len];\n    }\n    try {\n        if (readPostBody(formData, len) != len) {\n            parameters.setParseFailedReason(FailReason.REQUEST_BODY_INCOMPLETE);\n            return;\n        }\n    } catch (IOException e) {\n          \/\/省略非关键代码\n    }\n\/\/把 Form 数据添加到 parameter 里面去\nparameters.processParameters(formData, 0, len);\n<\/code><\/pre><p>Form 的数据最终存储在 Parameters#paramHashValues 中。<\/p><p>而对于查询参数的处理，同样是在 org.apache.catalina.connector.Request#parseParameters 中，不过处理它的代码行在 Form 前面一些，关键调用代码行如下：<\/p><pre><code>parameters.handleQueryParameters();\n<\/code><\/pre><p>最终它也是通过 org.apache.tomcat.util.http.Parameters#processParameters 来完成数据的添加。自然，它存储的位置也是 Parameters#paramHashValues 中。<\/p><p>综上可知，虽然使用的是一个固定的注解 @RequestParam，但是它能处理表单和查询参数，因为它们都会存储在同一个位置：Parameters#paramHashValues。<\/p><h2><strong><a href=\"https:\/\/time.geekbang.org\/column\/article\/383756\">第22课<\/a><\/strong><\/h2><p>在案例 1 中，我们解释了为什么测试程序加载不到 spring.xml 文件，根源在于当使用下面的语句加载文件时，它们是采用不同的 Resource 形式来加载的：<\/p><pre><code>@ImportResource(locations = {&quot;spring.xml&quot;})\n<\/code><\/pre><p>具体而言，应用程序加载使用的是 ClassPathResource，测试加载使用的是 ServletContextResource，那么这是怎么造成的呢？<\/p><p>实际上，以何种类型的Resource加载是由 DefaultResourceLoader#getResource 来决定的：<\/p><pre><code>@Override\npublic Resource getResource(String location) {\n   \/\/省略非关键代码\n   if (location.startsWith(&quot;\/&quot;)) {\n      return getResourceByPath(location);\n   }\n   else if (location.startsWith(CLASSPATH_URL_PREFIX)) {\n      return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());\n   }\n   else {\n      try {\n         \/\/ Try to parse the location as a URL...\n         URL url = new URL(location);\n         return (ResourceUtils.isFileURL(url) ? new FileUrlResource(url) : new UrlResource(url));\n      }\n      catch (MalformedURLException ex) {\n         \/\/ No URL -&gt; resolve as resource path.\n         return getResourceByPath(location);\n      }\n   }\n}\n<\/code><\/pre><p>结合上述代码，你可以看出，当使用下面语句时：<\/p><pre><code>@ImportResource(locations = {&quot;classpath:spring.xml&quot;})\n<\/code><\/pre><p>走入的分支是：<\/p><pre><code>   \/\/CLASSPATH_URL_PREFIX:classpath\n   else if (location.startsWith(CLASSPATH_URL_PREFIX)) {\n      return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());\n   }\n<\/code><\/pre><p>即创建的是 ClassPathResource。<\/p><p>而当使用下面语句时：<\/p><pre><code>@ImportResource(locations = {&quot;spring.xml&quot;})\n<\/code><\/pre><p>走入的分支是：<\/p><pre><code>      try {\n         \/\/ 按 URL 加载\n         URL url = new URL(location);\n         return (ResourceUtils.isFileURL(url) ? new FileUrlResource(url) : new UrlResource(url));\n      }\n      catch (MalformedURLException ex) {\n         \/\/ 按路径加载\n         return getResourceByPath(location);\n      }\n<\/code><\/pre><p>先尝试按 URL 加载，很明显这里会失败，因为字符串spring.xml并非一个 URL。随后使用 getResourceByPath()来加载，它会执行到下面的 WebApplicationContextResourceLoader#getResourceByPath()：<\/p><pre><code> private static class WebApplicationContextResourceLoader extends ClassLoaderFilesResourcePatternResolver.ApplicationContextResourceLoader {\n    private final WebApplicationContext applicationContext;\n    \/\/省略非关键代码\n    protected Resource getResourceByPath(String path) {\n        return (Resource)(this.applicationContext.getServletContext() != null ? new ServletContextResource(this.applicationContext.getServletContext(), path) : super.getResourceByPath(path));\n    }\n}\n<\/code><\/pre><p>可以看出，这个时候其实已经和 ApplicationContext 息息相关了。在我们的案例中，最终返回的是 ServletContextResource。<\/p><p>相信看到这里，你就能明白为什么一个小小的改动会导致生成的Resource不同了。无非还是因为你定义了不同的格式，不同的格式创建的资源不同，加载逻辑也不同。至于后续是如何加载的，你可以回看全文。<\/p><p>以上就是这次答疑的全部内容，我们下节课再见！<\/p>","footer_cover_data":{"img_url":"","mp_url":"","link_url":""},"article_cover_hidden":false,"column_is_experience":false,"is_required":false,"rate":{},"product_id":100077001,"like_count":4,"had_liked":false,"article_subtitle":"无","audio_download_url":"https:\/\/static001.geekbang.org\/resource\/audio\/cb\/37\/cb0805b9fdc838e1bc1yyd646c5yy437.mp3","id":384537,"had_viewed":false,"article_title":"23｜答疑现场：Spring 补充篇思考题合集","column_bgcolor":"#F6F7FB","share":{"content":"Spring 开发老兵 10 年避坑心法","title":"傅健 · Spring编程常见错误50例","poster":"https:\/\/static001.geekbang.org\/resource\/image\/81\/cf\/81d9cef44e90ff4890d04b735fd135cf.jpg","cover":"https:\/\/static001.geekbang.org\/resource\/image\/82\/a2\/829d02f2fc0e10860d7b5401f2160ba2.jpg"},"is_video_preview":false,"article_summary":"恭喜你，终点已近在咫尺。","article_poster_wxlite":"https:\/\/static001.geekbang.org\/render\/screen\/7b\/68\/7bde273841743057ad946b1d7d0c9668.jpeg","column_sale_type":1,"article_features":0,"article_could_preview":false,"column_cover":"https:\/\/static001.geekbang.org\/resource\/image\/82\/a2\/829d02f2fc0e10860d7b5401f2160ba2.jpg","column_id":408,"audio_time_arr":{"m":"00","s":"37","h":"00"},"video_time":"","audio_title":"傅建-答疑3","audio_md5":"cb0805b9fdc838e1bc1yyd646c5yy437","video_size":0,"text_read_percent":0,"comment_count":3,"cid":408,"article_sharetitle":"答疑现场：Spring 补充篇思考题合集","column_is_onboard":true,"article_cshort":"<p>你好，我是傅健。<\/p><p>欢迎来到第三次答疑现场，恭喜你，到了这，终点已近在咫尺。到今天为止，我们已经解决了 50 个线上问题，是不是很有成就感了？但要想把学习所得真正为你所用还要努力练习呀，这就像理论与实践之间永远有道鸿沟需要我们去跨越一样。那么接下来，话不多说，我们就开始逐一解答第三章的课后思考题了，有任何想法欢迎到留言区补充。<\/p><h2><strong><a href=\"https:\/\/time.geekbang.org\/column\/article\/380565\">第18课<\/a><\/strong><\/h2><p>在案例 1 中使用 Spring Data Redis 时，我们提到了 StringRedisTemplate 和 RedisTemplate。那么它们是如何被创建起来的呢？<\/p><p>实际上，当我们依赖 spring-boot-starter 时，我们就间接依赖了 spring-boot -autoconfigure。<\/p><p><img src=\"https:\/\/static001.geekbang.org\/resource\/image\/d0\/c1\/d07f1bc8f4aab19a834a347bb189abc1.png?wh=744x199\" alt=\"\"><\/p><p>在这个 JAR 中，存在下面这样的一个类，即 RedisAutoConfiguration。<\/p><pre><code>\n@Configuration(proxyBeanMethods = false)\n@ConditionalOnClass(RedisOperations.class)\n@EnableConfigurationProperties(RedisProperties.class)\n@Import({ LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class })\npublic class RedisAutoConfiguration {\n\n   @Bean\n   @ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)\n   @ConditionalOnSingleCandidate(RedisConnectionFactory.class)\n   public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) {\n      RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();\n      template.setConnectionFactory(redisConnectionFactory);\n      return template;\n   }\n\n   @Bean\n   @ConditionalOnMissingBean\n   @ConditionalOnSingleCandidate(RedisConnectionFactory.class)\n   public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) {\n      StringRedisTemplate template = new StringRedisTemplate();\n      template.setConnectionFactory(redisConnectionFactory);\n      return template;\n   }\n\n}\n<\/code><\/pre><p>从上述代码可以看出，当存在RedisOperations这个类时，就会创建 StringRedisTemplate 和 RedisTemplate 这两个 Bean。顺便说句，这个 RedisOperations 是位于 Spring Data Redis 这个 JAR 中。<\/p><p>再回到开头，RedisAutoConfiguration 是如何被发现的呢？实际上，它被配置在<\/p>","video_width":0,"column_could_sub":true,"article_ctime":1623600000,"score":"41623600000","video_media_map":{},"video_preview":{},"video":0,"video_time_arr":{"m":"","s":"","h":""},"video_total_seconds":0},"extra":{},"error":{}}